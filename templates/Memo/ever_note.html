{% extends "Memo/base.html" %}
{% block title %}Evernote{% endblock %}
{% block content %}

<div class="modern-note-container">


    <!-- Main Content -->
    <div class="note-layout">
    <!-- Sidebar với buttons ở trên -->
    <div class="note-sidebar" id="note-sidebar">
        <!-- Sidebar Header với Action Buttons -->
        <div class="sidebar-header">
            <!-- Action Buttons ở sidebar -->
            <div class="sidebar-actions">
                <button id="add-folder-btn" class="sidebar-action-btn folder-btn" title="Add Folder">
                    <i class="bi bi-folder-plus"></i>
                </button>
                <button class="sidebar-action-btn success-btn" id="add-note-btn" title="Add new note">
                    <i class="bi bi-plus"></i>
                </button>
                <button class="sidebar-action-btn primary-btn" id="share-link-btn" title="Share note">
                    <i class="bi bi-share"></i>
                </button>
                
                <!-- Toggle button -->
                <button class="sidebar-toggle" id="toggle-sidebar-btn">
                    <i class="bi bi-chevron-left"></i>
                </button>
            </div>
        </div>
        
        <!-- Rest of sidebar content -->
        <div id="folder-tree" class="folder-tree-container"></div>
        
        <div class="notes-section">
            <div class="notes-header">
                <span id="current-folder-name">All Notes</span>
                <span id="notes-count" class="badge bg-secondary">0</span>
            </div>
            <ul class="note-list" id="note-list"></ul>
        </div>
    </div>

    <!-- Editor - giờ sẽ có chiều cao lớn hơn -->
    <div class="note-editor-wrapper">
        <!-- Title -->
        <div class="title-group">
            <input type="text" 
                id="note-title" 
                placeholder="Note title..." 
                class="title-input"
                tabindex="1">
            
            <!-- Real save indicator element -->
            <div class="save-dot-indicator" id="save-dot-indicator">
                <div class="save-dot"></div>
            </div>
            
            <button type="button" id="clear-title-btn" class="clear-btn" title="Clear title">
                <i class="bi bi-x"></i>
            </button>
        </div>

            <!-- Toolbar -->
            <div class="editor-toolbar">
                <!-- Mobile Toolbar Toggle (chỉ hiện trên mobile) -->
                <div class="mobile-toolbar-toggle" id="mobile-toolbar-toggle">
                    <button class="toolbar-toggle-btn" title="Toggle toolbar">
                        <i class="bi bi-chevron-down"></i>
                    </button>
                </div>
                
                <!-- Toolbar Content (sẽ ẩn/hiện trên mobile) -->
                <div class="toolbar-content" id="toolbar-content">
                    <div class="toolbar-group">
                        <button id="search-btn" class="toolbar-btn" title="Search">
                            <i class="bi bi-search"></i>
                        </button>
                        <button id="upload-btn" class="toolbar-btn" title="Upload image">
                            <i class="bi bi-image"></i>
                        </button>
                        <label class="auto-scroll-toggle" title="Bật/tắt tự động cuộn theo cursor">
                            <input type="checkbox" id="autoScrollToggle" checked>
                            <span class="toggle-slider"></span>
                            <i class="fas fa-arrows-alt-v"></i>
                            <span class="toggle-label">Scroll</span>
                        </label>
                    </div>
                    
                    <div class="toolbar-divider"></div>
                    
                    <div class="toolbar-group">
                        <input type="color" class="color-picker" title="Text color" onchange="format('foreColor', this.value)">
                        <button class="toolbar-btn" id="bold-btn" title="Bold" onmousedown="toggleFormat(event, 'bold', this)">
                            <i class="bi bi-type-bold"></i>
                        </button>
                        <button class="toolbar-btn" id="italic-btn" title="Italic" onmousedown="toggleFormat(event, 'italic', this)">
                            <i class="bi bi-type-italic"></i>
                        </button>
                        <button class="toolbar-btn" id="underline-btn" title="Underline" onmousedown="toggleFormat(event, 'underline', this)">
                            <i class="bi bi-type-underline"></i>
                        </button>
                        <button class="toolbar-btn" id="strike-btn" title="Strikethrough" onmousedown="toggleFormat(event, 'strikeThrough', this)">
                            <i class="bi bi-type-strikethrough"></i>
                        </button>
                        
                    </div>

                    <div class="toolbar-divider"></div>

                    <div class="toolbar-group">
                        <select class="toolbar-select" onchange="format('formatBlock', this.value)">
                            <option value="p">Paragraph</option>
                            <option value="h1">Heading 1</option>
                            <option value="h2">Heading 2</option>
                            <option value="h3">Heading 3</option>
                        </select>
                        
                        <select class="toolbar-select" onchange="setFontSize(this.value)">
                            <option value="">Font Size</option>
                            <option value="12pt">12</option>
                            <option value="14pt">14</option>
                            <option value="16pt">16</option>
                            <option value="18pt">18</option>
                            <option value="20pt">20</option>
                            <option value="24pt">24</option>
                        </select>
                        
                        
                    </div>

                    <div class="toolbar-divider"></div>

                    <div class="toolbar-group">
                        <button class="toolbar-btn" id="ordered-btn" title="Ordered list" onmousedown="toggleFormat(event, 'insertOrderedList', this)">
                            <i class="bi bi-list-ol"></i>
                        </button>
                        <button class="toolbar-btn" id="unordered-btn" title="Bullet list" onmousedown="toggleFormat(event, 'insertUnorderedList', this)">
                            <i class="bi bi-list-ul"></i>
                        </button>
                        <button class="toolbar-btn" id="checklist-btn" title="Checklist" onmousedown="toggleChecklist(event, this)">
                            <i class="bi bi-check2-square"></i>
                        </button>
                        <button class="toolbar-btn" id="left-btn" title="Align left" onmousedown="toggleFormat(event, 'justifyLeft', this)">
                            <i class="bi bi-text-left"></i>
                        </button>
                        <button class="toolbar-btn" id="center-btn" title="Align center" onmousedown="toggleFormat(event, 'justifyCenter', this)">
                            <i class="bi bi-text-center"></i>
                        </button>
                        <button class="toolbar-btn" id="right-btn" title="Align right" onmousedown="toggleFormat(event, 'justifyRight', this)">
                            <i class="bi bi-text-right"></i>
                        </button>
                    </div>
                </div>
            </div>

        <!-- Editor Content -->
        <div id="evernote-editor" class="note-editor" contenteditable="true" tabindex="2"></div>
        
        <!-- Meta Info -->
        <div id="note-meta" class="note-meta"></div>
    </div>
</div>

<!-- Modals cho Folder Management -->
<div class="modal fade" id="folderModal" tabindex="-1">
    <div class="modal-dialog modal-dialog-centered">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title" id="folderModalTitle">
                    <i class="bi bi-folder me-2"></i>
                    Create Folder
                </h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal" tabindex="4"></button>
            </div>
            <div class="modal-body">
                <form id="folderForm">
                    <div class="mb-3">
                        <label for="folder-name" class="form-label">Folder Name</label>
                        <input type="text" 
                               class="form-control" 
                               id="folder-name" 
                               required
                               tabindex="1"
                               placeholder="Enter folder name...">
                    </div>
                    <div class="mb-3">
                        <label for="parent-folder" class="form-label">Parent Folder</label>
                        <select class="form-select" 
                                id="parent-folder"
                                tabindex="2">
                            <option value="">Root Level</option>
                        </select>
                    </div>
                    <input type="hidden" id="folder-id">
                </form>
            </div>
            <div class="modal-footer">
                <button type="button" 
                        class="btn btn-secondary" 
                        data-bs-dismiss="modal"
                        tabindex="4">Cancel</button>
                <button type="button" 
                        class="btn btn-primary" 
                        id="save-folder-btn"
                        tabindex="3">Save</button>
            </div>
        </div>
    </div>
</div>

<div class="modal fade" id="deleteFolderModal" tabindex="-1" data-bs-backdrop="static" data-bs-keyboard="true">
    <div class="modal-dialog modal-dialog-centered">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title">
                    <i class="bi bi-exclamation-triangle me-2"></i>
                    Delete Folder
                </h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body">
                <p class="mb-3">What would you like to do with the contents of this folder?</p>
                <div class="form-check mb-2">
                    <input class="form-check-input" type="radio" name="deleteAction" id="moveToParent" value="move_to_parent" checked>
                    <label class="form-check-label" for="moveToParent">
                        <strong>Move to parent folder</strong><br>
                        <small class="text-muted">Notes and subfolders will be moved to the parent folder</small>
                    </label>
                </div>
                <div class="form-check">
                    <input class="form-check-input" type="radio" name="deleteAction" id="deleteAll" value="delete_all">
                    <label class="form-check-label" for="deleteAll">
                        <strong>Delete everything</strong><br>
                        <small class="text-muted text-danger">Permanently delete all notes and subfolders</small>
                    </label>
                </div>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancel</button>
                <button type="button" class="btn btn-danger" id="confirm-delete-folder-btn">
                    Delete
                </button>
            </div>
        </div>
    </div>
</div>

<!-- Modals -->
<div class="modal fade" id="shareLinkModal" tabindex="-1">
    <div class="modal-dialog modal-dialog-centered">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title">
                    <i class="bi bi-share me-2"></i>
                    Share Note
                </h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
            </div>
            <div class="modal-body">
                <div id="share-link-content">
                    <p><i class="bi bi-hourglass-split me-2"></i>Creating share link...</p>
                </div>
                <div id="share-link-result" style="display: none;">
                    <div class="mb-3">
                        <label for="share-link-input" class="form-label">Share Link:</label>
                        <div class="input-group">
                            <input type="text" class="form-control" id="share-link-input" readonly>
                            <button class="btn btn-outline-secondary" type="button" id="copy-link-btn">
                                <i class="bi bi-clipboard"></i>
                            </button>
                        </div>
                    </div>
                    <div class="alert alert-info">
                        <i class="bi bi-info-circle me-2"></i>
                        This link allows anyone to view the note without login.
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<div class="modal fade" id="searchModal" tabindex="-1">
    <div class="modal-dialog modal-dialog-centered modal-sm">
        <div class="modal-content">
            <div class="modal-body py-2">
                <input type="text" id="search-textbox" class="form-control" placeholder="Search...">
            </div>
        </div>
    </div>
</div>

<!-- Image Lightbox -->
<div id="imageLightbox" class="image-lightbox">
    <span class="lightbox-close">&times;</span>
    <img class="lightbox-content" id="lightboxImg">
    <div class="lightbox-caption" id="lightboxCaption"></div>
</div>

<style>
:root {
    --alert-success-color: #28a745; /* Green */
    --alert-success-color-rgb: 40, 167, 69;
    --alert-danger-color: #dc3545;
    --alert-danger-color-rgb: 220, 53, 69;
    --alert-warning-color: #ffc107;
    --alert-warning-color-rgb: 255, 193, 7;
    --primary-color-rgb: 52, 152, 219;
    --secondary-color-rgb: 108, 117, 125;
}

/* ===== BASE STYLES ===== */
.modern-note-container {
    max-width: 100%;
    margin: 0 auto;
    padding: 1.5rem;
    min-height: calc(100vh - 80px);
    display: flex;
    flex-direction: column;
    background: linear-gradient(135deg, var(--gradient-start) 0%, var(--gradient-end) 100%);
    border-radius: 20px;
    box-shadow: 0 20px 40px rgba(0,0,0,0.1);
    font-family: 'Inter', 'Segoe UI', 'Roboto', sans-serif;
}

.note-layout {
    display: flex;
    flex: 1;
    gap: 1.5rem;
    min-height: calc(100vh - 160px);
}

.note-layout.sidebar-collapsed {
    gap: 1rem;
}

.note-layout.sidebar-collapsed .note-editor-wrapper {
    margin-left: 0;
    width: 100%;
    flex: 1;
}

/* ===== HEADER STYLES ===== */
.header-left {
    display: flex;
    align-items: center;
    gap: 1rem;
}

.note-title {
    font-size: 2rem;
    font-weight: 700;
    color: var(--text-color);
    margin: 0;
    display: flex;
    align-items: center;
    gap: 0.5rem;
}

.note-title i {
    color: var(--primary-color);
    font-size: 1.8rem;
}

.header-actions {
    display: flex;
    gap: 0.5rem;
}

/* ===== SIDEBAR STYLES ===== */
.note-sidebar {
    width: 280px;
    min-width: 280px;
    background: rgba(255,255,255,0.9);
    border-radius: 15px;
    box-shadow: 0 4px 20px rgba(0,0,0,0.1);
    display: flex;
    flex-direction: column;
    backdrop-filter: blur(10px);
    transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    position: relative;
    overflow: hidden;
}

.note-sidebar.collapsed {
    width: 60px;
    min-width: 60px;
    background: transparent;
    box-shadow: none;
    border-radius: 0;
}

.sidebar-header {
    display: flex;
    flex-direction: column;
    gap: 1rem;
    padding: 1.5rem;
    border-bottom: 1px solid rgba(0,0,0,0.1);
    background: rgba(255,255,255,0.05);
}

.note-sidebar.collapsed .sidebar-header {
    padding: 1rem 0.5rem;
    flex-direction: column;
    align-items: center;
}

.sidebar-title {
    display: flex;
    justify-content: space-between;
    align-items: center;
}

.sidebar-title h3 {
    margin: 0;
    font-size: 1.2rem;
    font-weight: 600;
    color: var(--text-color);
    transition: all 0.3s ease;
}

.note-sidebar.collapsed .sidebar-title,
.note-sidebar.collapsed .sidebar-header h3,
.note-sidebar.collapsed .folder-tree-container,
.note-sidebar.collapsed .notes-section {
    display: none;
}

.sidebar-actions {
    display: flex;
    gap: 0.5rem;
    align-items: center;
    flex-wrap: nowrap;
    justify-content: center;
}

.note-sidebar.collapsed .sidebar-actions {
    flex-direction: column;
    gap: 0.25rem;
}

.sidebar-action-btn {
    width: 36px;
    height: 36px;
    border: none;
    border-radius: 10px;
    cursor: pointer;
    transition: all 0.3s ease;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 1rem;
    box-shadow: 0 2px 8px rgba(0,0,0,0.1);
    flex-shrink: 0;
}

.sidebar-action-btn:hover {
    transform: translateY(-1px);
    box-shadow: 0 4px 12px rgba(0,0,0,0.15);
}

.sidebar-action-btn.success-btn {
    background: linear-gradient(135deg, var(--alert-success-color), #27ae60);
    color: white;
}

.sidebar-action-btn.primary-btn {
    background: linear-gradient(135deg, var(--primary-color), var(--accent-color));
    color: white;
}

.sidebar-action-btn.folder-btn {
    background: linear-gradient( 135deg, #f39c12, #e67e22);
    color: white;
}

.sidebar-action-btn.success-btn:hover {
    background: linear-gradient(135deg, #27ae60, #2ecc71);
    box-shadow: 0 4px 12px rgba(39, 174, 96, 0.3);
}

.sidebar-action-btn.primary-btn:hover {
    box-shadow: 0 4px 12px rgba(var(--primary-color-rgb), 0.3);
}

.sidebar-action-btn.folder-btn:hover {
    background: linear-gradient(135deg, #e67e22, #d35400);
    box-shadow: 0 4px 12px rgba(243, 156, 18, 0.3);
}

.sidebar-action-btn.success-btn:active {
    animation: buttonPulse 0.3s ease;
}

@keyframes buttonPulse {
    0% { transform: scale(1); }
    50% { transform: scale(1.05); }
    100% { transform: scale(1); }
}

.sidebar-toggle {
    background: rgba(var(--primary-color-rgb), 0.1);
    border: 1px solid rgba(0,0,0,0.1);
    color: var(--secondary-color);
    font-size: 1rem;
    cursor: pointer;
    padding: 0.5rem;
    border-radius: 8px;
    transition: all 0.3s ease;
    box-shadow: 0 2px 8px rgba(0,0,0,0.1);
    width: 36px;
    height: 36px;
    display: flex;
    align-items: center;
    justify-content: center;
    margin-left: auto;
    position: relative;
    z-index: 100; /* Fixed invalid z-index */
    flex-shrink: 0;
}

.sidebar-toggle:hover {
    background: var(--primary-color);
    color: white;
    transform: scale(1.05);
}

.sidebar-toggle i {
    transition: transform 0.3s ease;
}

.note-sidebar.collapsed .sidebar-toggle {
    margin: 0;
    background: rgba(255,255,255,0.95);
    box-shadow: 0 4px 12px rgba(0,0,0,0.15);
    border-radius: 12px;
}

.note-sidebar.collapsed .sidebar-toggle i {
    transform: rotate(180deg);
}

/* ===== FOLDER TREE STYLES ===== */
.folder-tree-container {
    max-height: 40vh;
    overflow-y: auto;
    border-bottom: 1px solid rgba(0,0,0,0.1);
    padding: 0.5rem 0;
    scrollbar-width: thin;
    scrollbar-color: #cbd5e0 #f7fafc;
    -webkit-overflow-scrolling: touch;
}

.folder-tree-container::-webkit-scrollbar {
    width: 8px;
    height: 8px;
}

.folder-tree-container::-webkit-scrollbar-track {
    background: #f7fafc;
    border-radius: 4px;
}

.folder-tree-container::-webkit-scrollbar-thumb {
    background: #cbd5e0;
    border-radius: 4px;
}

.folder-tree-container::-webkit-scrollbar-thumb:hover {
    background: #a0aec0;
}

.folder-tree-item {
    user-select: none;
    transition: all 0.2s ease;
}

.folder-item-content {
    display: flex;
    align-items: center;
    padding: 0.4rem 0.75rem;
    margin: 1px 0;
    border-radius: 8px;
    cursor: pointer;
    transition: all 0.2s ease;
    position: relative;
    min-height: 32px;
}

.folder-item-content:hover {
    background: rgba(var(--primary-color-rgb), 0.08);
}

.folder-item-content.selected {
    background: var(--primary-color);
    color: white;
}

.folder-toggle {
    width: 16px;
    height: 16px;
    display: flex;
    align-items: center;
    justify-content: center;
    margin-right: 0.5rem;
    border: none;
    background: none;
    cursor: pointer;
    color: var(--secondary-color);
    transition: all 0.2s ease;
    flex-shrink: 0;
}

.folder-toggle:hover {
    color: var(--primary-color);
}

.folder-toggle i {
    font-size: 0.75rem;
    transition: transform 0.2s ease;
}

.folder-toggle.expanded i {
    transform: rotate(90deg);
}

.folder-toggle.no-children {
    visibility: hidden;
}

.folder-icon {
    margin-right: 0.5rem;
    color: #f39c12;
    font-size: 0.9rem;
    flex-shrink: 0;
}

.folder-item-content.selected .folder-icon {
    color: rgba(255, 255, 255, 0.9);
}

.folder-name {
    flex: 1;
    font-weight: 500;
    font-size: 0.9rem;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
}

.folder-notes-count {
    background: rgba(var(--secondary-color-rgb), 0.2);
    color: var(--secondary-color);
    font-size: 0.7rem;
    padding: 0.2rem 0.4rem;
    border-radius: 10px;
    margin-left: 0.5rem;
    flex-shrink: 0;
}

.folder-item-content.selected .folder-notes-count {
    background: rgba(255, 255, 255, 0.2);
    color: rgba(255, 255, 255, 0.8);
}

.folder-actions {
    display: flex;
    gap: 0.25rem;
    margin-left: 0.5rem;
    opacity: 0;
    transition: all 0.2s ease;
    flex-shrink: 0;
}

.folder-item-content:hover .folder-actions,
.folder-item-content.selected .folder-actions {
    opacity: 1;
}

.folder-action-btn {
    width: 20px;
    height: 20px;
    border: none;
    background: rgba(var(--secondary-color-rgb), 0.1);
    border-radius: 4px;
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    transition: all 0.2s ease;
}

.folder-action-btn:hover {
    background: rgba(var(--secondary-color-rgb), 0.2);
}

.folder-action-btn i {
    font-size: 0.7rem;
    color: var(--secondary-color);
}

.folder-item-content.selected .folder-action-btn {
    background: rgba(255, 255, 255, 0.15);
}

.folder-item-content.selected .folder-action-btn:hover {
    background: rgba(255, 255, 255, 0.25);
}

.folder-item-content.selected .folder-action-btn i {
    color: rgba(255, 255, 255, 0.8);
}

.folder-children {
    margin-left: 1.5rem;
    transition: all 0.3s ease;
    overflow: hidden;
}

.folder-children.collapsed {
    max-height: 0;
    opacity: 0;
}

.folder-children.expanded {
    max-height: 1000px;
    opacity: 1;
    margin: 0.25rem 0;
}

.all-notes-content {
    display: flex;
    align-items: center;
    padding: 0.5rem 0.75rem;
    border-radius: 8px;
    cursor: pointer;
    transition: all 0.2s ease;
    background: rgba(var(--info-color-rgb, 23, 162, 184), 0.05);
    border: 1px solid rgba(var(--info-color-rgb, 23, 162, 184), 0.2);
}

.all-notes-content:hover {
    background: rgba(var(--info-color-rgb, 23, 162, 184), 0.1);
}

.all-notes-content.selected {
    background: var(--info-color, #17a2b8);
    color: white;
}

.all-notes-icon {
    margin-right: 0.5rem;
    color: var(--info-color, #17a2b8);
    font-size: 0.9rem;
}

.all-notes-content.selected .all-notes-icon {
    color: white;
}

.all-notes-title {
    flex: 1;
    font-weight: 600;
    font-size: 0.9rem;
}

/* ===== NOTES SECTION ===== */
.notes-section {
    flex: 1;
    display: flex;
    flex-direction: column;
    min-height: 0;
}

.notes-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 0.75rem 1rem;
    border-bottom: 1px solid rgba(0,0,0,0.1);
    background: rgba(0,0,0,0.02);
    font-weight: 600;
    position: sticky;
    top: 0;
    z-index: 10;
    flex-shrink: 0;
}

.notes-header #current-folder-name {
    font-size: 0.9rem;
    color: var(--text-color);
}

.notes-header #notes-count {
    font-size: 0.75rem;
    padding: 0.25rem 0.5rem;
}

.note-list {
    flex: 1;
    overflow-y: auto;
    padding: 0.5rem 0;
    margin: 0;
    list-style: none;
    max-height: calc(100vh - 200px);
    scrollbar-width: thin;
    scrollbar-color: #cbd5e0 #f7fafc;
    -webkit-overflow-scrolling: touch;
    min-height: 0;
}

.note-list::-webkit-scrollbar {
    width: 8px;
    height: 8px;
}

.note-list::-webkit-scrollbar-track {
    background: #f7fafc;
    border-radius: 4px;
}

.note-list::-webkit-scrollbar-thumb {
    background: #cbd5e0;
    border-radius: 4px;
}

.note-list::-webkit-scrollbar-thumb:hover {
    background: #a0aec0;
}

.note-item {
    padding: 0.75rem 1rem;
    cursor: move;
    border-bottom: 1px solid rgba(0,0,0,0.05);
    transition: all 0.2s ease;
    color: var(--text-color);
    font-size: 0.9rem;
    line-height: 1.3;
    border-radius: 6px;
    margin: 0 0.5rem;
    position: relative;
    display: flex;
    align-items: center;
    justify-content: space-between;
}

.note-item:hover {
    background: rgba(var(--primary-color-rgb), 0.08);
    transform: translateY(-1px);
    box-shadow: 0 2px 8px rgba(0,0,0,0.1);
}

.note-item.active {
    background: var(--primary-color);
    color: white;
    font-weight: 500;
}

.note-item.dragging {
    opacity: 0.5;
    transform: rotate(2deg);
    z-index: 1000;
    box-shadow: 0 8px 25px rgba(0,0,0,0.3);
}

.note-item::before {
    content: '⋮⋮';
    position: absolute;
    left: 0.25rem;
    top: 50%;
    transform: translateY(-50%);
    color: var(--secondary-color);
    font-size: 0.8rem;
    opacity: 0;
    transition: opacity 0.2s ease;
}

.note-item:hover::before {
    opacity: 0.5;
}

.note-item.active::before {
    color: rgba(255,255,255,0.7);
}

.note-item-content {
    flex: 1;
    min-width: 0;
    cursor: pointer;
    overflow: hidden;
    margin-right: 0.5rem;
    display: flex;
    align-items: center;
}

.note-item-actions {
    display: flex;
    align-items: center;
    gap: 0.25rem;
    opacity: 0;
    transition: opacity 0.2s ease;
    flex-shrink: 0;
}

.note-item:hover .note-item-actions,
.note-item.active .note-item-actions {
    opacity: 1;
}

.note-delete-btn {
    width: 24px;
    height: 24px;
    border: none;
    background: rgba(220, 53, 69, 0.1);
    color: var(--alert-danger-color);
    border-radius: 4px;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: all 0.2s ease;
    font-size: 0.8rem;
}

.note-delete-btn:hover {
    background: var(--alert-danger-color);
    color: white;
    transform: scale(1.1);
}

.note-delete-btn:active {
    transform: scale(0.95);
}

.note-icon {
    margin-right: 0.5rem;
    font-size: 0.85rem;
    flex-shrink: 0;
    transition: color 0.2s ease;
}

.note-icon.in-folder {
    color: #f39c12;
}

.note-icon.root-level {
    color: var(--info-color, #17a2b8);
}

.note-item.active .note-icon {
    color: rgba(255, 255, 255, 0.9);
}

.note-title-text {
    flex: 1;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
}

/* ===== ACTION BUTTONS ===== */
.action-btn {
    width: 45px;
    height: 45px;
    border: none;
    border-radius: 12px;
    cursor: pointer;
    transition: all 0.3s ease;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 1.2rem;
    box-shadow: 0 4px 12px rgba(0,0,0,0.1);
}

.action-btn:hover {
    transform: translateY(-2px);
    box-shadow: 0 8px 20px rgba(0,0,0,0.2);
}

.success-btn {
    background: linear-gradient(135deg, var(--alert-success-color), #27ae60);
    color: white;
}

.primary-btn {
    background: linear-gradient(135deg, var(--primary-color), var(--accent-color));
    color: white;
}

.danger-btn {
    background: linear-gradient(135deg, var(--alert-danger-color), #c0392b);
    color: white;
}

.folder-btn {
    background: linear-gradient(135deg, #f39c12, #e67e22);
    color: white;
}

.folder-btn:hover {
    background: linear-gradient(135deg, #e67e22, #d35400);
    transform: translateY(-2px);
    box-shadow: 0 8px 20px rgba(243, 156, 18, 0.3);
}

/* ===== EDITOR STYLES ===== */
.note-editor-wrapper {
    flex: 1;
    display: flex;
    flex-direction: column;
    background: rgba(255,255,255,0.9);
    border-radius: 15px;
    box-shadow: 0 4px 20px rgba(0,0,0,0.1);
    backdrop-filter: blur(10px);
    min-height: calc(100vh - 200px);
    transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    position: relative;
}

.editor-toolbar {
    display: flex;
    flex-wrap: wrap;
    gap: 0.5rem;
    padding: 1rem 1.5rem;
    border-bottom: 1px solid rgba(0,0,0,0.1);
    position: sticky;
    top: 0;
    z-index: 100;
    background: rgba(255,255,255,0.98);
    backdrop-filter: blur(15px);
    box-shadow: 0 2px 8px rgba(0,0,0,0.1);
    transition: all 0.3s ease;
}

.editor-toolbar.scrolled {
    box-shadow: 0 4px 12px rgba(0,0,0,0.15);
    background: rgba(255,255,255,0.99);
}

.title-group {
    position: relative;
    margin: 0.5rem 0.5rem 0;
}

.title-input {
    width: 100%;
    font-size: 1.4rem;
    font-weight: 600;
    padding: 1rem 3rem 1rem 1rem;
    border: none;
    border-radius: 12px;
    background: rgba(0,0,0,0.02);
    color: var(--text-color);
    transition: all 0.3s ease;
    border-left: 3px solid transparent;
    position: relative;
}

.title-input:focus {
    outline: none;
    background: rgba(0,0,0,0.05);
    transform: translateY(-1px);
    box-shadow: 0 4px 12px rgba(var(--primary-color-rgb), 0.15);
}

.title-input::placeholder {
    color: var(--secondary-color);
    font-weight: 400;
}

.title-input.saving {
    border-left-color: #ffc107;
    background: rgba(255, 193, 7, 0.05);
}

.title-input.saved {
    border-left-color: var(--alert-success-color);
    background: rgba(var(--alert-success-color-rgb), 0.05);
}

.title-input.error {
    border-left-color: var(--alert-danger-color);
    background: rgba(var(--alert-danger-color-rgb), 0.05);
}

.save-dot-indicator {
    position: absolute;
    top: 50%;
    right: 1rem;
    transform: translateY(-50%);
    width: 12px;
    height: 12px;
    z-index: 10;
    opacity: 0;
    transition: opacity 0.3s ease;
    pointer-events: none;
}

.save-dot {
    width: 100%;
    height: 100%;
    border-radius: 50%;
    background: transparent;
    transition: all 0.3s ease;
}

.title-input.saving ~ .save-dot-indicator,
.title-input.saved ~ .save-dot-indicator,
.title-input.error ~ .save-dot-indicator {
    opacity: 1;
}

.title-input.saving ~ .save-dot-indicator .save-dot {
    background: #ffc107;
    animation: pulseAnimation 1s ease-in-out infinite;
}

.title-input.saved ~ .save-dot-indicator .save-dot {
    background: var(--alert-success-color);
    animation: popAnimation 0.5s ease;
}

.title-input.error ~ .save-dot-indicator .save-dot {
    background: var(--alert-danger-color);
    animation: shakeAnimation 0.5s ease;
}

@keyframes pulseAnimation {
    0%, 100% { transform: scale(1); opacity: 1; }
    50% { transform: scale(1.3); opacity: 0.7; }
}

@keyframes popAnimation {
    0% { transform: scale(0.5); opacity: 0.5; }
    50% { transform: scale(1.4); opacity: 1; }
    100% { transform: scale(1); opacity: 1; }
}

@keyframes shakeAnimation {
    0%, 20%, 40%, 60%, 80% { transform: translateX(0); }
    10%, 30%, 50%, 70% { transform: translateX(-2px); }
    15%, 35%, 55%, 75% { transform: translateX(2px); }
}

.clear-btn {
    position: absolute;
    right: 2.5rem;
    top: 50%;
    transform: translateY(-50%);
    background: none;
    border: none;
    color: var(--secondary-color);
    font-size: 1.2rem;
    cursor: pointer;
    padding: 0.5rem;
    border-radius: 6px;
    transition: all 0.3s ease;
    z-index: 5;
}

.clear-btn:hover {
    background: rgba(0,0,0,0.05);
    color: var(--alert-danger-color);
}

.toolbar-group {
    display: flex;
    gap: 0.25rem;
    align-items: center;
}

.toolbar-btn {
    width: 36px;
    height: 36px;
    border: none;
    border-radius: 8px;
    background: rgba(0,0,0,0.02);
    color: var(--text-color);
    cursor: pointer;
    transition: all 0.3s ease;
    display: flex;
    align-items: center;
    justify-content: center;
}

.toolbar-btn:hover {
    background: rgba(var(--primary-color-rgb), 0.1);
    color: var(--primary-color);
}

.toolbar-btn.active {
    background: var(--primary-color);
    color: white;
}

.toolbar-select {
    min-width: 100px;
    padding: 0.5rem;
    border: 1px solid rgba(0,0,0,0.1);
    border-radius: 6px;
    background: rgba(0,0,0,0.02);
    color: var(--text-color);
    font-size: 0.9rem;
}

.color-picker {
    width: 36px;
    height: 36px;
    border: none;
    border-radius: 8px;
    cursor: pointer;
    padding: 0;
}

.toolbar-divider {
    width: 1px;
    height: 24px;
    background: rgba(0,0,0,0.1);
    margin: 0 0.5rem;
}

.note-editor {
    flex: 1;
    padding: 1.5rem;
    border: none;
    outline: none;
    font-size: 1.1rem;
    line-height: 1.4;
    color: var(--text-color);
    min-height: calc(100vh - 350px);
    overflow-y: auto;
    font-family: 'Merriweather', 'Times New Roman', 'Noto Serif', serif;
}

.note-editor p {
    margin: 0 0 0.5rem 0; /* Giảm từ 1rem xuống 0.5rem */
    line-height: 1.4; /* Thêm line-height riêng cho p */
}

.note-editor h1, .note-editor h2, .note-editor h3 {
    margin: 1rem 0 0.5rem 0; /* Giảm margin bottom từ 1rem xuống 0.5rem */
    line-height: 1.3; /* Thêm line-height cho headings */
    color: var(--text-color);
}

.note-editor table {
    width: 100%;
    border-collapse: collapse;
    margin: 1rem 0;
}

.note-editor th, .note-editor td {
    border: 1px solid rgba(0,0,0,0.1);
    padding: 0.75rem;
    text-align: left;
}

.note-editor ul, .note-editor ol {
    margin: 0.5rem 0;
    padding-left: 1.5rem;
    line-height: 1.4;
}

.note-editor li {
    margin-bottom: 0.25rem; /* Khoảng cách nhỏ giữa các list items */
}

.note-editor th {
    background: rgba(var(--primary-color-rgb), 0.1);
    font-weight: 600;
}

.note-editor div {
    line-height: 1.4; /* Đảm bảo div cũng có line-height nhất quán */
}

.note-editor blockquote {
    margin: 0.5rem 0;
    padding: 0.5rem 1rem;
    border-left: 4px solid var(--primary-color);
    background: rgba(var(--primary-color-rgb), 0.05);
    line-height: 1.4;
}

.note-meta {
    padding: 1rem 1.5rem; /* Removed duplicate padding declaration */
    font-size: 0.9rem;
    color: var(--secondary-color);
    border-top: 1px solid rgba(0,0,0,0.1);
    background: rgba(0,0,0,0.02);
    border-radius: 0 0 15px 15px;
}

/* ===== AUTO-SCROLL TOGGLE ===== */
.auto-scroll-toggle {
    display: flex;
    align-items: center;
    gap: 0.5rem;
    cursor: pointer;
    padding: 0.5rem 0.75rem;
    border-radius: 8px;
    transition: all 0.3s ease;
    background: rgba(255,255,255,0.1);
    border: 1px solid rgba(0,0,0,0.1);
    user-select: none;
    font-size: 0.85rem;
    color: var(--text-color);
}

.auto-scroll-toggle:hover {
    background: rgba(var(--primary-color-rgb), 0.1);
    border-color: var(--primary-color);
}

.auto-scroll-toggle input[type="checkbox"] {
    display: none;
}

.toggle-slider {
    position: relative;
    width: 34px;
    height: 18px;
    background: #ccc;
    border-radius: 20px;
    transition: all 0.3s ease;
    flex-shrink: 0;
}

.toggle-slider::before {
    content: '';
    position: absolute;
    width: 14px;
    height: 14px;
    border-radius: 50%;
    background: white;
    top: 2px;
    left: 2px;
    transition: all 0.3s ease;
    box-shadow: 0 2px 4px rgba(0,0,0,0.2);
}

.auto-scroll-toggle input:checked + .toggle-slider {
    background: var(--primary-color);
}

.auto-scroll-toggle input:checked + .toggle-slider::before {
    transform: translateX(16px);
}

.auto-scroll-toggle i {
    font-size: 0.9rem;
    transition: color 0.3s ease;
}

.auto-scroll-toggle input:checked ~ i {
    color: var(--primary-color);
}

.toggle-label {
    font-weight: 500;
    white-space: nowrap;
}

.auto-scroll-toggle input:checked ~ .toggle-label {
    color: var(--primary-color);
}

/* ===== IMAGE STYLES ===== */
.image-container {
    margin: 1rem 0;
    position: relative;
    display: inline-block;
    border-radius: 12px;
    overflow: hidden;
    box-shadow: 0 4px 12px rgba(0,0,0,0.1);
    transition: all 0.3s ease;
    background: var(--card-bg);
}

.image-container:hover {
    transform: translateY(-2px);
    box-shadow: 0 8px 25px rgba(0,0,0,0.15);
}

.image-container img {
    max-width: 100%;
    height: auto;
    display: block;
    cursor: pointer;
    transition: transform 0.3s ease;
}

.image-container:hover img {
    transform: scale(1.02);
}

.delete-image-btn {
    position: absolute;
    top: 8px;
    right: 8px;
    background: rgba(220, 53, 69, 0.9);
    color: white;
    border: none;
    border-radius: 50%;
    width: 32px;
    height: 32px;
    cursor: pointer;
    font-size: 14px;
    display: flex;
    align-items: center;
    justify-content: center;
    opacity: 0;
    transition: all 0.3s ease;
    backdrop-filter: blur(10px);
}

.image-container:hover .delete-image-btn {
    opacity: 1;
}

.delete-image-btn:hover {
    background: rgba(220, 53, 69, 1);
    transform: scale(1.1);
}

.image-info {
    position: absolute;
    bottom: 0;
    left: 0;
    right: 0;
    background: linear-gradient(transparent, rgba(0,0,0,0.7));
    color: white;
    padding: 1rem 0.75rem 0.5rem;
    font-size: 0.8rem;
    opacity: 0;
    transition: opacity 0.3s ease;
}

.image-container:hover .image-info {
    opacity: 1;
}

.image-filename {
    display: block;
    font-weight: 500;
    margin-bottom: 0.25rem;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
}

.image-size {
    display: block;
    opacity: 0.8;
    font-size: 0.7rem;
}

.images-section {
    border-top: 1px solid rgba(0,0,0,0.1);
    padding-top: 1rem;
    margin-top: 1rem;
}

#upload-progress {
    display: none;
    position: fixed;
    top: 20px;
    right: 20px;
    background: var(--primary-color0);
    color: white;
    padding: 1rem;
    border-radius: 8px;
    box-shadow: 0 4px 12px rgba(0,0,0,0.3);
    z-index: 9999;
}

.image-toast {
    position: fixed;
    top: 80px;
    right: 20px;
    padding: 0.75rem 1rem;
    border-radius: 8px;
    box-shadow: 0 4px 12px rgba(0,0,0,0.3);
    z-index: 10000;
    display: flex;
    align-items: center;
    gap: 0.5rem;
    font-size: 0.9rem;
    font-weight: 500;
    opacity: 0;
    transform: translateX(100%);
    transition: all 0.3s ease;
}

.image-toast.show {
    opacity: 1;
    transform: translateX(0);
}

.image-toast-success {
    background: var(--alert-success-color);
    color: white;
}

.image-toast-error {
    background: var(--alert-danger-color);
    color: white;
}

/* ===== LIGHTBOX STYLES ===== */
.image-lightbox {
    display: none;
    position: fixed;
    z-index: 10000;
    left: 0;
    top: 0;
    width: 100%;
    height: 100%;
    background: rgba(0,0,0,0.9);
    backdrop-filter: blur(5px);
}

.lightbox-content {
    margin: auto;
    display: block;
    width: 90%;
    max-width: 1200px;
    max-height: 80vh;
    object-fit: contain;
    border-radius: 8px;
    margin-top: 5%;
    box-shadow: 0 20px 40px rgba(0,0,0,0.3);
    opacity: 0;
    transition: opacity 0.3s ease;
}

.lightbox-close {
    position: absolute;
    top: 20px;
    right: 35px;
    color: white;
    font-size: 40px;
    font-weight: bold;
    cursor: pointer;
    z-index: 10001;
}

.lightbox-caption {
    margin: auto;
    display: block;
    width: 80%;
    max-width: 700px;
    text-align: center;
    color: #ccc;
    padding: 10px 0;
}

/* ===== DRAG AND DROP STYLES ===== */
.folder-item-content.drag-over {
    background: rgba(var(--success-color-rgb, 40, 167, 69), 0.2);
    border: 2px dashed var(--success-color, #28a745);
    transform: scale(1.02);
}

.folder-item-content.drag-over::after {
    content: 'Drop note here';
    position: absolute;
    right: 0.5rem;
    top: 50%;
    transform: translateY(-50%);
    font-size: 0.7rem;
    color: var(--success-color, #28a745);
    font-weight: 600;
    pointer-events: none;
}

.all-notes-content.drag-over {
    background: rgba(var(--info-color-rgb, 23, 162, 184), 0.3);
    border: 2px dashed var(--info-color, #17a2b8);
    transform: scale(1.02);
}

.all-notes-content.drag-over::after {
    content: 'Drop to move to root';
    position: absolute;
    right: 0.5rem;
    top: 50%;
    transform: translateY(-50%);
    font-size: 0.7rem;
    color: var(--info-color, #17a2b8);
    font-weight: 600;
    pointer-events: none;
}

.drag-feedback {
    position: fixed;
    top: 0;
    left: 0;
    background: var(--primary-color);
    color: white;
    padding: 0.5rem 1rem;
    border-radius: 6px;
    font-size: 0.9rem;
    font-weight: 500;
    z-index: 10000;
    pointer-events: none;
    box-shadow: 0 4px 12px rgba(0,0,0,0.3);
    opacity: 0.9;
    transform: translate(-50%, -50%);
}

@keyframes moveSuccess {
    0% { transform: scale(1); }
    50% { transform: scale(1.05); background: var(--success-color); }
    100% { transform: scale(1); }
}

.move-success {
    animation: moveSuccess 0.5s ease;
}

/* ===== MODAL STYLES ===== */
.form-control,
.form-select {
    border: 1px solid #212529;
}

.modal-backdrop {
    z-index: 1040;
}

.modal {
    z-index: 1050;
}

.btn:disabled {
    opacity: 0.6;
    cursor: not-allowed;
}

.btn:disabled .bi-hourglass-split {
    animation: spin 1s linear infinite;
}

@keyframes spin {
    from { transform: rotate(0deg); }
    to { transform: rotate(360deg); }
}

.modal .form-control:focus,
.modal .form-select:focus {
    border-color: var(--primary-color);
    box-shadow: 0 0 0 0.2rem rgba(var(--primary-color-rgb), 0.25);
}

.form-control.is-invalid {
    border-color: var(--alert-danger-color);
    animation: shake 0.5s ease-in-out;
}

.modal .btn:focus {
    box-shadow: 0 0 0 0.2rem rgba(var(--primary-color-rgb), 0.25);
}

.modal [tabindex]:focus {
    outline: 2px solid var(--primary-color);
    outline-offset: 2px;
}
/* ===== MOBILE TOOLBAR TOGGLE ===== */
.mobile-toolbar-toggle {
    display: none;
    justify-content: center;
    align-items: center;
}

.toolbar-toggle-btn {
    background: rgba(var(--primary-color-rgb), 0.1);
    border: 1px solid rgba(var(--primary-color-rgb), 0.2); /* Fixed invalid variable and syntax */
    color: var(--primary-color);
    border-radius: 8px;
    cursor: pointer;
    transition: all 0.3s ease;
    display: flex;
    align-items: center;
    gap: 0.5rem;
    font-size: 0.9rem;
    font-weight: 500;
}

.toolbar-toggle-btn:hover {
    background: rgba(var(--primary-color-rgb), 0.15);
    transform: translateY(-1px);
}

.toolbar-toggle-btn i {
    transition: transform 0.3s ease;
    font-size: 1rem;
}

.toolbar-toggle-btn.expanded i {
    transform: rotate(180deg);
}

.toolbar-toggle-btn::after {
    content: 'Tools';
    margin-left: 0.25rem;
}

.toolbar-toggle-btn.expanded::after {
    content: 'Hide';
}

.toolbar-content {
    display: flex;
    flex-wrap: wrap;
    gap: 0.5rem;
    align-items: center;
}

/* ===== RESPONSIVE STYLES ===== */
@media (min-width: 769px) {
    .mobile-toggle-container,
    .sidebar-overlay,
    .mobile-toolbar-toggle {
        display: none;
    }

    .toolbar-content {
        display: flex;
        max-height: none;
        opacity: 1;
        overflow: visible;
    }
}

@media (max-width: 768px) {
    .mobile-toggle-container {
        position: fixed;
        top: 20px;
        left: 10px;
        z-index: 1100;
        transition: all 0.3s cubic-bezier(0.25, 0.8, 0.25, 1);
        will-change: transform;
    }

    .mobile-toggle-container.sidebar-open {
        left: calc(320px + 10px);
        display: none;
    }

    .sidebar-toggle {
        top: 50vh;
        background: var(--primary-color);
        border: 2px solid rgba(0,0,0,0.1);
        color: var(--primary-color);
        padding: 0.5rem 0.75rem;
        border-radius: 25px;
        box-shadow: 0 4px 20px rgba(0,0,0,0.3);
        backdrop-filter: blur(10px);
        width: auto;
        min-width: 20px;
        height: 35px;
        display: flex;
        align-items: center;
        justify-content: center;
        transition: all 0.3s cubic-bezier(0.25, 0.8, 0.25, 1);
        will-change: transform, box-shadow;
        opacity: 0.3;
    }

    .sidebar-toggle:hover {
        background: rgba(var(--primary-color-rgb), 0.1);
        color: var(--primary-color);
        transform: scale(1.05);
        box-shadow: 0 6px 25px rgba(0,0,0,0.4);
        opacity: 1;
    }

    .mobile-toggle-container .sidebar-toggle:hover {
        opacity: 1;
    }

    .mobile-toggle-container.sidebar-open .sidebar-toggle i {
        transform: rotate(180deg);
    }

    .modern-note-container {
        border-radius: 0;
        min-height: 100vh;
        padding-left: 15px;
        padding-right: 1px;
        padding-top: 1px;
    }

    .note-layout {
        flex-direction: column;
        gap: 1rem;
        min-height: calc(100vh - 120px);
    }

    .note-sidebar {
        position: fixed;
        top: 0;
        left: 0;
        bottom: 0;
        width: 320px;
        max-width: 80vw;
        z-index: 1050;
        background: rgba(255,255,255,0.98);
        backdrop-filter: blur(20px);
        border-radius: 0 15px 15px 0;
        box-shadow: 0 0 50px rgba(0,0,0,0.3);
        transform: translateX(-100%);
        transition: all 0.4s cubic-bezier(0.25, 0.8, 0.25, 1);
        border-right: 3px solid var(--primary-color);
        display: flex;
        flex-direction: column;
        height: 100vh;
        overflow: hidden;
        max-height: 90vh;
    }

    .note-sidebar.mobile-open {
        transform: translateX(0);
    }

    .note-sidebar.collapsed {
        width: 320px;
        min-width: 320px;
        background: rgba(255,255,255,0.98);
        box-shadow: 0 0 50px rgba(0,0,0,0.3);
        border-radius: 0 15px 15px 0;
        height: 100vh;
    }

    .note-sidebar .sidebar-header {
        display: flex;
        flex-direction: column;
        gap: 0.75rem;
        padding: 1rem;
        border-bottom: 1px solid rgba(0,0,0,0.1);
        background: rgba(255,255,255,0.05);
    }

    .sidebar-actions {
        display: flex;
        flex-direction: row;
        gap: 0.4rem;
        align-items: center;
        justify-content: space-evenly;
        flex-wrap: wrap;
        padding: 0 0.5rem;
    }

    .sidebar-title {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 0.5rem;
    }

    .sidebar-title h3 {
        font-size: 1.1rem;
        margin: 0;
    }

    .sidebar-action-btn {
        width: 40px;
        height: 40px;
        font-size: 1.1rem;
        border-radius: 10px;
        margin: 0;
        flex-shrink: 0;
        min-width: 40px;
    }

    .note-sidebar.collapsed .sidebar-header,
    .note-sidebar.collapsed .sidebar-header h3,
    .note-sidebar.collapsed .folder-tree-container,
    .note-sidebar.collapsed .notes-section {
        display: block;
    }

    .all-notes-item {
        flex-shrink: 0;
    }

    #folder-tree {
        flex: 1;
        overflow-y: auto;
        -webkit-overflow-scrolling: touch;
    }

    .notes-section {
        flex: 1;
        min-height: 0;
        display: flex;
        flex-direction: column;
        overflow: visible;
    }

    .notes-header {
        flex-shrink: 0;
        position: sticky;
        top: 0;
        z-index: 10;
        background: rgba(255, 255, 255, 0.98);
    }

    .note-list {
        flex: 1;
        overflow-y: scroll;
        -webkit-overflow-scrolling: touch;
        max-height: 45vh;
    }

    .note-list::-webkit-scrollbar {
        width: 6px;
        height: 6px;
    }

    .editor-toolbar {
        position: sticky;
        top: 10px;
        z-index: 100;
        flex-direction: column;
        gap: 0;
        padding: 0.5rem;
        background: rgba(255,255,255,0.98);
        backdrop-filter: blur(15px);
        border-radius: 12px;
        margin: 0.5rem;
        border: 1px solid rgba(0,0,0,0.05);
        box-shadow: 0 4px 12px rgba(0,0,0,0.15);
        will-change: transform;
        isolation: isolate;
    }

    .editor-toolbar.scrolled {
        box-shadow: 0 6px 20px rgba(0,0,0,0.2);
        background: rgba(255,255,255,1);
        border-color: rgba(0,0,0,0.1);
    }

    .toolbar-content {
        max-height: 0;
        opacity: 0;
        overflow: hidden;
        transition: all 0.3s cubic-bezier(0.25, 0.8, 0.25, 1);
        flex-direction: column;
        gap: 0.75rem;
        width: 100%;
    }

    .toolbar-content.expanded {
        max-height: 500px;
        opacity: 1;
        padding-top: 0.75rem;
    }

    .toolbar-content .toolbar-group {
        flex-wrap: wrap;
        justify-content: center;
        gap: 0.5rem;
        width: 100%;
    }

    .toolbar-content .toolbar-divider {
        width: 80%;
        height: 1px;
        margin: 0;
        align-self: center;
    }

    .toolbar-content .toolbar-btn {
        width: 44px;
        height: 44px;
        min-height: 44px;
        min-width: 44px;
        font-size: 1.1rem;
    }

    .toolbar-content .toolbar-select {
        min-width: 120px;
        font-size: 0.9rem;
        height: 44px;
        flex: 1;
        max-width: 200px;
    }

    .toolbar-content .auto-scroll-toggle {
        padding: 0.5rem 1rem;
        font-size: 0.9rem;
        border-radius: 10px;
        min-height: 44px;
    }

    .toolbar-content .color-picker {
        width: 44px;
        height: 44px;
        border-radius: 10px;
    }

    .mobile-toolbar-toggle {
        display: flex;
    }

    .title-input {
        font-size: 16px;
        padding: 1rem;
        transform: scale(1);
        border-radius: 8px;
    }

    .title-input:focus {
        background: rgba(var(--primary-color-rgb), 0.08);
        border: 2px solid var(--primary-color);
        transform: scale(1.02);
    }

    .title-group {
        margin: 0.5rem;
        margin-bottom: 0;
        position: relative;
        z-index: 90;
        transition: all 0.3s ease;
    }

    .title-group:focus-within {
        transform: translateY(-2px);
        box-shadow: 0 8px 20px rgba(0,0,0,0.1);
    }

    .save-dot-indicator {
        right: 0.75rem;
        width: 10px;
        height: 10px;
    }

    .clear-btn {
        right: 2rem;
        padding: 0.4rem;
        font-size: 1rem;
    }

    .folder-tree-container {
        overflow-y: scroll;
        -webkit-overflow-scrolling: touch;
        flex-shrink: 0;
        max-height: 25vh;
        display: flex;
        flex-direction: column;
        overflow: hidden;
    }

    .folder-tree-container::-webkit-scrollbar {
        width: 6px;
        height: 6px;
    }

    .folder-tree-container::-webkit-scrollbar-track {
        background: #f1f5f9;
        border-radius: 3px;
    }

    .folder-tree-container::-webkit-scrollbar-thumb {
        background: #94a3b8;
        border-radius: 3px;
    }

    .folder-tree-container::-webkit-scrollbar-thumb:hover {
        background: #64748b;
    }

    .folder-item-content,
    .all-notes-content {
        padding: 0.5rem;
        min-height: 44px;
    }

    .folder-children {
        margin-left: 1rem;
    }

    .folder-actions {
        opacity: 1;
    }

    .folder-toggle {
        width: 20px;
        height: 20px;
    }

    .note-item {
        padding: 1rem 0.75rem 1rem 2rem;
        font-size: 0.85rem;
    }

    .note-item::before {
        opacity: 0.3;
        left: 0.5rem;
    }

    .note-item-actions {
        opacity: 1;
    }

    .note-delete-btn {
        width: 28px;
        height: 28px;
        font-size: 0.9rem;
    }

    .lightbox-content {
        width: 95%;
        max-height: 70%;
        margin-top: 10px;
    }

    .lightbox-close {
        top: 10px;
        right: 20px;
        background: rgba(0,0,0,0.7);
        font-size: 30px;
        border-radius: 50%;
        width: 40px;
        height: 40px;
        display: flex;
        align-items: center;
        justify-content: center;
    }

    .header-actions {
        gap: 0.25rem;
    }

    .action-btn {
        width: 40px;
        height: 40px;
        font-size: 1rem;
    }

    .folder-btn {
        order: -1;
    }

    .auto-scroll-toggle {
        padding: 0.4rem;
        font-size: 0.8rem;
    }

    .toggle-slider {
        width: 28px;
        height: 16px;
    }

    .toggle-slider::before {
        width: 12px;
        height: 12px;
    }

    .auto-scroll-toggle input:checked + .toggle-slider::before {
        transform: translateX(12px);
    }

    .toggle-label {
        display: none;
    }

    .toggle-sidebar-btn,
    .sidebar-toggle:not(.mobile-toggle-container .sidebar-toggle) {
        display: none;
    }

    .image-container {
        width: 100%;
        margin: 0.5rem 0;
    }

    .delete-image-btn {
        opacity: 1;
        width: 36px;
        height: 36px;
        font-size: 16px;
    }

    .image-info {
        opacity: 1;
        position: static;
        background: rgba(0,0,0,0.05);
        color: var(--text-color);
        padding: 0.5rem;
    }

    .image-toast {
        right: 10px;
        left: 10px;
        width: auto;
    }
}

@media (max-width: 480px) {
    .sidebar-toggle {
        width: 20px;
        height: 100px;
    }

    .toolbar-toggle-btn::after {
        display: none;
    }
}

/* iOS and Android Specific Fixes */
@supports (-webkit-touch-callout: none) {
    .note-editor,
    .title-input {
        font-size: 16px;
        transform: scale(1);
    }
}

@media screen and (-webkit-min-device-pixel-ratio: 0) and (min-resolution: 0.001dpcm) {
    .note-editor {
        font-size: 16px;
    }
}





/* ===== IMAGE DRAG & DROP STYLES ===== */
.drag-over-images {
    background: rgba(var(--primary-color-rgb), 0.1) !important;
    border: 2px dashed var(--primary-color) !important;
    border-radius: 12px !important;
    position: relative;
}

.drag-over-images::after {
    content: 'Drop images here';
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background: var(--primary-color);
    color: white;
    padding: 0.5rem 1rem;
    border-radius: 6px;
    font-size: 0.9rem;
    font-weight: 500;
    pointer-events: none;
    z-index: 1000;
    box-shadow: 0 4px 12px rgba(0,0,0,0.3);
}

/* Global drop indicator */
.image-drop-indicator {
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: rgba(0,0,0,0.8);
    z-index: 10000;
    display: flex;
    align-items: center;
    justify-content: center;
    opacity: 0;
    visibility: hidden;
    transition: all 0.3s ease;
    backdrop-filter: blur(5px);
}

.image-drop-indicator.visible {
    opacity: 1;
    visibility: visible;
}

.drop-indicator-content {
    text-align: center;
    color: white;
    max-width: 400px;
    padding: 2rem;
    border: 3px dashed rgba(255,255,255,0.5);
    border-radius: 20px;
    background: rgba(255,255,255,0.1);
    backdrop-filter: blur(10px);
    transform: scale(0.9);
    transition: transform 0.3s ease;
}

.image-drop-indicator.visible .drop-indicator-content {
    transform: scale(1);
}

.drop-indicator-content i {
    font-size: 4rem;
    margin-bottom: 1rem;
    opacity: 0.8;
    animation: float 2s ease-in-out infinite;
}

.drop-indicator-content h3 {
    margin: 1rem 0 0.5rem 0;
    font-size: 1.8rem;
    font-weight: 600;
}

.drop-indicator-content p {
    margin: 0;
    font-size: 1.1rem;
    opacity: 0.9;
}

@keyframes float {
    0%, 100% { transform: translateY(0); }
    50% { transform: translateY(-10px); }
}

/* Drag & Drop Toast Notifications */
.image-drag-toast {
    position: fixed;
    top: 80px;
    right: 20px;
    padding: 0.75rem 1rem;
    border-radius: 8px;
    box-shadow: 0 4px 12px rgba(0,0,0,0.3);
    z-index: 10000;
    display: flex;
    align-items: center;
    gap: 0.5rem;
    font-size: 0.9rem;
    font-weight: 500;
    opacity: 0;
    transform: translateX(100%);
    transition: all 0.3s ease;
    max-width: 350px;
}

.image-drag-toast.show {
    opacity: 1;
    transform: translateX(0);
}

.image-drag-toast-success {
    background: var(--alert-success-color);
    color: white;
}

.image-drag-toast-error {
    background: var(--alert-danger-color);
    color: white;
}

.image-drag-toast-warning {
    background: var(--alert-warning-color);
    color: #333;
}

.image-drag-toast-info {
    background: #17a2b8;
    color: white;
}

/* Mobile optimizations */
@media (max-width: 768px) {
    .drop-indicator-content {
        max-width: 300px;
        padding: 1.5rem;
    }
    
    .note-editor p {
        margin: 0 0 0.4rem 0; /* Giảm margin trên mobile */
    }
    
    .note-editor h1, .note-editor h2, .note-editor h3 {
        margin: 0.8rem 0 0.4rem 0;
        line-height: 1.25;
    }

    .drop-indicator-content i {
        font-size: 3rem;
    }
    
    .drop-indicator-content h3 {
        font-size: 1.5rem;
    }
    
    .drop-indicator-content p {
        font-size: 1rem;
    }
    
    .image-drag-toast {
        right: 10px;
        left: 10px;
        width: auto;
        max-width: none;
    }
}

/* Enhanced editor drop zone when empty */
.note-editor:empty.drag-over-images::after {
    content: 'Drop your images here to get started';
    font-size: 1.2rem;
    padding: 2rem;
}

/* Title input drop zone */
.title-input.drag-over-images {
    background: rgba(var(--primary-color-rgb), 0.1) !important;
    border: 2px dashed var(--primary-color) !important;
    color: var(--primary-color) !important;
}

.title-input.drag-over-images::placeholder {
    color: var(--primary-color) !important;
    opacity: 0.7;
}

.note-editor[data-placeholder]:empty::before {
    content: attr(data-placeholder);
    color: var(--secondary-color);
    font-style: italic;
    pointer-events: none;
}

.note-editor p:empty {
    min-height: 1.2em;
}

.note-editor p:empty::before {
    content: '\00a0'; /* Non-breaking space để <p> có thể click được */
    color: transparent;
}

.auto-scroll-toggle {
    display: flex;
    align-items: center;
    gap: 0.5rem;
    cursor: pointer;
    padding: 0.5rem 0.75rem;
    border-radius: 8px;
    transition: all 0.3s ease;
    background: rgba(255,255,255,0.1);
    border: 1px solid rgba(0,0,0,0.1);
    user-select: none;
    font-size: 0.85rem;
    color: var(--text-color);
}

/* Remove mobile-only restriction */
@media (max-width: 768px) {
    .auto-scroll-toggle {
        padding: 0.4rem;
        font-size: 0.8rem;
    }
    
    .toggle-label {
        display: none; /* Hide label on mobile only */
    }
}

/* Desktop specific styles */
@media (min-width: 769px) {
    .auto-scroll-toggle {
        min-width: 120px; /* Ensure enough space for label */
    }
    
    .toggle-label {
        display: block; /* Show label on desktop */
    }
}
/* ===== SMOOTH SCROLL ENHANCEMENTS ===== */
html {
    scroll-behavior: smooth;
    scroll-padding-top: 20px; /* Offset for sticky elements */
}

/* Better scroll behavior control */
html.instant-scroll {
    scroll-behavior: auto !important;
}

html.auto-scroll-smooth {
    scroll-behavior: smooth !important;
}

/* Reduce scroll jump on mobile */
@media (max-width: 768px) {
    html {
        -webkit-overflow-scrolling: touch;
        overflow-scrolling: touch;
    }
    
    body {
        overscroll-behavior: contain;
    }
}

/* Improve scroll performance */
.note-editor,
.note-list,
.folder-tree-container {
    contain: layout style;
    will-change: scroll-position;
}

/* Reduce motion for users who prefer it */
@media (prefers-reduced-motion: reduce) {
    html {
        scroll-behavior: auto !important;
    }
    
    * {
        transition-duration: 0.01ms !important;
        animation-duration: 0.01ms !important;
    }
    
    .smooth-scroll-override {
        scroll-behavior: auto !important;
    }
}

/* ===== SEARCH MODAL STYLES ===== */
#searchModal .modal-dialog {
    margin-top: 10vh;
    max-width: 500px;
}

#searchModal .modal-content {
    border-radius: 12px;
    border: none;
    box-shadow: 0 10px 40px rgba(0,0,0,0.2);
}

#searchModal .modal-body {
    padding: 1rem;
}

#search-textbox {
    border: 2px solid #e1e5e9;
    border-radius: 8px;
    padding: 12px 16px;
    font-size: 1rem;
    transition: all 0.3s ease;
    box-shadow: none;
}

#search-textbox:focus {
    border-color: var(--primary-color);
    box-shadow: 0 0 0 3px rgba(var(--primary-color-rgb), 0.1);
    outline: none;
}

.search-results {
    animation: slideDown 0.2s ease;
}

@keyframes slideDown {
    from {
        opacity: 0;
        transform: translateY(-10px);
    }
    to {
        opacity: 1;
        transform: translateY(0);
    }
}

.search-result-item:hover {
    background: #f8f9fa !important;
}

.search-result-item.active {
    background: #e3f2fd !important;
}

.search-result-item:last-child {
    border-bottom: none;
}

/* Mobile search modal */
@media (max-width: 768px) {
    #searchModal .modal-dialog {
        margin: 1rem;
        margin-top: 5vh;
    }
    
    .search-results {
        max-height: 250px !important;
    }
}
.toolbar-btn.search-active {
    background: var(--primary-color);
    color: white;
}

/* ===== SEARCH HIGHLIGHTING ===== */


/* Search results with mode indicators */
.search-result-item .bi-eye-fill {
    color: var(--primary-color) !important;
}

.search-result-item .bi-search {
    color: var(--success-color, #28a745) !important;
}

.search-result-item .bi-folder {
    color: #f39c12 !important;
}

/* Enhanced search modal */
#searchModal .modal-dialog {
    margin-top: 8vh;
    max-width: 600px; /* Tăng width để có chỗ cho mode toggle */
}

.search-toolbar-content {
    padding: 1rem;
    display: flex;
    flex-direction: column;
    gap: 0.75rem;
}

.search-info {
    display: flex;
    justify-content: space-between;
    align-items: center;
    gap: 0.5rem;
}

.search-term {
    font-weight: 600;
    color: var(--primary-color);
    background: rgba(var(--primary-color-rgb), 0.1);
    padding: 0.25rem 0.5rem;
    border-radius: 6px;
    font-size: 0.9rem;
    flex: 1;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
}

.search-count {
    font-size: 0.85rem;
    color: var(--secondary-color);
    font-weight: 500;
    white-space: nowrap;
}

.current-highlight {
    color: var(--primary-color);
    font-weight: 600;
}

.search-controls {
    display: flex;
    gap: 0.5rem;
    justify-content: center;
}

.search-nav-btn {
    width: 36px;
    height: 36px;
    border: 1px solid #e1e5e9;
    border-radius: 8px;
    background: white;
    color: var(--text-color);
    cursor: pointer;
    transition: all 0.2s ease;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 1rem;
}

.search-nav-btn:hover {
    background: var(--primary-color);
    color: white;
    border-color: var(--primary-color);
    transform: translateY(-1px);
}

.search-nav-btn:active {
    transform: translateY(0);
}

.search-close-btn {
    background: #f8f9fa;
    border-color: #dee2e6;
}

.search-close-btn:hover {
    background: var(--alert-danger-color);
    border-color: var(--alert-danger-color);
}

/* Mobile responsive */
@media (max-width: 768px) {
    
    .search-toolbar-content {
        padding: 0.75rem;
        gap: 0.5rem;
    }
    
    .search-info {
        flex-direction: column;
        gap: 0.25rem;
        align-items: stretch;
    }
    
    .search-term {
        text-align: center;
    }
    
    .search-controls {
        gap: 0.75rem;
    }
    
    .search-nav-btn {
        width: 44px;
        height: 44px;
        font-size: 1.1rem;
    }
}
/* ===== SEARCH MATCH BADGES ===== */
.match-badge {
    display: inline-flex;
    align-items: center;
    justify-content: center;
    min-width: 20px;
    height: 18px;
    font-family: 'Inter', sans-serif;
    font-weight: 600;
    font-size: 0.7rem;
    line-height: 1;
    border-radius: 10px;
    color: white;
    text-shadow: 0 1px 2px rgba(0,0,0,0.2);
    box-shadow: 0 1px 3px rgba(0,0,0,0.2);
    transition: all 0.2s ease;
    flex-shrink: 0;
}

.match-badge-single {
    background: linear-gradient(135deg, #28a745, #20c997);
}

.match-badge-low {
    background: linear-gradient(135deg, #ffc107, #fd7e14);
}

.match-badge-medium {
    background: linear-gradient(135deg, #fd7e14, #dc3545);
}

.match-badge-high {
    background: linear-gradient(135deg, #dc3545, #6f42c1);
    animation: highlightPulse 2s ease-in-out infinite;
}

@keyframes highlightPulse {
    0%, 100% { 
        transform: scale(1); 
        box-shadow: 0 1px 3px rgba(0,0,0,0.2);
    }
    50% { 
        transform: scale(1.1); 
        box-shadow: 0 2px 8px rgba(220, 53, 69, 0.4);
    }
}

/* Search result item improvements */
.search-result-item {
    position: relative;
}

.search-result-item:hover .match-badge {
    transform: scale(1.1);
    box-shadow: 0 2px 6px rgba(0,0,0,0.3);
}

.search-result-item.active .match-badge {
    transform: scale(1.05);
    filter: brightness(1.1);
}

/* Mobile responsive */
@media (max-width: 768px) {
    .match-badge {
        font-size: 0.65rem;
        min-width: 18px;
        height: 16px;
        padding: 0.15rem 0.3rem;
    }
}

/* Tooltip for match details */
.match-badge[title]:hover::after {
    content: attr(title);
    position: absolute;
    top: -35px;
    right: 0;
    background: rgba(0,0,0,0.9);
    color: white;
    padding: 0.25rem 0.5rem;
    border-radius: 4px;
    font-size: 0.7rem;
    white-space: nowrap;
    z-index: 1000;
    opacity: 0;
    animation: tooltipFade 0.3s ease forwards;
}

@keyframes tooltipFade {
    from { opacity: 0; transform: translateY(5px); }
    to { opacity: 1; transform: translateY(0); }
}
</style>

<script>
// ===== APPLICATION STATE =====
const AppState = {
    notes: [],
    currentId: null,
    pendingDelete: false,
    checklistActive: false,
    lastSavedTitle: "",
    lastSavedContent: "",
    currentImages: [],
    isFocusLocked: false
};

const DeviceUtils = {
    isMobile() {
        return window.innerWidth <= 768;
    },
    
    isMobileDevice() {
        const userAgent = navigator.userAgent || navigator.vendor || window.opera;
        return /android|iphone|ipad|ipod|blackberry|iemobile|opera mini/i.test(userAgent);
    },
    
    hasTouch() {
        return 'ontouchstart' in window || navigator.maxTouchPoints > 0;
    }
};

// ===== IMAGE DRAG & DROP MANAGER =====
const ImageDragDropManager = {
    init() {
        this.setupEditorDropZone();
        this.setupDragEvents();
    },

    setupEditorDropZone() {
        const editor = document.getElementById('evernote-editor');
        if (!editor) return;

        // Prevent default drag behaviors on editor
        ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
            editor.addEventListener(eventName, this.preventDefaults, false);
        });

        // Highlight drop zone when item is dragged over it
        ['dragenter', 'dragover'].forEach(eventName => {
            editor.addEventListener(eventName, this.highlight.bind(this), false);
        });

        ['dragleave', 'drop'].forEach(eventName => {
            editor.addEventListener(eventName, this.unhighlight.bind(this), false);
        });

        // Handle dropped files
        editor.addEventListener('drop', this.handleDrop.bind(this), false);
    },

    setupDragEvents() {
        // Also setup for title input (optional)
        const titleInput = document.getElementById('note-title');
        if (titleInput) {
            ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
                titleInput.addEventListener(eventName, this.preventDefaults, false);
            });

            ['dragenter', 'dragover'].forEach(eventName => {
                titleInput.addEventListener(eventName, this.highlight.bind(this), false);
            });

            ['dragleave', 'drop'].forEach(eventName => {
                titleInput.addEventListener(eventName, this.unhighlight.bind(this), false);
            });

            titleInput.addEventListener('drop', this.handleDrop.bind(this), false);
        }

        // Global drag events for better UX
        document.addEventListener('dragenter', this.showDropIndicator.bind(this), false);
        document.addEventListener('dragleave', this.hideDropIndicator.bind(this), false);
        document.addEventListener('drop', this.hideDropIndicator.bind(this), false);
    },

    preventDefaults(e) {
        e.preventDefault();
        e.stopPropagation();
    },

    highlight(e) {
        const target = e.currentTarget;
        target.classList.add('drag-over-images');
    },

    unhighlight(e) {
        const target = e.currentTarget;
        target.classList.remove('drag-over-images');
    },

    showDropIndicator(e) {
        // Only show if dragging files and note is selected
        if (this.isDraggingFiles(e) && AppState.currentId) {
            this.createDropIndicator();
        }
    },

    hideDropIndicator(e) {
        this.removeDropIndicator();
    },

    isDraggingFiles(e) {
        return e.dataTransfer && e.dataTransfer.types && 
               (e.dataTransfer.types.includes('Files') || 
                e.dataTransfer.types.includes('application/x-moz-file'));
    },

    enhanceDropZones() {
        // Add visual hints when no note is selected
        const editor = document.getElementById('evernote-editor');
        const titleInput = document.getElementById('note-title');
        
        if (!AppState.currentId && editor) {
            editor.setAttribute('data-placeholder', 'Select a note first, then drag images here');
        } else if (editor) {
            editor.removeAttribute('data-placeholder');
        }
    },

    createDropIndicator() {
        if (document.getElementById('image-drop-indicator')) return;

        const indicator = document.createElement('div');
        indicator.id = 'image-drop-indicator';
        indicator.className = 'image-drop-indicator';
        indicator.innerHTML = `
            <div class="drop-indicator-content">
                <i class="bi bi-cloud-arrow-up"></i>
                <h3>Drop Images Here</h3>
                <p>Drop your images to upload them to this note</p>
            </div>
        `;
        document.body.appendChild(indicator);

        // Animate in
        setTimeout(() => {
            indicator.classList.add('visible');
        }, 10);
    },

    removeDropIndicator() {
        const indicator = document.getElementById('image-drop-indicator');
        if (indicator) {
            indicator.classList.remove('visible');
            setTimeout(() => {
                indicator.remove();
            }, 300);
        }
    },

    async handleDrop(e) {
        this.preventDefaults(e);
        this.unhighlight(e);
        this.hideDropIndicator();

        if (!AppState.currentId) {
            this.showError('Please select a note first');
            return;
        }

        const files = Array.from(e.dataTransfer.files);
        const imageFiles = files.filter(file => file.type.startsWith('image/'));

        if (imageFiles.length === 0) {
            this.showError('No image files found in dropped items');
            return;
        }

        if (imageFiles.length !== files.length) {
            this.showWarning(`${files.length - imageFiles.length} non-image files were ignored`);
        }

        try {
            const result = await ImageManager.uploadImages(imageFiles, AppState.currentId);
            
            if (result && result.status === 'success') {
                await ImageManager.loadNoteImages(AppState.currentId);
                
                setTimeout(() => {
                    ImageManager.cleanupDuplicateSections();
                    
                    // Focus vào <p> tag đầu tiên thay vì complex cursor positioning
                    const editor = document.getElementById('evernote-editor');
                    const firstP = editor.querySelector('p');
                    if (firstP) {
                        const range = document.createRange();
                        const selection = window.getSelection();
                        
                        range.selectNodeContents(firstP);
                        range.collapse(false);
                        
                        selection.removeAllRanges();
                        selection.addRange(range);
                        
                        editor.focus();
                    } else {
                        editor.focus();
                    }
                    
                    SaveManager.saveNote();
                }, 500);
                
                this.showSuccess(`Successfully uploaded ${imageFiles.length} image(s)`);
            }
        } catch (error) {
            console.error('Drag & drop upload failed:', error);
            this.showError('Failed to upload images: ' + error.message);
        }
    },

    showSuccess(message) {
        this.showToast(message, 'success');
    },

    showError(message) {
        this.showToast(message, 'error');
    },

    showWarning(message) {
        this.showToast(message, 'warning');
    },

    showToast(message, type = 'info') {
        const toast = document.createElement('div');
        toast.className = `image-drag-toast image-drag-toast-${type}`;
        
        const iconMap = {
            success: 'check-circle-fill',
            error: 'exclamation-triangle-fill',
            warning: 'exclamation-circle-fill',
            info: 'info-circle-fill'
        };

        toast.innerHTML = `
            <i class="bi bi-${iconMap[type]}"></i>
            <span>${message}</span>
        `;
        
        document.body.appendChild(toast);
        
        // Animate in
        setTimeout(() => toast.classList.add('show'), 100);
        
        // Animate out and remove
        setTimeout(() => {
            toast.classList.remove('show');
            setTimeout(() => toast.remove(), 300);
        }, type === 'error' ? 5000 : 3000);
    }
};


// ===== MOBILE TOOLBAR MANAGER =====
const MobileToolbarManager = {
    isExpanded: false,
    
    init() {
        if (window.innerWidth <= 768) {
            this.setupToggleListener();
            this.restoreState();
        }
    },
    
    setupToggleListener() {
        const toggleBtn = document.getElementById('mobile-toolbar-toggle');
        if (toggleBtn) {
            toggleBtn.addEventListener('click', () => {
                this.toggle();
            });
        }
    },
    
    toggle() {
        this.isExpanded = !this.isExpanded;
        this.updateUI();
        this.saveState();
    },
    
    expand() {
        this.isExpanded = true;
        this.updateUI();
        this.saveState();
    },
    
    collapse() {
        this.isExpanded = false;
        this.updateUI();
        this.saveState();
    },
    
    updateUI() {
        const toggleBtn = document.querySelector('.toolbar-toggle-btn');
        const toolbarContent = document.getElementById('toolbar-content');
        
        if (toggleBtn && toolbarContent) {
            if (this.isExpanded) {
                toggleBtn.classList.add('expanded');
                toolbarContent.classList.add('expanded');
                toggleBtn.title = 'Collapse toolbar';
            } else {
                toggleBtn.classList.remove('expanded');
                toolbarContent.classList.remove('expanded');
                toggleBtn.title = 'Expand toolbar';
            }
        }
    },
    
    saveState() {
        localStorage.setItem('mobileToolbarExpanded', this.isExpanded.toString());
    },
    
    restoreState() {
        // Mặc định collapsed trên mobile
        const savedState = localStorage.getItem('mobileToolbarExpanded');
        this.isExpanded = savedState === 'true';
        this.updateUI();
    },
    
    handleResize() {
        if (window.innerWidth <= 768) {
            this.setupToggleListener();
            this.updateUI();
        } else {
            // Desktop: luôn expanded
            const toolbarContent = document.getElementById('toolbar-content');
            if (toolbarContent) {
                toolbarContent.classList.remove('expanded');
            }
        }
    }
};

const AutoScrollSettings = {
    enabled: true,
    debounceTimeout: null,
    activeScrolls: new Set(), // Track active scrolls
    
    init() {
        console.log('AutoScrollSettings.init() called');
        const saved = localStorage.getItem('autoScroll');
        this.enabled = saved !== 'false';
        
        const checkbox = document.getElementById('autoScrollToggle');
        if (checkbox) {
            checkbox.checked = this.enabled;
            
            checkbox.addEventListener('change', (e) => {
                clearTimeout(this.debounceTimeout);
                this.debounceTimeout = setTimeout(() => {
                    this.toggle(e.target.checked);
                }, 100);
            });
        }
    },
    
    toggle(enabled) {
        this.enabled = enabled;
        localStorage.setItem('autoScroll', enabled ? 'true' : 'false');
        
        if (!enabled) {
            this.stopAllScrolling();
        }
    },
    
    isEnabled() {
        return this.enabled;
    },
    
    // Improved stop all scrolling
    stopAllScrolling() {
        // Stop all timeouts
        clearTimeout(MobileCursorManager.scrollTimeout);
        clearTimeout(DesktopCursorManager.scrollTimeout);
        
        // Cancel any ongoing animations
        this.activeScrolls.forEach(animationId => {
            cancelAnimationFrame(animationId);
        });
        this.activeScrolls.clear();
        
        // Reset scrolling flags
        MobileCursorManager.isScrolling = false;
        DesktopCursorManager.isScrolling = false;
    },
    
    // Register active scroll animation
    registerAnimation(animationId) {
        this.activeScrolls.add(animationId);
    },
    
    // Unregister completed animation
    unregisterAnimation(animationId) {
        this.activeScrolls.delete(animationId);
    }
};



// ===== SAVE FUNCTIONALITY =====
const SaveManager = {
    showSaveStatus(type = 'saved') {
        const titleInput = document.getElementById('note-title');
        const saveIndicator = document.getElementById('save-dot-indicator');
        
        if (!titleInput || !saveIndicator) {
            console.warn('Title input or save indicator not found!');
            return;
        }
        
        console.log('SaveManager.showSaveStatus called with:', type);
        
        // Remove existing classes from title input
        titleInput.classList.remove('saving', 'saved', 'error');
        
        if (type === 'saving') {
            titleInput.classList.add('saving');
            console.log('Applied saving class to title input');
            
        } else if (type === 'saved') {
            titleInput.classList.add('saved');
            console.log('Applied saved class to title input');
            
            // Reset sau 2 giây
            clearTimeout(this.saveTimeout);
            this.saveTimeout = setTimeout(() => {
                titleInput.classList.remove('saved');
                console.log('Removed saved class from title input');
            }, 2000);
            
        } else if (type === 'error') {
            titleInput.classList.add('error');
            console.log('Applied error class to title input');
            
            setTimeout(() => {
                titleInput.classList.remove('error');
                console.log('Removed error class from title input');
            }, 3000);
        }
    },

    debounce(func, wait) {
        let timeout;
        return function executedFunction(...args) {
            const later = () => {
                clearTimeout(timeout);
                func(...args);
            };
            clearTimeout(timeout);
            timeout = setTimeout(later, wait);
        };
    },

    async saveNote() {
        let title = document.getElementById('note-title').value.trim();
        const editor = document.getElementById('evernote-editor');
        
        const cleanContent = this.cleanEditorContent(editor);

        if (title === "") {
            title = `Note_${new Date().toLocaleString('sv-SE').replace(/[:\s]/g, '_').slice(0, -3)}`;
            document.getElementById('note-title').value = title;
        }

        try {
            this.showSaveStatus('saving');
            
            let shouldReloadNotes = false;
            let noteData;
            
            if (!AppState.currentId) {
                // Creating new note
                noteData = await API.createNote(title, cleanContent, FolderManager.currentFolderId);
                
                if (noteData && noteData.id) {
                    AppState.currentId = noteData.id;
                    
                    // ✅ ADD to local state immediately
                    const newNote = {
                        id: noteData.id,
                        title: title,
                        content: cleanContent,
                        folder_id: noteData.folder_id,
                        folder_name: noteData.folder_name || null,
                        created_at: noteData.created_at || new Date().toISOString(),
                        updated_at: noteData.updated_at || new Date().toISOString(),
                        images: AppState.currentImages || []
                    };
                    
                    AppState.notes.push(newNote);
                    console.log('✅ Added new note to local state:', newNote);
                    
                    shouldReloadNotes = true; // Still need to reload for folder counts
                }
            } else {
                // Updating existing note
                noteData = await API.updateNote(AppState.currentId, title, cleanContent);
                
                if (noteData && noteData.status === 'success') {
                    console.log('Note updated successfully, updating local state...');
                    
                    // ✅ UPDATE local state immediately
                    const noteIndex = AppState.notes.findIndex(n => n.id === AppState.currentId);
                    if (noteIndex !== -1) {
                        AppState.notes[noteIndex] = {
                            ...AppState.notes[noteIndex],
                            title: title,
                            content: cleanContent,
                            updated_at: new Date().toISOString()
                        };
                        console.log('✅ Updated note in local state:', AppState.notes[noteIndex]);
                        
                        // ✅ Re-render note list với fresh local data
                        NoteManager.renderNoteList();
                        
                        // ✅ Update meta with fresh data
                        NoteManager.updateMeta(AppState.notes[noteIndex]);
                    }
                }
            }
            
            if (shouldReloadNotes) {
                // Only for new notes - reload folder structure
                await FolderManager.loadFolders();
                await NoteManager.loadNotes(FolderManager.currentFolderId);
                if (AppState.currentId) {
                    await NoteManager.selectNote(AppState.currentId);
                }
            }

            AppState.lastSavedTitle = title;
            AppState.lastSavedContent = cleanContent;
            
            this.showSaveStatus('saved');
            
        } catch (error) {
            console.error('Save failed:', error);
            this.showSaveStatus('error');
        }
    },

    cleanEditorContent(editor) {
        const tempDiv = document.createElement('div');
        tempDiv.innerHTML = editor.innerHTML;
        
        // Remove ALL images sections
        const imagesSections = tempDiv.querySelectorAll('.images-section');
        imagesSections.forEach(section => section.remove());
        
        return tempDiv.innerHTML;
    },

    autoSave: null
};

// ===== API FUNCTIONS =====
const API = {
    async fetchNotes() {
        try {
            const res = await fetch('/api/evernote_notes');
            if (!res.ok) {
                throw new Error(`HTTP ${res.status}: ${res.statusText}`);
            }
            return await res.json();
        } catch (error) {
            console.error('Error fetching notes:', error);
            return [];
        }
    },

    async createNote(title, content, folderId = null) {
        try {
            console.log('API.createNote called with:', { title, content, folderId }); // Debug log
            
            const requestBody = {
                title: title || '',
                content: content || '',
                folder_id: folderId  // Ensure this is correctly set
            };
            
            console.log('Request body:', requestBody); // Debug log
            
            const res = await fetch('/api/evernote_notes', {
                method: 'POST',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify(requestBody)
            });
            
            console.log('Response status:', res.status); // Debug log
            
            if (!res.ok) {
                throw new Error(`HTTP ${res.status}: ${res.statusText}`);
            }
            
            const data = await res.json();
            console.log('Response data:', data); // Debug log
            
            if (data.status === 'error') {
                throw new Error(data.message);
            }
            
            return data;
        } catch (error) {
            console.error('Error creating note:', error);
            throw error;
        }
    },

    async updateNote(id, title, content) {
        try {
            const res = await fetch(`/api/evernote_notes/${id}`, {
                method: 'PUT',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify({
                    title: title, 
                    content: content
                    // Không cần folder_id khi update
                })
            });
            
            if (!res.ok) {
                throw new Error(`HTTP ${res.status}: ${res.statusText}`);
            }
            
            const data = await res.json();
            
            if (data.status === 'error') {
                throw new Error(data.message);
            }
            
            return data;
        } catch (error) {
            console.error('Error updating note:', error);
            throw error;
        }
    },

    async deleteNote(id) {
        try {
            const res = await fetch(`/api/evernote_notes/${id}`, {method: 'DELETE'});
            
            if (!res.ok) {
                throw new Error(`HTTP ${res.status}: ${res.statusText}`);
            }
            
            const data = await res.json();
            
            if (data.status === 'error') {
                throw new Error(data.message);
            }
            
            return data;
        } catch (error) {
            console.error('Error deleting note:', error);
            throw error;
        }
    }
};

// ===== FOLDER MANAGER =====
const FolderManager = {
    folders: [],
    currentFolderId: null,
    expandedFolders: new Set(),

    async loadFolders() {
        try {
            const response = await fetch('/api/evernote_folders');
            const data = await response.json();
            if (data.status === 'success') {
                this.folders = data.folders;
                this.renderFolderTree();
                this.populateParentSelect();
            }
        } catch (error) {
            console.error('Error loading folders:', error);
        }
    },

    renderFolderTree() {
        const treeContainer = document.getElementById('folder-tree');
    
        let html = `
            <!-- All Notes Button -->
            <div class="all-notes-item">
                <div class="all-notes-content ${this.currentFolderId === null ? 'selected' : ''}" 
                    onclick="FolderManager.selectAllNotes()">
                    <i class="bi bi-collection all-notes-icon"></i>
                    <span class="all-notes-title">All Notes</span>
                    <span class="folder-notes-count" id="all-notes-count">0</span>
                </div>
            </div>
        `;
        
        // Sort folders trước khi build HTML
        this.sortFoldersRecursively(this.folders);
        
        html += this.buildFolderTreeHTML(this.folders, 0);
        treeContainer.innerHTML = html;
        
        // Attach event listeners after rendering
        this.attachFolderActionListeners();

        // Update all notes count
        this.updateAllNotesCount();
    },

    // Thêm method để sort folders recursively
    sortFoldersRecursively(folders) {
        // Sort current level
        folders.sort((a, b) => a.name.toLowerCase().localeCompare(b.name.toLowerCase()));
        
        // Sort children recursively
        folders.forEach(folder => {
            if (folder.children && folder.children.length > 0) {
                this.sortFoldersRecursively(folder.children);
            }
        });
    },

    attachFolderActionListeners() {
        // Remove existing listeners first
        document.querySelectorAll('.folder-action-btn').forEach(btn => {
            btn.removeEventListener('click', this.handleFolderAction);
        });

        // Add new listeners
        document.querySelectorAll('.folder-action-btn').forEach(btn => {
            btn.addEventListener('click', (event) => {
                event.stopPropagation();
                event.preventDefault();
                
                const action = btn.dataset.action;
                const folderId = parseInt(btn.dataset.folderId);
                
                console.log('Folder action clicked:', { action, folderId, btn });
                
                if (action === 'edit') {
                    this.editFolder(folderId);
                } else if (action === 'delete') {
                    this.showDeleteFolderModal(folderId);
                }
            });
        });
    },

    buildFolderTreeHTML(folders, level = 0) {
        let html = '';
        
        folders.forEach(folder => {
            const hasChildren = folder.children && folder.children.length > 0;
            const isExpanded = this.expandedFolders.has(folder.id);
            const isSelected = this.currentFolderId === folder.id;
            
            html += `
                <div class="folder-tree-item ${level === 0 ? 'root-level' : ''}">
                    <div class="folder-item-content ${isSelected ? 'selected' : ''}" 
                        data-folder-id="${folder.id}">
                        
                        <!-- Expand/Collapse Toggle -->
                        <button class="folder-toggle ${hasChildren ? (isExpanded ? 'expanded' : '') : 'no-children'}" 
                                onclick="FolderManager.toggleFolder(event, ${folder.id})">
                            <i class="bi bi-chevron-right"></i>
                        </button>
                        
                        <!-- Folder Content -->
                        <div style="display: flex; align-items: center; flex: 1; min-width: 0;" 
                            onclick="FolderManager.selectFolder(${folder.id})">
                            <i class="bi bi-folder${hasChildren ? '' : '2'} folder-icon"></i>
                            <span class="folder-name" title="${folder.name}">${folder.name}</span>
                            <span class="folder-notes-count">${folder.notes_count || 0}</span>
                        </div>
                        
                        <!-- Folder Actions -->
                        <div class="folder-actions">
                            <button class="folder-action-btn" 
                                    data-action="edit" 
                                    data-folder-id="${folder.id}"
                                    title="Edit folder"
                                    type="button">
                                <i class="bi bi-pencil"></i>
                            </button>
                            <button class="folder-action-btn" 
                                    data-action="delete" 
                                    data-folder-id="${folder.id}"
                                    title="Delete folder"
                                    type="button">
                                <i class="bi bi-trash"></i>
                            </button>
                        </div>
                    </div>
                    
                    <!-- Children Container -->
                    ${hasChildren ? `
                        <div class="folder-children ${isExpanded ? 'expanded' : 'collapsed'}">
                            ${this.buildFolderTreeHTML(folder.children, level + 1)}
                        </div>
                    ` : ''}
                </div>
            `;
        });
        
        return html;
    },

    toggleFolder(event, folderId) {
        event.stopPropagation();
        
        if (this.expandedFolders.has(folderId)) {
            this.expandedFolders.delete(folderId);
        } else {
            this.expandedFolders.add(folderId);
        }
        
        // Re-render tree to update expand/collapse state
        this.renderFolderTree();
    },

    selectFolder(folderId) {
        console.log('FolderManager.selectFolder called with:', folderId);
        console.log('Setting currentFolderId from', this.currentFolderId, 'to', folderId);
        
        this.currentFolderId = folderId;
        
        console.log('FolderManager.currentFolderId is now:', this.currentFolderId);
        
        // Update UI selection
        document.querySelectorAll('.folder-item-content').forEach(item => {
            item.classList.remove('selected');
        });
        document.querySelector('.all-notes-content').classList.remove('selected');
        
        const selectedItem = document.querySelector(`[data-folder-id="${folderId}"]`);
        if (selectedItem) {
            selectedItem.classList.add('selected');
            console.log('UI updated - folder selected');
        } else {
            console.warn('Could not find folder element with ID:', folderId);
        }
        
        // Load notes for this folder
        NoteManager.loadNotes(folderId);
        
        // Update current folder name
        const folder = this.findFolder(folderId);
        document.getElementById('current-folder-name').textContent = folder ? folder.name : 'All Notes';
        
        // QUAN TRỌNG: Clear current note selection và images khi chuyển folder
        AppState.currentId = null;
        AppState.currentImages = [];
        NoteManager.clearEditor();
    },

    selectAllNotes() {
        console.log('FolderManager.selectAllNotes called');
        console.log('Setting currentFolderId from', this.currentFolderId, 'to null');
        
        this.currentFolderId = null;
        
        console.log('FolderManager.currentFolderId is now:', this.currentFolderId);
        
        // Update UI selection
        document.querySelectorAll('.folder-item-content').forEach(item => {
            item.classList.remove('selected');
        });
        document.querySelector('.all-notes-content').classList.add('selected');
        
        // Load all notes
        NoteManager.loadNotes(null);
        
        // Update current folder name
        document.getElementById('current-folder-name').textContent = 'All Notes';
        
        // QUAN TRỌNG: Clear current note selection và images
        AppState.currentId = null;
        AppState.currentImages = [];
        NoteManager.clearEditor();
    },

    async updateFolderNotesCount(folderId) {
        // Function để update count của một folder cụ thể mà không cần reload toàn bộ tree
        try {
            const response = await fetch(`/api/evernote_notes?folder_id=${folderId}`);
            const notes = await response.json();
            const notesCount = Array.isArray(notes) ? notes.length : 0;
            
            // Update UI count
            const countElement = document.querySelector(`[data-folder-id="${folderId}"] .folder-notes-count`);
            if (countElement) {
                countElement.textContent = notesCount;
            }
            
            // Also update all notes count
            this.updateAllNotesCount();
            
        } catch (error) {
            console.error('Error updating folder notes count:', error);
        }
    },

    async updateAllNotesCount() {
        try {
            const response = await fetch('/api/evernote_notes');
            const notes = await response.json();
            const allNotesCount = Array.isArray(notes) ? notes.length : 0;
            
            const countElement = document.getElementById('all-notes-count');
            if (countElement) {
                countElement.textContent = allNotesCount;
            }
        } catch (error) {
            console.error('Error updating all notes count:', error);
        }
    },

    findFolder(id, folders = this.folders) {
        for (const folder of folders) {
            if (folder.id === id) return folder;
            const found = this.findFolder(id, folder.children);
            if (found) return found;
        }
        return null;
    },

    editFolder(folderId) {
        const folder = this.findFolder(folderId);
        if (!folder) return;
        
        document.getElementById('folderModalTitle').innerHTML = '<i class="bi bi-folder me-2"></i>Edit Folder';
        document.getElementById('folder-name').value = folder.name;
        document.getElementById('parent-folder').value = folder.parent_id || '';
        document.getElementById('folder-id').value = folderId;
        
        const modal = new bootstrap.Modal(document.getElementById('folderModal'));
        modal.show();
        
        // Focus vào folder name input và select text để dễ edit
        modal._element.addEventListener('shown.bs.modal', function() {
            const folderNameInput = document.getElementById('folder-name');
            folderNameInput.focus();
            folderNameInput.select(); // Select all text for easy editing
        }, { once: true });
    },

    showDeleteFolderModal(folderId) {
        const modalElement = document.getElementById('deleteFolderModal');
        if (!modalElement) return;

        // Tìm folder name để hiển thị trên tiêu đề
        const folder = this.findFolder(folderId);
        const folderName = folder ? folder.name : 'this folder';

        // 1. Sửa tiêu đề của modal
        const modalTitle = modalElement.querySelector('.modal-title');
        if (modalTitle) {
            modalTitle.innerHTML = `<i class="bi bi-exclamation-triangle-fill me-2 text-danger"></i> Delete: ${folderName}`;
        }

        // 2. Sửa nội dung của modal, loại bỏ các lựa chọn
        const modalBody = modalElement.querySelector('.modal-body');
        if (modalBody) {
            modalBody.innerHTML = `
                <p>Are you sure you want to delete this folder?</p>
                <p class="text-danger fw-bold mt-3">
                    Warning: All notes and subfolders inside will be permanently deleted. This action cannot be undone.
                </p>
            `;
        }

        // 3. Sửa nút xác nhận
        const confirmBtn = modalElement.querySelector('#confirm-delete-folder-btn');
        if (confirmBtn) {
            confirmBtn.dataset.folderId = folderId.toString();
            confirmBtn.innerHTML = 'Delete Everything'; // Đổi text cho rõ ràng
        }

        // Hiển thị modal
        const modal = new bootstrap.Modal(modalElement);
        modal.show();
    },

    async handleDeleteFolder() {
        const deleteBtn = document.getElementById('confirm-delete-folder-btn');
        const folderId = deleteBtn.dataset.folderId;
        
        console.log('handleDeleteFolder - folderId from dataset:', folderId);
        
        // Validate folderId
        if (!folderId || isNaN(folderId)) {
            console.error('Invalid folder ID in dataset:', folderId);
            alert('Error: Invalid folder ID');
            return false;
        }
        
        const action = 'delete_all';
        
        try {
            // Disable button and show loading
            deleteBtn.disabled = true;
            deleteBtn.innerHTML = '<i class="bi bi-hourglass-split me-2"></i>Deleting...';
            
            const deleteUrl = `/api/evernote_folders/${folderId}`;
            console.log('DELETE URL:', deleteUrl);
            
            const response = await fetch(deleteUrl, {
                method: 'DELETE',
                headers: {
                    'Content-Type': 'application/json',
                    'X-Requested-With': 'XMLHttpRequest'
                },
                body: JSON.stringify({action})
            });
            
            console.log('DELETE response status:', response.status);
            
            const responseText = await response.text();
            console.log('DELETE response text:', responseText);
            
            let data;
            try {
                data = JSON.parse(responseText);
            } catch (e) {
                console.error('JSON parse error:', e);
                throw new Error('Server returned invalid response');
            }
            
            if (response.ok && data.status === 'success') {
                // Hide modal properly
                const modal = bootstrap.Modal.getInstance(document.getElementById('deleteFolderModal'));
                if (modal) {
                    modal.hide();
                    
                    // Wait for modal to close completely before proceeding
                    setTimeout(async () => {
                        await this.loadFolders();
                        if (this.currentFolderId == folderId) {
                            this.selectAllNotes();
                        }
                    }, 300);
                } else {
                    // Fallback: reload immediately if modal not found
                    await this.loadFolders();
                    if (this.currentFolderId == folderId) {
                        this.selectAllNotes();
                    }
                }
                
                return true;
            } else {
                throw new Error(data.message || 'Delete failed');
            }
            
        } catch (error) {
            console.error('Delete folder error:', error);
            alert('Delete failed: ' + error.message);
            return false;
        } finally {
            // Re-enable button
            deleteBtn.disabled = false;
            deleteBtn.innerHTML = 'Delete';
        }
    },
    populateParentSelect() {
        const select = document.getElementById('parent-folder');
        select.innerHTML = '<option value="">Root Level</option>';
        
        const addFolderOptions = (folders, level = 0) => {
            folders.forEach(folder => {
                const indent = '  '.repeat(level);
                select.innerHTML += `<option value="${folder.id}">${indent}${folder.name}</option>`;
                if (folder.children.length > 0) {
                    addFolderOptions(folder.children, level + 1);
                }
            });
        };
        
        addFolderOptions(this.folders);
    },

    async createFolder(name, parentId = null) {
        try {
            const response = await fetch('/api/evernote_folders', {
                method: 'POST',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify({name, parent_id: parentId})
            });
            
            const data = await response.json();
            if (data.status === 'success') {
                await this.loadFolders();
                return true;
            } else {
                alert(data.message);
                return false;
            }
        } catch (error) {
            console.error('Error creating folder:', error);
            return false;
        }
    },

    async updateFolder(id, name, parentId = null) {
        try {
            const response = await fetch(`/api/evernote_folders/${id}`, {
                method: 'PUT',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify({name, parent_id: parentId})
            });
            
            const data = await response.json();
            if (data.status === 'success') {
                await this.loadFolders();
                return true;
            } else {
                alert(data.message);
                return false;
            }
        } catch (error) {
            console.error('Error updating folder:', error);
            return false;
        }
    },

    async deleteFolder(id, action = 'move_to_parent') {
        try {
            const response = await fetch(`/api/evernote_folders/${id}`, {
                method: 'DELETE',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify({action})
            });
            
            if (response.ok) {
                await this.loadFolders();
                if (this.currentFolderId === id) {
                    this.selectAllNotes();
                }
                return true;
            }
            return false;
        } catch (error) {
            console.error('Error deleting folder:', error);
            return false;
        }
    }
};

// ===== NOTE MANAGER ===== (UNIFIED VERSION)
const NoteManager = {
    async loadNotes(folderId = null) {
        try {
            // ✅ ALWAYS fetch fresh data với cache busting
            const url = folderId ? `/api/evernote_notes?folder_id=${folderId}` : '/api/evernote_notes';
            const timestamp = Date.now(); // Cache busting
            const fullUrl = `${url}${url.includes('?') ? '&' : '?'}t=${timestamp}`;
            
            console.log('Loading fresh notes from:', fullUrl);
            
            const response = await fetch(fullUrl, {
                cache: 'no-cache',
                headers: {
                    'Cache-Control': 'no-cache, no-store, must-revalidate',
                    'Pragma': 'no-cache',
                    'Expires': '0'
                }
            });
            
            const data = await response.json();
            
            console.log('Fresh API response:', data);
            
            // Validate response data
            if (Array.isArray(data)) {
                AppState.notes = data;
            } else if (data && Array.isArray(data.notes)) {
                AppState.notes = data.notes;
            } else if (data && data.status === 'error') {
                console.error('API error:', data.message);
                AppState.notes = [];
            } else {
                console.warn('Unexpected API response format:', data);
                AppState.notes = [];
            }
            
            // Sort notes by updated_at (newest first), then by title
            AppState.notes.sort((a, b) => {
                const dateA = new Date(a.updated_at || a.created_at || 0);
                const dateB = new Date(b.updated_at || b.created_at || 0);
                if (dateB.getTime() !== dateA.getTime()) {
                    return dateB.getTime() - dateA.getTime();
                }
                
                const titleA = (a.title || 'Untitled').toLowerCase();
                const titleB = (b.title || 'Untitled').toLowerCase();
                return titleA.localeCompare(titleB);
            });
            
            console.log('Fresh AppState.notes (sorted by update time):', AppState.notes);
            
            this.renderNoteList();
            document.getElementById('notes-count').textContent = AppState.notes.length;
            
            // ✅ Smart selection với fresh data check
            if (AppState.notes.length > 0) {
                if (AppState.currentId) {
                    const stillExists = AppState.notes.some(n => n.id === AppState.currentId);
                    if (stillExists) {
                        await this.selectNote(AppState.currentId); // Will fetch fresh data
                    } else {
                        AppState.currentId = AppState.notes[0].id;
                        await this.selectNote(AppState.currentId);
                    }
                } else {
                    AppState.currentId = AppState.notes[0].id;
                    await this.selectNote(AppState.currentId);
                }
            } else {
                AppState.currentId = null;
                this.clearEditor();
            }
        } catch (error) {
            console.error('Error loading fresh notes:', error);
            AppState.notes = [];
            this.renderNoteList();
            document.getElementById('notes-count').textContent = '0';
        }
    },

    async forceRefreshCurrentNote() {
        if (AppState.currentId) {
            console.log('Force refreshing current note:', AppState.currentId);
            await this.selectNote(AppState.currentId);
        }
    },

    // Thêm method để refresh note list
    async forceRefreshNoteList() {
        console.log('Force refreshing note list');
        await this.loadNotes(FolderManager.currentFolderId);
    },

    renderNoteList() {
        const list = document.getElementById('note-list');
        list.innerHTML = '';
        
        // Validate that AppState.notes is an array
        if (!Array.isArray(AppState.notes)) {
            console.error('AppState.notes is not an array:', AppState.notes);
            AppState.notes = [];
            return;
        }
        
        AppState.notes.forEach(note => {
            const li = document.createElement('li');
            li.className = `note-item ${note.id === AppState.currentId ? 'active' : ''}`;
            li.dataset.noteId = note.id;
            
            // Create note content
            const noteContent = document.createElement('div');
            noteContent.className = 'note-item-content';
            
            // Thêm icon để phân biệt note thuộc folder hay không
            const noteIcon = document.createElement('i');
            if (note.folder_id) {
                noteIcon.className = 'bi bi-file-earmark-text note-icon in-folder';
                noteIcon.title = 'Note in folder';
            } else {
                noteIcon.className = 'bi bi-file-earmark note-icon root-level';
                noteIcon.title = 'Root level note';
            }
            
            const noteTitle = document.createElement('span');
            noteTitle.className = 'note-title-text';
            noteTitle.textContent = note.title || 'Untitled';
            
            noteContent.appendChild(noteIcon);
            noteContent.appendChild(noteTitle);
            noteContent.onclick = () => this.selectNote(note.id);
            
            // Create actions container
            const actionsContainer = document.createElement('div');
            actionsContainer.className = 'note-item-actions';
            
            // Create delete button
            const deleteBtn = document.createElement('button');
            deleteBtn.className = 'note-delete-btn';
            deleteBtn.innerHTML = '<i class="bi bi-trash"></i>';
            deleteBtn.title = 'Delete note';
            deleteBtn.onclick = (e) => {
                e.stopPropagation();
                e.preventDefault();
                this.deleteNoteFromList(note.id, note.title);
            };
            
            actionsContainer.appendChild(deleteBtn);
            
            li.appendChild(noteContent);
            li.appendChild(actionsContainer);
            list.appendChild(li);
        });
        
        // Setup drag and drop for newly rendered notes
        DragDropManager.makeNotesDraggable();
    },

    async selectNote(id) {
        AppState.currentId = id;
        ImageDragDropManager.enhanceDropZones();
        
        // ✅ SỬ DỤNG LOCAL DATA ONLY
        const note = AppState.notes.find(n => n.id === id);
        if (!note) {
            console.warn('Note not found in local state:', id);
            // Fallback: reload từ server nếu cần
            this.loadNotes(FolderManager.currentFolderId);
            return;
        }
        
        console.log('✅ Using LOCAL data for note:', note.title);
        
        // Clear previous images state
        AppState.currentImages = [];
        const editor = document.getElementById('evernote-editor');
        
        // Remove existing images sections
        const existingSections = editor.querySelectorAll('.images-section');
        existingSections.forEach(section => section.remove());
        
        // ✅ Set UI với local data
        document.getElementById('note-title').value = note.title || '';
        editor.innerHTML = note.content || '';
        
        // ✅ Load images (vẫn cần fetch vì images có thể thay đổi)
        this.loadNoteImages(id).then(images => {
            AppState.currentImages = images || [];
            console.log('Images loaded for note:', id, AppState.currentImages.length);
            
            if (AppState.currentImages.length > 0) {
                ImageManager.updateImagesInEditor(AppState.currentImages);
            }
        }).catch(error => {
            console.error('Error loading images for note:', id, error);
            AppState.currentImages = [];
        });
        
        // ✅ Update UI với local data
        this.renderNoteList();
        this.updateMeta(note);
        
        console.log('Successfully selected note using local data');
    },


    async loadNoteImages(noteId) {
        try {
            if (!noteId) {
                console.warn('No noteId provided for image loading');
                return [];
            }
            
            const response = await fetch(`/api/evernote_notes/${noteId}/images`);
            if (response.ok) {
                const data = await response.json();
                if (data.status === 'success') {
                    return data.images || [];
                }
            }
            console.warn('Failed to load images for note:', noteId);
            return [];
        } catch (error) {
            console.error('Error loading note images:', error);
            return [];
        }
    },

    updateMeta(note) {
        const metaDiv = document.getElementById('note-meta');
        if (note.created_at && note.updated_at) {
            metaDiv.innerHTML = `Created: ${new Date(note.created_at).toLocaleString()}<br>Updated: ${new Date(note.updated_at).toLocaleString()}`;
            
            if (note.folder_name) {
                metaDiv.innerHTML += `<br>Folder: ${note.folder_name}`;
            }
        } else {
            metaDiv.innerHTML = '';
        }
    },

    // ✅ Thêm method để manual refresh khi cần
    async forceRefreshFromServer() {
        console.log('Force refreshing all data from server...');
        await this.loadNotes(FolderManager.currentFolderId);
        
        // Re-select current note với fresh data
        if (AppState.currentId) {
            this.selectNote(AppState.currentId);
        }
    },

    clearEditor() {
        document.getElementById('note-title').value = '';
        
        // QUAN TRỌNG: Luôn có sẵn <p> tag trong editor
        const editor = document.getElementById('evernote-editor');
        editor.innerHTML = '<p><br></p>';
        
        document.getElementById('note-meta').textContent = '';
        
        // Clear images state và remove images sections
        AppState.currentImages = [];
        
        // Remove any existing images sections from editor
        const existingSections = editor.querySelectorAll('.images-section');
        existingSections.forEach(section => section.remove());
        
        ImageDragDropManager.enhanceDropZones();
    },

    async addNote() {
        try {
            // Clear editor (đã có <p> tag sẵn)
            this.clearEditor();
            
            const title = `Note ${new Date().toLocaleString()}`;
            const currentFolderId = FolderManager.currentFolderId;
            
            // Tạo note với content có sẵn <p> tag
            const data = await API.createNote(title, "<p><br></p>", currentFolderId);
            
            if (data && data.id) {
                AppState.currentId = data.id;
                
                await FolderManager.loadFolders();
                await this.loadNotes(currentFolderId);
                this.selectNote(data.id);
                
                // Focus và đặt cursor trong <p> tag
                setTimeout(() => {
                    const editor = document.getElementById('evernote-editor');
                    const firstP = editor.querySelector('p');
                    if (firstP) {
                        const range = document.createRange();
                        const selection = window.getSelection();
                        
                        range.setStart(firstP, 0);
                        range.collapse(true);
                        
                        selection.removeAllRanges();
                        selection.addRange(range);
                        
                        editor.focus();
                    }
                }, 100);
                
                if (window.innerWidth <= 768) {
                    SidebarManager.closeMobileSidebar();
                    setTimeout(() => {
                        this.focusNoteTitle();
                    }, 450);
                } else {
                    this.focusNoteTitle();
                }
            }
        } catch (error) {
            console.error('Error creating note:', error);
            alert('Error creating note: ' + error.message);
        }
    },

    focusNoteTitle() {
        const titleInput = document.getElementById('note-title');
        if (titleInput) {
            titleInput.scrollIntoView({ 
                behavior: 'smooth', 
                block: 'center' 
            });
            
            setTimeout(() => {
                titleInput.focus();
                titleInput.select();
                console.log('Title input focused and selected');
            }, 100);
        }
    },

    async deleteNote() {
        if (!AppState.currentId) {
            alert('No note selected');
            return;
        }
        
        try {
            const noteTitle = AppState.notes.find(n => n.id === AppState.currentId)?.title || 'Unknown';
            
            await API.deleteNote(AppState.currentId);
            
            // ✅ REMOVE from local state
            AppState.notes = AppState.notes.filter(note => note.id !== AppState.currentId);
            
            // Clear editor
            AppState.currentId = null;
            this.clearEditor();
            
            // ✅ Re-render với local data
            this.renderNoteList();
            document.getElementById('notes-count').textContent = AppState.notes.length;
            
            // Reload folder tree
            await FolderManager.loadFolders();
            
            this.showDeleteSuccess(noteTitle);
            
        } catch (error) {
            console.error('Error deleting note:', error);
            alert('Error deleting note');
            
            // Refresh nếu có lỗi
            this.forceRefreshFromServer();
        }
    },

    // ===== NEW METHODS FROM DRAG & DROP =====
    async deleteNoteFromList(noteId, noteTitle) {
        try {
            // Delete từ server
            await API.deleteNote(noteId);
            
            // ✅ REMOVE from local state immediately
            AppState.notes = AppState.notes.filter(note => note.id !== noteId);
            console.log('✅ Removed note from local state:', noteTitle);
            
            // Nếu note đang được chọn, clear editor
            if (AppState.currentId === noteId) {
                AppState.currentId = null;
                this.clearEditor();
            }
            
            // ✅ Re-render với local data
            this.renderNoteList();
            document.getElementById('notes-count').textContent = AppState.notes.length;
            
            // Reload folder tree để update counts
            await FolderManager.loadFolders();
            
            this.showDeleteSuccess(noteTitle);
            
        } catch (error) {
            console.error('Error deleting note:', error);
            alert('Error deleting note: ' + error.message);
            
            // Refresh từ server nếu delete fail
            this.forceRefreshFromServer();
        }
    },

    showDeleteSuccess(noteTitle) {
        const toast = document.createElement('div');
        toast.className = 'delete-success-toast';
        toast.innerHTML = `
            <i class="bi bi-check-circle-fill"></i>
            <span>Deleted "${noteTitle}"</span>
        `;
        
        // Thêm CSS cho toast nếu chưa có
        if (!document.getElementById('delete-toast-styles')) {
            const toastStyle = document.createElement('style');
            toastStyle.id = 'delete-toast-styles';
            toastStyle.textContent = `
                .delete-success-toast {
                    position: fixed;
                    top: 20px;
                    right: 20px;
                    background: var(--alert-success-color);
                    color: white;
                    padding: 0.75rem 1rem;
                    border-radius: 8px;
                    box-shadow: 0 4px 12px rgba(0,0,0,0.3);
                    z-index: 10000;
                    display: flex;
                    align-items: center;
                    gap: 0.5rem;
                    font-size: 0.9rem;
                    font-weight: 500;
                    animation: slideInRight 0.3s ease, fadeOut 0.3s ease 2.7s forwards;
                }
                
                @keyframes slideInRight {
                    from { transform: translateX(100%); opacity: 0; }
                    to { transform: translateX(0); opacity: 1; }
                }
                
                @keyframes fadeOut {
                    from { opacity: 1; }
                    to { opacity: 0; }
                }
            `;
            document.head.appendChild(toastStyle);
        }
        
        document.body.appendChild(toast);
        
        // Tự động xóa toast sau 3 giây
        setTimeout(() => {
            toast.remove();
        }, 3000);
    }
};

// ===== IMAGE MANAGER =====
const ImageManager = {
    // Upload images with better progress tracking
    async uploadImages(files, noteId) {
        if (!files || files.length === 0) return;
    
        // Validate file types and sizes
        const validFiles = [];
        const invalidFiles = [];
        const maxSize = 10 * 1024 * 1024; // 10MB per file
        
        Array.from(files).forEach(file => {
            if (!file.type.startsWith('image/')) {
                invalidFiles.push({file, reason: 'Not an image file'});
            } else if (file.size > maxSize) {
                invalidFiles.push({file, reason: 'File too large (max 10MB)'});
            } else {
                validFiles.push(file);
            }
        });
        
        // Show warnings for invalid files
        if (invalidFiles.length > 0) {
            const messages = invalidFiles.map(item => 
                `${item.file.name}: ${item.reason}`
            ).join('\n');
            
            ImageDragDropManager.showWarning(
                `${invalidFiles.length} file(s) skipped:\n${messages}`
            );
        }
        
        if (validFiles.length === 0) {
            ImageDragDropManager.showError('No valid image files to upload');
            return;
        }
        
        const formData = new FormData();
        validFiles.forEach((file, index) => {
            formData.append('images', file);
        });
        
        try {
            // Show upload progress
            this.showUploadProgress(true);
            
            const response = await fetch(`/api/evernote_notes/${noteId}/upload_images`, {
                method: 'POST',
                body: formData
            });
            
            if (response.ok) {
                const result = await response.json();
                
                if (result.status === 'success') {
                    // Update images in editor with new URLs
                    await this.loadNoteImages(noteId);
                    
                    // Show success message
                    this.showUploadSuccess(result.processed_count);
                    
                    return result;
                } else {
                    throw new Error(result.message || 'Upload failed');
                }
            } else {
                throw new Error(`HTTP ${response.status}: ${response.statusText}`);
            }
        } catch (error) {
            console.error('Upload failed:', error);
            this.showUploadError(error.message);
            throw error;
        } finally {
            this.showUploadProgress(false);
        }
    },
    
    // Load images for a note
    async loadNoteImages(noteId) {
        try {
            // Validate noteId
            if (!noteId) {
                console.log('No noteId provided, clearing images');
                AppState.currentImages = [];
                return [];
            }
            
            const response = await fetch(`/api/evernote_notes/${noteId}/images`);
            if (response.ok) {
                const data = await response.json();
                if (data.status === 'success' && data.images) {
                    // Update AppState with current images for this specific note
                    AppState.currentImages = data.images;
                    
                    // Update images display in editor
                    this.updateImagesInEditor(data.images);
                    
                    console.log('Loaded images for note:', noteId, data.images.length);
                    return data.images;
                }
            } else {
                console.error('Failed to load note images:', response.status);
            }
        } catch (error) {
            console.error('Error loading note images:', error);
        }
        
        // Fallback: clear images
        AppState.currentImages = [];
        return [];
    },

    cleanupDuplicateSections() {
        const editor = document.getElementById('evernote-editor');
        const imagesSections = editor.querySelectorAll('.images-section');
        
        if (imagesSections.length > 1) {
            console.log(`Found ${imagesSections.length} images sections, cleaning up...`);
            
            // Keep only the last one (most recent)
            for (let i = 0; i < imagesSections.length - 1; i++) {
                imagesSections[i].remove();
            }
            
            console.log('Cleaned up duplicate images sections');
        }
    },
    
    // Update images display in editor
    updateImagesInEditor(images) {
        const editor = document.getElementById('evernote-editor');
        
        // Remove existing images sections
        const existingSections = editor.querySelectorAll('.images-section');
        existingSections.forEach(section => section.remove());
        
        if (images && images.length > 0) {
            // Đảm bảo có content trước images section
            const hasContent = editor.innerHTML.trim() !== '';
            
            if (!hasContent) {
                // Nếu editor trống, thêm <p> tag
                editor.innerHTML = '<p><br></p>';
            }
            
            // Add images section at the end
            const imagesHTML = '<div class="images-section">' + this.displayImages(images) + '</div>';
            editor.insertAdjacentHTML('beforeend', imagesHTML);
            
            // Cursor sẽ tự nhiên ở trong <p> tag đầu tiên
            this.setCursorInFirstParagraph();
        }
    },

    // Thêm method mới
    setCursorInFirstParagraph() {
        const editor = document.getElementById('evernote-editor');
        const firstP = editor.querySelector('p');
        
        if (firstP) {
            try {
                const range = document.createRange();
                const selection = window.getSelection();
                
                // Đặt cursor ở cuối nội dung trong <p> tag
                range.selectNodeContents(firstP);
                range.collapse(false); // false = collapse to end
                
                selection.removeAllRanges();
                selection.addRange(range);
                
                editor.focus();
            } catch (error) {
                console.error('Error setting cursor in paragraph:', error);
                editor.focus();
            }
        }
    },

    ensureCursorBeforeImages() {
        const editor = document.getElementById('evernote-editor');
        const imagesSection = editor.querySelector('.images-section');
        
        if (imagesSection) {
            // Create a text node before images if needed
            const previousNode = imagesSection.previousSibling;
            if (!previousNode || previousNode.nodeType !== Node.TEXT_NODE) {
                const textNode = document.createTextNode('\n');
                editor.insertBefore(textNode, imagesSection);
            }
            
            // Set cursor before images section
            const range = document.createRange();
            const selection = window.getSelection();
            
            range.setStart(editor, editor.childNodes.length - 1); // Before images section
            range.collapse(true);
            
            selection.removeAllRanges();
            selection.addRange(range);
        }
    },
    
    // Display images with optimized HTML
    displayImages(images) {
        if (!images || images.length === 0) return '';
        
        return images.map(img => {
            const sizeStr = img.size ? `(${this.formatFileSize(img.size)})` : '';
            return `
                <div class="image-container" data-filename="${img.filename}">
                    <img src="${img.url}" 
                         alt="${img.filename}"
                         loading="lazy"
                         onclick="ImageManager.showLightbox('${img.url}', '${img.filename}')">
                    <button type="button" class="delete-image-btn" 
                            onclick="ImageManager.deleteImage('${img.filename}', ${AppState.currentId})"
                            title="Delete image">
                        <i class="bi bi-trash"></i>
                    </button>
                    <div class="image-info">
                        <span class="image-filename">${img.filename}</span>
                        <span class="image-size">${sizeStr}</span>
                    </div>
                </div>
            `;
        }).join('');
    },
    
    // Delete image with better UX
    async deleteImage(filename, noteId) {
        try {
            const response = await fetch(`/api/evernote_notes/${noteId}/delete_image/${encodeURIComponent(filename)}`, {
                method: 'DELETE'
            });
            
            if (response.ok) {
                const result = await response.json();
                if (result.status === 'success') {
                    // Remove from current state
                    AppState.currentImages = AppState.currentImages.filter(img => img.filename !== filename);
                    
                    // Remove from DOM with animation
                    const imageContainer = document.querySelector(`[data-filename="${filename}"]`);
                    if (imageContainer) {
                        imageContainer.style.transition = 'opacity 0.3s ease';
                        imageContainer.style.opacity = '0';
                        setTimeout(() => {
                            imageContainer.remove();
                        }, 300);
                    }
                    
                    this.showDeleteSuccess(filename);
                } else {
                    throw new Error(result.message || 'Delete failed');
                }
            } else {
                throw new Error(`HTTP ${response.status}: ${response.statusText}`);
            }
        } catch (error) {
            console.error('Delete failed:', error);
            alert('Failed to delete image: ' + error.message);
        }
    },
    
    // Utility functions
    formatFileSize(bytes) {
        if (bytes === 0) return '0 Bytes';
        const k = 1024;
        const sizes = ['Bytes', 'KB', 'MB', 'GB'];
        const i = Math.floor(Math.log(bytes) / Math.log(k));
        return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
    },
    
    showUploadProgress(show) {
        const progressEl = document.getElementById('upload-progress');
        if (progressEl) {
            progressEl.style.display = show ? 'block' : 'none';
        }
        
        // Disable upload button during upload
        const uploadBtn = document.getElementById('upload-btn');
        if (uploadBtn) {
            uploadBtn.disabled = show;
            uploadBtn.innerHTML = show ? 
                '<i class="bi bi-hourglass-split"></i>' : 
                '<i class="bi bi-image"></i>';
        }
    },
    
    showUploadSuccess(count) {
        this.showToast(`Successfully uploaded ${count} image(s)`, 'success');
    },
    
    showUploadError(message) {
        this.showToast(`Upload failed: ${message}`, 'error');
    },
    
    showDeleteSuccess(filename) {
        this.showToast(`Deleted "${filename}"`, 'success');
    },
    
    showToast(message, type = 'info') {
        const toast = document.createElement('div');
        toast.className = `image-toast image-toast-${type}`;
        toast.innerHTML = `
            <i class="bi bi-${type === 'success' ? 'check-circle-fill' : 'exclamation-triangle-fill'}"></i>
            <span>${message}</span>
        `;
        
        document.body.appendChild(toast);
        
        // Animate in
        setTimeout(() => toast.classList.add('show'), 100);
        
        // Animate out and remove
        setTimeout(() => {
            toast.classList.remove('show');
            setTimeout(() => toast.remove(), 300);
        }, 3000);
    },
    
    // Optimized lightbox
    showLightbox(imageSrc, filename) {
        AppState.isFocusLocked = true;
        const lightbox = document.getElementById('imageLightbox');
        const lightboxImg = document.getElementById('lightboxImg');
        const lightboxCaption = document.getElementById('lightboxCaption');
        
        lightbox.style.display = 'block';
        lightboxImg.src = imageSrc;
        lightboxImg.alt = filename;
        lightboxCaption.textContent = filename || 'Image';
        document.body.style.overflow = 'hidden';
        
        // Preload image for smooth display
        const preloadImg = new Image();
        preloadImg.onload = () => {
            lightboxImg.style.opacity = '1';
        };
        preloadImg.src = imageSrc;
    },
    
    closeLightbox() {
        const lightbox = document.getElementById('imageLightbox');
        const lightboxImg = document.getElementById('lightboxImg');
        
        lightbox.style.display = 'none';
        lightboxImg.style.opacity = '0';
        lightboxImg.src = '';
        document.body.style.overflow = '';
        AppState.isFocusLocked = false;
    }
};

// ===== EDITOR FUNCTIONS =====
function format(cmd, value = null) {
    document.execCommand(cmd, false, value);
    document.getElementById('evernote-editor').focus();
}

function setFontSize(size) {
    if (!size) return;
    document.execCommand('fontSize', false, 7);
    const editor = document.getElementById('evernote-editor');
    const fonts = editor.querySelectorAll('font[size="7"]');
    fonts.forEach(font => {
        const span = document.createElement('span');
        span.style.fontSize = size;
        span.innerHTML = font.innerHTML;
        font.parentNode.replaceChild(span, font);
    });
    editor.focus();
}

function toggleFormat(event, cmd, btn) {
    event.preventDefault();
    document.getElementById('evernote-editor').focus();
    document.execCommand(cmd);
    updateFormatButtons();
    btn.classList.add('active');
    setTimeout(() => btn.classList.remove('active'), 200);
}

function toggleChecklist(event, btn) {
    event.preventDefault();
    AppState.checklistActive = !AppState.checklistActive;
    btn.classList.toggle('active', AppState.checklistActive);
    
    if (AppState.checklistActive) {
        document.execCommand('insertHTML', false, '<input type="checkbox" style="margin-right: 8px;">');
    }
    document.getElementById('evernote-editor').focus();
}

function updateFormatButtons() {
    const buttons = {
        'bold': document.getElementById('bold-btn'),
        'italic': document.getElementById('italic-btn'),
        'underline': document.getElementById('underline-btn'),
        'strikeThrough': document.getElementById('strike-btn'),
        'insertOrderedList': document.getElementById('ordered-btn'),
        'insertUnorderedList': document.getElementById('unordered-btn'),
        'justifyLeft': document.getElementById('left-btn'),
        'justifyCenter': document.getElementById('center-btn'),
        'justifyRight': document.getElementById('right-btn')
    };

    Object.entries(buttons).forEach(([cmd, btn]) => {
        if (btn) {
            btn.classList.toggle('active', document.queryCommandState(cmd));
        }
    });
}

// ===== SEARCH MANAGER =====
// ===== SEARCH MANAGER ===== (CLEANED VERSION)
const SearchManager = {
    modalInstance: null,
    searchResults: [],
    currentIndex: -1,

    init() {
        this.setupSearchModal();
    },

    setupSearchModal() {
        const searchModal = document.getElementById('searchModal');
        const searchTextbox = document.getElementById('search-textbox');
        
        if (searchModal) {
            this.modalInstance = new bootstrap.Modal(searchModal);
            
            searchModal.addEventListener('shown.bs.modal', () => {
                if (searchTextbox) {
                    searchTextbox.focus();
                    searchTextbox.select();
                }
            });
            
            searchModal.addEventListener('hidden.bs.modal', () => {
                this.clearSearch();
            });
        }
        
        if (searchTextbox) {
            searchTextbox.addEventListener('input', (e) => {
                this.performSearch(e.target.value);
            });
            
            searchTextbox.addEventListener('keydown', (e) => {
                this.handleSearchInputKeys(e);
            });
        }
    },

    handleSearchInputKeys(e) {
        switch (e.key) {
            case 'Enter':
                e.preventDefault();
                if (this.searchResults.length > 0) {
                    this.selectFirstResult();
                }
                this.closeSearchModal();
                break;
            case 'Escape':
                this.closeSearchModal();
                break;
            case 'ArrowDown':
                e.preventDefault();
                this.navigateResults(1);
                break;
            case 'ArrowUp':
                e.preventDefault();
                this.navigateResults(-1);
                break;
        }
    },

    openSearchModal() {
        if (this.modalInstance) {
            this.modalInstance.show();
        }
    },

    closeSearchModal() {
        if (this.modalInstance) {
            this.modalInstance.hide();
        }
    },

    performSearch(query) {
        if (!query || query.trim().length < 2) {
            this.clearSearchResults();
            return;
        }

        const searchTerm = query.toLowerCase().trim();
        this.searchResults = [];

        // Search trong notes
        if (Array.isArray(AppState.notes)) {
            AppState.notes.forEach(note => {
                const titleMatches = this.countMatches(note.title || '', searchTerm);
                const contentMatches = this.countMatches(note.content || '', searchTerm);
                
                if (titleMatches > 0) {
                    this.searchResults.push({
                        type: 'note',
                        note: note,
                        matchType: 'title',
                        matchCount: titleMatches,
                        totalMatches: titleMatches + contentMatches
                    });
                } else if (contentMatches > 0) {
                    this.searchResults.push({
                        type: 'note',
                        note: note,
                        matchType: 'content',
                        matchCount: contentMatches,
                        totalMatches: titleMatches + contentMatches
                    });
                }
            });
        }

        this.displaySearchResults();
    },

    // Thêm method đếm số lượng matches
    countMatches(text, searchTerm) {
        if (!text || !searchTerm) return 0;
        
        // Strip HTML tags để đếm chính xác trong content
        const cleanText = this.stripHtml(text).toLowerCase();
        const lowerSearchTerm = searchTerm.toLowerCase();
        
        // Đếm số lần xuất hiện không overlap
        let count = 0;
        let index = 0;
        
        while ((index = cleanText.indexOf(lowerSearchTerm, index)) !== -1) {
            count++;
            index += lowerSearchTerm.length;
        }
        
        return count;
    },

    // Thêm method strip HTML
    stripHtml(html) {
        if (!html) return '';
        
        // Tạo temporary div để strip HTML
        const temp = document.createElement('div');
        temp.innerHTML = html;
        
        // Get text content và clean up whitespace
        return temp.textContent || temp.innerText || '';
    },

    displaySearchResults() {
        let existingResults = document.querySelector('.search-results');
        if (existingResults) {
            existingResults.remove();
        }

        if (this.searchResults.length === 0) {
            return;
        }

        // Sort results by relevance (total matches descending, then title matches first)
        this.searchResults.sort((a, b) => {
            // Prioritize title matches
            if (a.matchType === 'title' && b.matchType !== 'title') return -1;
            if (b.matchType === 'title' && a.matchType !== 'title') return 1;
            
            // Then by total match count
            if (b.totalMatches !== a.totalMatches) {
                return b.totalMatches - a.totalMatches;
            }
            
            // Finally by note title alphabetically
            const titleA = (a.note.title || 'Untitled').toLowerCase();
            const titleB = (b.note.title || 'Untitled').toLowerCase();
            return titleA.localeCompare(titleB);
        });

        const searchModal = document.querySelector('#searchModal .modal-body');
        const resultsContainer = document.createElement('div');
        resultsContainer.className = 'search-results';
        resultsContainer.style.cssText = `
            max-height: 300px;
            overflow-y: auto;
            margin-top: 10px;
            border: 1px solid #ddd;
            border-radius: 6px;
            background: white;
        `;

        // Add results summary
        const summaryDiv = document.createElement('div');
        summaryDiv.className = 'search-summary';
        summaryDiv.style.cssText = `
            padding: 0.5rem 0.75rem;
            background: #f8f9fa;
            border-bottom: 1px solid #dee2e6;
            font-size: 0.8rem;
            color: #6c757d;
            font-weight: 500;
        `;
        
        const totalMatches = this.searchResults.reduce((sum, result) => sum + result.totalMatches, 0);
        summaryDiv.textContent = `Found ${this.searchResults.length} notes with ${totalMatches} total matches`;
        
        resultsContainer.appendChild(summaryDiv);

        this.searchResults.forEach((result, index) => {
            const resultItem = this.createResultItem(result, index);
            resultsContainer.appendChild(resultItem);
        });

        searchModal.appendChild(resultsContainer);
    },

    createResultItem(result, index) {
        const resultItem = document.createElement('div');
        resultItem.className = `search-result-item ${index === this.currentIndex ? 'active' : ''}`;
        resultItem.style.cssText = `
            padding: 10px;
            border-bottom: 1px solid #eee;
            cursor: pointer;
            transition: background 0.2s ease;
        `;
        
        // Tạo match count badge
        const matchBadge = this.createMatchBadge(result);
        
        resultItem.innerHTML = `
            <div style="font-weight: 500; color: #333; display: flex; align-items: center; justify-content: space-between;">
                <span>${result.note.title || 'Untitled'}</span>
                ${matchBadge}
            </div>
            <div style="font-size: 0.85rem; color: #666; margin-top: 4px;">
                <i class="bi bi-folder me-1 text-warning"></i>Match in ${result.matchType} • ${result.note.folder_name || 'Root'}
            </div>
        `;

        resultItem.addEventListener('mouseenter', () => {
            this.setActiveResult(index);
        });

        resultItem.addEventListener('click', () => {
            this.selectResult(result);
            this.closeSearchModal();
        });

        return resultItem;
    },

    // Thêm method tạo match badge
    createMatchBadge(result) {
        const count = result.matchCount;
        const total = result.totalMatches;
        
        let badgeClass = 'match-badge';
        let badgeColor = '#6c757d'; // Default gray
        
        // Thay đổi màu dựa trên số lượng matches
        if (total >= 10) {
            badgeClass += ' match-badge-high';
            badgeColor = '#dc3545'; // Red for high matches
        } else if (total >= 5) {
            badgeClass += ' match-badge-medium';
            badgeColor = '#fd7e14'; // Orange for medium matches
        } else if (total >= 2) {
            badgeClass += ' match-badge-low';
            badgeColor = '#ffc107'; // Yellow for low matches
        } else {
            badgeClass += ' match-badge-single';
            badgeColor = '#28a745'; // Green for single match
        }
        
        // Hiển thị format khác nhau tùy context
        let displayText;
        if (result.matchType === 'title' && total > count) {
            // Title match nhưng có thêm content matches
            displayText = `${count}+${total - count}`;
        } else if (result.matchType === 'content' && total > count) {
            // Content match, có thể có title matches
            displayText = `${total}`;
        } else {
            // Chỉ có matches trong 1 loại
            displayText = `${count}`;
        }
        
        return `
            <span class="${badgeClass}" 
                style="background: ${badgeColor}; color: white; font-size: 0.7rem; padding: 0.2rem 0.4rem; border-radius: 10px; font-weight: 600;"
                title="${total} total matches (${result.matchType}: ${count})">
                ${displayText}
            </span>
        `;
    },

    selectResult(result) {
        if (result.type !== 'note') return;

        // Switch to folder chứa note nếu cần
        if (result.note.folder_id && result.note.folder_id !== FolderManager.currentFolderId) {
            FolderManager.selectFolder(result.note.folder_id);
        } else if (!result.note.folder_id && FolderManager.currentFolderId !== null) {
            FolderManager.selectAllNotes();
        }
        
        // Select note
        setTimeout(() => {
             NoteManager.selectNote(result.note.id);
            
            // Close mobile sidebar if open
            if (window.innerWidth <= 768 && SidebarManager.isMobileOpen) {
                SidebarManager.closeMobileSidebar();
            }
        }, 100);
    },

    navigateResults(direction) {
        if (this.searchResults.length === 0) return;

        this.currentIndex += direction;
        
        if (this.currentIndex >= this.searchResults.length) {
            this.currentIndex = 0;
        } else if (this.currentIndex < 0) {
            this.currentIndex = this.searchResults.length - 1;
        }

        this.setActiveResult(this.currentIndex);
    },

    setActiveResult(index) {
        this.currentIndex = index;
        
        const resultItems = document.querySelectorAll('.search-result-item');
        resultItems.forEach((item, i) => {
            if (i === index) {
                item.classList.add('active');
                item.style.background = '#e3f2fd';
                item.scrollIntoView({ block: 'nearest' });
            } else {
                item.classList.remove('active');
                item.style.background = '';
            }
        });
    },

    selectFirstResult() {
        if (this.searchResults.length > 0) {
            this.selectResult(this.searchResults[0]);
        }
    },

    clearSearchResults() {
        const existingResults = document.querySelector('.search-results');
        if (existingResults) {
            existingResults.remove();
        }
        this.searchResults = [];
        this.currentIndex = -1;
    },

    clearSearch() {
        const searchTextbox = document.getElementById('search-textbox');
        if (searchTextbox) {
            searchTextbox.value = '';
        }
        this.clearSearchResults();
    }
};


// ===== INITIALIZATION =====
document.addEventListener('DOMContentLoaded', () => {

    SidebarManager.init();
    SidebarManager.restoreState(); 
    AutoScrollSettings.init();
    MobileToolbarManager.init();
    UniversalCursorManager.init();
    SidebarManager.init();
    ImageDragDropManager.init();

    // Add keyboard open/close styles
    const keyboardStyles = document.createElement('style');
    keyboardStyles.textContent = `
        body.keyboard-open {
            /* Adjust body when keyboard is open */
        }
        
        @media (max-width: 768px) {
            /* Ensure proper mobile behavior */
            .note-editor, .title-input {
                font-size: 16px !important;
                -webkit-text-size-adjust: 100%;
            }
            
            /* Better touch scrolling */
            .note-editor-wrapper {
                -webkit-overflow-scrolling: touch;
                overflow-y: auto;
            }
        }
    `;
    document.head.appendChild(keyboardStyles);

    DragDropManager.init();

    const searchBtn = document.getElementById('search-btn');
    if (searchBtn) {
        searchBtn.onclick = () => {
            SearchManager.openSearchModal();
        };
    }
    
    // Setup search modal events
    SearchManager.init();

    // Initialize auto-save
    SaveManager.autoSave = SaveManager.debounce(() => {
        const title = document.getElementById('note-title').value.trim();
        const editor = document.getElementById('evernote-editor');
        const content = SaveManager.cleanEditorContent(editor);
        
        // ✅ So sánh với dữ liệu thực tế từ server
        if (AppState.currentId) {
            const currentNote = AppState.notes.find(n => n.id === AppState.currentId);
            if (currentNote && 
                title === currentNote.title && 
                content === currentNote.content) {
                console.log('No changes detected, skipping auto-save');
                return;
            }
        }
        
        console.log('Auto-saving changes...');
         SaveManager.saveNote();
    }, 3000);

    const preventScrollConflicts = () => {
        // Disable CSS scroll-behavior when auto-scroll is handling
        const style = document.createElement('style');
        style.id = 'scroll-conflict-prevention';
        style.textContent = `
            html.auto-scroll-active {
                scroll-behavior: auto !important;
            }
            
            html.auto-scroll-smooth {
                scroll-behavior: smooth !important;
            }
        `;
        document.head.appendChild(style);
    };
    
    preventScrollConflicts();

    // Setup button events
    document.getElementById('add-note-btn').onclick = () => NoteManager.addNote();
    document.getElementById('clear-title-btn').onclick = () => {
        document.getElementById('note-title').value = "";
        document.getElementById('note-title').focus();
    };

    document.getElementById('add-note-btn').onclick = async () => {
        console.log('Add note button clicked on mobile:', DeviceUtils.isMobile());
        await NoteManager.addNote();
    };
    // Setup sidebar toggle
    document.getElementById('toggle-sidebar-btn').onclick = () => {
        const sidebar = document.getElementById('note-sidebar');
        sidebar.classList.toggle('collapsed');
    };

    document.getElementById('folderModal').addEventListener('keydown', function(e) {
        // Enter key để save (chỉ khi không focus vào Cancel button)
        if (e.key === 'Enter' && !e.target.classList.contains('btn-secondary')) {
            e.preventDefault();
            document.getElementById('save-folder-btn').click();
        }
        
        // Escape key để cancel (ngoài default behavior)
        if (e.key === 'Escape') {
            const modal = bootstrap.Modal.getInstance(this);
            if (modal) modal.hide();
        }
    });

    // Thêm validation khi submit bằng Enter
    document.getElementById('folder-name').addEventListener('keydown', function(e) {
        if (e.key === 'Enter') {
            e.preventDefault();
            
            // Validate tên folder
            const folderName = this.value.trim();
            if (!folderName) {
                this.focus();
                // Có thể thêm visual feedback cho validation
                this.classList.add('is-invalid');
                setTimeout(() => {
                    this.classList.remove('is-invalid');
                }, 2000);
                return;
            }
            
            // Nếu valid thì submit
            document.getElementById('save-folder-btn').click();
        }
    });

    const editor = document.getElementById('evernote-editor');
    if (editor) {
        editor.addEventListener('input', () => {
            // Check for duplicate images sections after any input
            ImageManager.cleanupDuplicateSections();
        });
        
        editor.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') {
                // Prevent Enter from creating new sections
                setTimeout(() => {
                    ImageManager.cleanupDuplicateSections();
                }, 10);
            }
        });
    }

    // Setup image upload
    const imageInput = document.createElement('input');
    imageInput.type = 'file';
    imageInput.multiple = true;
    imageInput.accept = 'image/*';
    imageInput.style.display = 'none';
    document.body.appendChild(imageInput);
    
    imageInput.addEventListener('change', async (e) => {
        if (AppState.currentId && e.target.files.length > 0) {
            await ImageManager.uploadImages(e.target.files, AppState.currentId);
        }
        e.target.value = '';
    });
    
    document.getElementById('upload-btn').onclick = () => {
        if (AppState.currentId) {
            imageInput.click();
        } else {
            alert('Please select a note first');
        }
    };

    // Setup lightbox
    const lightboxClose = document.querySelector('.lightbox-close');
    const lightbox = document.getElementById('imageLightbox');
    
    lightboxClose.onclick = () => ImageManager.closeLightbox();
    lightbox.onclick = (e) => {
        if (e.target === lightbox) ImageManager.closeLightbox();
    };
    
    document.addEventListener('keydown', (e) => {
        if (e.key === 'Escape') ImageManager.closeLightbox();
    });

    // Initialize folder management
    FolderManager.loadFolders();
    
    // Add folder button
    document.getElementById('add-folder-btn').onclick = () => {
        document.getElementById('folderModalTitle').innerHTML = '<i class="bi bi-folder me-2"></i>Create Folder';
        document.getElementById('folder-name').value = '';
        document.getElementById('parent-folder').value = FolderManager.currentFolderId || '';
        document.getElementById('folder-id').value = '';
        
        const modal = new bootstrap.Modal(document.getElementById('folderModal'));
        modal.show();
        
        // Focus vào folder name input sau khi modal hiển thị
        modal._element.addEventListener('shown.bs.modal', function() {
            document.getElementById('folder-name').focus();
        }, { once: true });
    };
    
    // Save folder button
    document.getElementById('save-folder-btn').onclick = async () => {
        const name = document.getElementById('folder-name').value.trim();
        const parentId = document.getElementById('parent-folder').value || null;
        const folderId = document.getElementById('folder-id').value;
        
        if (!name) {
            alert('Please enter a folder name');
            return;
        }
        
        let success;
        if (folderId) {
            success = await FolderManager.updateFolder(folderId, name, parentId);
        } else {
            success = await FolderManager.createFolder(name, parentId);
        }
        
        if (success) {
            const modal = bootstrap.Modal.getInstance(document.getElementById('folderModal'));
            modal.hide();
        }
    };
    
    // Confirm delete folder button
    document.getElementById('confirm-delete-folder-btn').addEventListener('click', async (event) => {
        event.preventDefault();
        event.stopPropagation();
        
        // Prevent multiple clicks
        if (event.target.disabled) {
            return;
        }
        
        await FolderManager.handleDeleteFolder();
    });

    // Add resize handler
    window.addEventListener('resize', () => {
        SidebarManager.handleResize();
        MobileToolbarManager.handleResize();
        UniversalCursorManager.handleResize(); // Add this line
    });

    // Restore sidebar state after everything is loaded
    setTimeout(() => {
        SidebarManager.restoreState();
    }, 500);

    // Setup editor events
    const titleInput = document.getElementById('note-title');
    
    editor.addEventListener('input', SaveManager.autoSave);
    editor.addEventListener('blur', () => SaveManager.saveNote());
    editor.addEventListener('keyup', updateFormatButtons);
    editor.addEventListener('mouseup', updateFormatButtons);
    
    titleInput.addEventListener('input', SaveManager.autoSave);
    titleInput.addEventListener('blur', () => SaveManager.saveNote());

    // Load initial data
    NoteManager.loadNotes();
});

function setupStickyToolbar() {
    const toolbar = document.querySelector('.editor-toolbar');
    if (!toolbar) return;
    
    let scrollTimeout;
    
    // Detect scroll trên window
    window.addEventListener('scroll', () => {
        clearTimeout(scrollTimeout);
        scrollTimeout = setTimeout(() => {
            const scrollTop = window.pageYOffset || document.documentElement.scrollTop;
            
            if (scrollTop > 50) {
                toolbar.classList.add('scrolled');
            } else {
                toolbar.classList.remove('scrolled');
            }
        }, 10);
    });
    
    // Detect scroll trong editor container (backup)
    const editorWrapper = document.querySelector('.note-editor-wrapper');
    if (editorWrapper) {
        editorWrapper.addEventListener('scroll', () => {
            if (editorWrapper.scrollTop > 10) {
                toolbar.classList.add('scrolled');
            } else {
                toolbar.classList.remove('scrolled');
            }
        });
    }
}

// ===== MOBILE CURSOR MANAGER =====
const MobileCursorManager = {
    isKeyboardOpen: false,
    originalViewportHeight: 0,
    currentSelection: null,
    scrollTimeout: null,
    keyboardHeight: 0,
    isScrolling: false,

    init() {
        this.originalViewportHeight = window.innerHeight;
        
        // Only initialize on mobile devices
        if (this.isMobile()) {
            console.log('Mobile detected, initializing cursor manager');
            this.setupViewportListener();
            this.setupSelectionTracking();
            this.setupKeyboardDetection();
            this.setupMobileOptimizations();
        }
    },

    setupMobileOptimizations() {
        // Prevent zoom on input focus
        const viewportMeta = document.querySelector('meta[name="viewport"]');
        if (viewportMeta) {
            viewportMeta.setAttribute('content', 'width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no');
        }

        // Add mobile-specific styles
        const mobileStyle = document.createElement('style');
        mobileStyle.id = 'mobile-cursor-styles';
        mobileStyle.textContent = `
            @media (max-width: 768px) {
                input, textarea, [contenteditable] {
                    font-size: 16px !important;
                    transform: scale(1);
                }
                
                html, body {
                    scroll-behavior: smooth;
                    -webkit-overflow-scrolling: touch;
                }
                
                .note-editor-wrapper {
                    min-height: 100vh;
                }
                
                .note-editor {
                    min-height: 50vh;
                    padding-bottom: 30vh;
                }
            }
        `;
        document.head.appendChild(mobileStyle);
    },

    setupViewportListener() {
        let resizeTimer;
        
        // Main viewport resize handler
        window.addEventListener('resize', () => {
            clearTimeout(resizeTimer);
            resizeTimer = setTimeout(() => {
                this.handleViewportChange();
            }, 100);
        });

        // Visual Viewport API (better for iOS)
        if (window.visualViewport) {
            window.visualViewport.addEventListener('resize', () => {
                this.handleVisualViewportChange();
            });
        }

        // Fallback: orientation change
        window.addEventListener('orientationchange', () => {
            setTimeout(() => {
                this.originalViewportHeight = window.innerHeight;
                this.handleViewportChange();
            }, 500);
        });
    },

    handleViewportChange() {
        const currentHeight = window.innerHeight;
        const heightDiff = this.originalViewportHeight - currentHeight;
        
        console.log(`Viewport change: original=${this.originalViewportHeight}, current=${currentHeight}, diff=${heightDiff}`);
        
        // Keyboard is open if height reduced by more than 150px
        const wasKeyboardOpen = this.isKeyboardOpen;
        this.isKeyboardOpen = heightDiff > 150;
        this.keyboardHeight = Math.max(0, heightDiff);
        
        if (this.isKeyboardOpen && !wasKeyboardOpen) {
            console.log('Keyboard opened - height diff:', heightDiff);
            this.handleKeyboardOpen();
        } else if (!this.isKeyboardOpen && wasKeyboardOpen) {
            console.log('Keyboard closed');
            this.handleKeyboardClose();
        }
    },

    handleVisualViewportChange() {
        if (!window.visualViewport) return;
        
        const heightDiff = window.innerHeight - window.visualViewport.height;
        const wasKeyboardOpen = this.isKeyboardOpen;
        this.isKeyboardOpen = heightDiff > 100;
        this.keyboardHeight = Math.max(0, heightDiff);
        
        console.log(`Visual viewport: window=${window.innerHeight}, visual=${window.visualViewport.height}, diff=${heightDiff}`);
        
        if (this.isKeyboardOpen && !wasKeyboardOpen) {
            console.log('Keyboard opened (visual viewport)');
            this.handleKeyboardOpen();
        } else if (!this.isKeyboardOpen && wasKeyboardOpen) {
            console.log('Keyboard closed (visual viewport)');
            this.handleKeyboardClose();
        }
    },

    setupSelectionTracking() {
        const editor = document.getElementById('evernote-editor');
        const titleInput = document.getElementById('note-title');

        if (editor) {
            editor.addEventListener('focus', (e) => {
                console.log('Editor focused');
                this.startTrackingCursor(editor);
            });

            editor.addEventListener('blur', () => {
                console.log('Editor blurred');
                this.stopTrackingCursor();
            });
        }

        if (titleInput) {
            titleInput.addEventListener('focus', (e) => {
                console.log('Title input focused');
                this.startTrackingCursor(titleInput);
            });

            titleInput.addEventListener('blur', () => {
                console.log('Title input blurred');
                this.stopTrackingCursor();
            });
        }
    },

    setupKeyboardDetection() {
        // Enhanced focus detection
        document.addEventListener('focusin', (e) => {
            if (this.isInputElement(e.target)) {
                console.log('Input element focused:', e.target.tagName);
                this.currentSelection = e.target;
                
                // Check keyboard after delay
                setTimeout(() => {
                    this.checkKeyboardAndScroll();
                }, 300);
            }
        });

        document.addEventListener('focusout', (e) => {
            console.log('Element lost focus');
            setTimeout(() => {
                // Only reset if no other input is focused
                if (!document.activeElement || !this.isInputElement(document.activeElement)) {
                    this.currentSelection = null;
                    this.isKeyboardOpen = false;
                }
            }, 100);
        });
    },

    startTrackingCursor(element) {
        console.log('Starting to track cursor for:', element.tagName);
        this.currentSelection = element;
        
        // Remove old listeners first
        element.removeEventListener('keyup', this.boundOnCursorMove);
        element.removeEventListener('click', this.boundOnCursorMove);
        element.removeEventListener('input', this.boundOnCursorMove);
        
        // Bind methods to preserve 'this' context
        this.boundOnCursorMove = () => this.onCursorMove();
        
        // Add new listeners
        element.addEventListener('keyup', this.boundOnCursorMove);
        element.addEventListener('click', this.boundOnCursorMove);
        element.addEventListener('input', this.boundOnCursorMove);
    },

    stopTrackingCursor() {
        console.log('Stopped tracking cursor');
        if (this.currentSelection && this.boundOnCursorMove) {
            this.currentSelection.removeEventListener('keyup', this.boundOnCursorMove);
            this.currentSelection.removeEventListener('click', this.boundOnCursorMove);
            this.currentSelection.removeEventListener('input', this.boundOnCursorMove);
        }
        this.currentSelection = null;
    },

    // UNIFIED onCursorMove with auto-scroll control
    onCursorMove() {
        if (!AutoScrollSettings.isEnabled()) {
            return;
        }
        
        if (this.isScrolling) {
            return;
        }
        
        // Improved debouncing
        clearTimeout(this.scrollTimeout);
        this.scrollTimeout = setTimeout(() => {
            if (!this.isScrolling) { // Double check
                this.scrollToKeepCursorCentered(); // or scrollToKeepCursorVisible for desktop
            }
        }, 80); // Faster response time
    },

    // UNIFIED handleKeyboardOpen with auto-scroll control
    handleKeyboardOpen() {
        console.log('handleKeyboardOpen called, auto-scroll enabled:', AutoScrollSettings.isEnabled());
        
        document.body.classList.add('keyboard-open');
        
        if (!AutoScrollSettings.isEnabled()) {
            console.log('❌ Auto-scroll DISABLED - Blocking keyboard open handling');
            return;
        }
        
        console.log('✅ Auto-scroll ENABLED - Handling keyboard open');
        
        if (this.currentSelection) {
            setTimeout(() => {
                this.scrollToKeepCursorCentered();
            }, 300);
        }
    },

    handleKeyboardClose() {
        console.log('Handling keyboard close');
        document.body.classList.remove('keyboard-open');
    },

    // UNIFIED scrollToKeepCursorCentered with auto-scroll control
    scrollToKeepCursorCentered() {
        if (!AutoScrollSettings.isEnabled()) {
            return;
        }
        
        if (this.isScrolling || !this.currentSelection) {
            return;
        }

        this.isScrolling = true;

        try {
            const cursorRect = this.getCursorPosition();
            if (!cursorRect) {
                this.isScrolling = false;
                return;
            }

            const viewportHeight = window.visualViewport ? 
                window.visualViewport.height : 
                (window.innerHeight - this.keyboardHeight);
            
            // Calculate target position more precisely
            const targetY = viewportHeight * 0.4; // Target 40% from top
            const currentCursorY = cursorRect.top;
            const scrollNeeded = currentCursorY - targetY;

            // Use smaller threshold for smoother experience
            if (Math.abs(scrollNeeded) > 15) {
                const currentScroll = window.pageYOffset || document.documentElement.scrollTop;
                const newScrollPosition = Math.max(0, currentScroll + scrollNeeded);
                
                // Use CSS scroll-behavior for native smoothness
                this.smoothScrollToPosition(newScrollPosition);
            } else {
                this.isScrolling = false;
            }
        } catch (error) {
            console.error('Error in mobile cursor scroll:', error);
            this.isScrolling = false;
        }
    },

    // New method using CSS scroll-behavior
    smoothScrollToPosition(targetPosition) {
        // Enable smooth scrolling temporarily
        document.documentElement.style.scrollBehavior = 'smooth';
        
        window.scrollTo({
            top: targetPosition,
            behavior: 'smooth'
        });
        
        // Reset scrolling flag after animation completes
        setTimeout(() => {
            this.isScrolling = false;
            // Restore original scroll behavior
            document.documentElement.style.scrollBehavior = '';
        }, 300); // Estimated animation duration
    },

    // Alternative RAF-based smooth scroll (backup method)
    smoothScrollTo(targetPosition) {
        const startPosition = window.pageYOffset || document.documentElement.scrollTop;
        const distance = targetPosition - startPosition;
        const duration = 250; // Reduced duration for responsiveness
        const startTime = performance.now();
        
        let animationId;

        const animateScroll = (currentTime) => {
            if (!AutoScrollSettings.isEnabled()) {
                this.isScrolling = false;
                AutoScrollSettings.unregisterAnimation(animationId);
                return;
            }

            const elapsed = currentTime - startTime;
            const progress = Math.min(elapsed / duration, 1);
            
            // Use different easing for mobile - more natural
            const easeProgress = this.easeOutCubic(progress);
            const currentPosition = startPosition + (distance * easeProgress);
            
            // Use direct scrollTo for immediate effect
            window.scrollTo(0, currentPosition);
            
            if (progress < 1) {
                animationId = requestAnimationFrame(animateScroll);
                AutoScrollSettings.registerAnimation(animationId);
            } else {
                this.isScrolling = false;
                AutoScrollSettings.unregisterAnimation(animationId);
            }
        };

        animationId = requestAnimationFrame(animateScroll);
        AutoScrollSettings.registerAnimation(animationId);
    },

    // Better easing function
    easeOutCubic(t) {
        return 1 - Math.pow(1 - t, 3);
    },

    getCursorPosition() {
        if (!this.currentSelection) return null;

        try {
            if (this.currentSelection.tagName === 'INPUT' || this.currentSelection.tagName === 'TEXTAREA') {
                return this.getInputCursorPosition();
            } else {
                return this.getContentEditableCursorPosition();
            }
        } catch (error) {
            console.error('Error getting cursor position:', error);
            return this.currentSelection.getBoundingClientRect();
        }
    },

    getInputCursorPosition() {
        const element = this.currentSelection;
        const rect = element.getBoundingClientRect();
        
        return {
            top: rect.top + (rect.height / 2),
            left: rect.left,
            bottom: rect.bottom,
            right: rect.right,
            height: rect.height,
            width: rect.width
        };
    },

    getContentEditableCursorPosition() {
        const selection = window.getSelection();
        if (!selection.rangeCount) {
            return this.currentSelection.getBoundingClientRect();
        }

        const range = selection.getRangeAt(0);
        let rect = range.getBoundingClientRect();
        
        if (rect.width === 0 && rect.height === 0) {
            const tempSpan = document.createElement('span');
            tempSpan.innerHTML = '&#8203;';
            range.insertNode(tempSpan);
            rect = tempSpan.getBoundingClientRect();
            tempSpan.remove();
        }
        
        return rect;
    },

    checkKeyboardAndScroll() {
        setTimeout(() => {
            const currentHeight = window.innerHeight;
            const heightDiff = this.originalViewportHeight - currentHeight;
            
            console.log(`Checking keyboard: heightDiff=${heightDiff}`);
            
            if (heightDiff > 150) {
                this.isKeyboardOpen = true;
                this.keyboardHeight = heightDiff;
                console.log('Keyboard detected, scrolling to center cursor');
                this.scrollToKeepCursorCentered();
            }
        }, 200);
    },

    isMobile() {
        const userAgent = navigator.userAgent || navigator.vendor || window.opera;
        const isMobileUserAgent = /android|iphone|ipad|ipod|blackberry|iemobile|opera mini/i.test(userAgent);
        const isMobileViewport = window.innerWidth <= 768;
        const hasTouchScreen = 'ontouchstart' in window || navigator.maxTouchPoints > 0;
        
        return isMobileUserAgent || (isMobileViewport && hasTouchScreen);
    },

    isInputElement(element) {
        if (!element) return false;
        const inputTypes = ['INPUT', 'TEXTAREA'];
        return inputTypes.includes(element.tagName) || element.contentEditable === 'true';
    }
};


// ===== DESKTOP CURSOR MANAGER =====
const DesktopCursorManager = {
    currentSelection: null,
    scrollTimeout: null,
    isTracking: false,
    isScrolling: false, // Add this flag

    init() {
        // Only initialize on desktop devices
        if (!this.isMobile()) {
            console.log('Desktop detected, initializing cursor manager');
            this.setupDesktopTracking();
        }
    },

    setupDesktopTracking() {
        const editor = document.getElementById('evernote-editor');
        const titleInput = document.getElementById('note-title');

        if (editor) {
            editor.addEventListener('focus', (e) => {
                console.log('Desktop editor focused');
                this.startTrackingCursor(editor);
            });

            editor.addEventListener('blur', () => {
                console.log('Desktop editor blurred');
                this.stopTrackingCursor();
            });
        }

        if (titleInput) {
            titleInput.addEventListener('focus', (e) => {
                console.log('Desktop title input focused');
                this.startTrackingCursor(titleInput);
            });

            titleInput.addEventListener('blur', () => {
                console.log('Desktop title input blurred');
                this.stopTrackingCursor();
            });
        }
    },

    startTrackingCursor(element) {
        console.log('Desktop: Starting to track cursor for:', element.tagName);
        this.currentSelection = element;
        this.isTracking = true;
        
        // Remove old listeners first
        element.removeEventListener('keyup', this.boundOnCursorMove);
        element.removeEventListener('click', this.boundOnCursorMove);
        element.removeEventListener('input', this.boundOnCursorMove);
        element.removeEventListener('scroll', this.boundOnCursorMove);
        
        // Bind methods to preserve 'this' context
        this.boundOnCursorMove = () => this.onCursorMove();
        
        // Add new listeners - including scroll event
        element.addEventListener('keyup', this.boundOnCursorMove);
        element.addEventListener('click', this.boundOnCursorMove);
        element.addEventListener('input', this.boundOnCursorMove);
        
        // Track scrolling trong editor
        if (element.tagName === 'DIV' && element.contentEditable === 'true') {
            element.addEventListener('scroll', this.boundOnCursorMove);
        }
    },

    stopTrackingCursor() {
        console.log('Desktop: Stopped tracking cursor');
        if (this.currentSelection && this.boundOnCursorMove) {
            this.currentSelection.removeEventListener('keyup', this.boundOnCursorMove);
            this.currentSelection.removeEventListener('click', this.boundOnCursorMove);
            this.currentSelection.removeEventListener('input', this.boundOnCursorMove);
            this.currentSelection.removeEventListener('scroll', this.boundOnCursorMove);
        }
        this.currentSelection = null;
        this.isTracking = false;
    },

    onCursorMove() {
        if (!AutoScrollSettings.isEnabled()) {
            return;
        }
        
        if (this.isScrolling) {
            return; // Prevent concurrent scrolls
        }
        
        clearTimeout(this.scrollTimeout);
        this.scrollTimeout = setTimeout(() => {
            this.scrollToKeepCursorVisible();
        }, 100); // Reduced delay
    },

    scrollToKeepCursorVisible() {
        if (!AutoScrollSettings.isEnabled() || this.isScrolling) {
            return;
        }
        
        if (!this.currentSelection || !this.isTracking) {
            return;
        }

        this.isScrolling = true;

        try {
            const cursorRect = this.getCursorPosition();
            if (!cursorRect) {
                this.isScrolling = false;
                return;
            }

            const viewportHeight = window.innerHeight;
            const viewportTop = window.pageYOffset || document.documentElement.scrollTop;

            const cursorTop = cursorRect.top + viewportTop;
            const cursorBottom = cursorRect.bottom + viewportTop;

            // Tighter zones for more responsive scrolling
            const topZone = viewportTop + (viewportHeight * 0.25); // 25% from top
            const bottomZone = viewportTop + (viewportHeight * 0.75); // 25% from bottom

            let scrollNeeded = 0;

            if (cursorTop < topZone) {
                scrollNeeded = cursorTop - (viewportTop + (viewportHeight * 0.3));
            } else if (cursorBottom > bottomZone) {
                scrollNeeded = cursorBottom - (viewportTop + (viewportHeight * 0.7));
            }

            if (Math.abs(scrollNeeded) > 10) {
                const newScrollPosition = viewportTop + scrollNeeded;
                this.smoothScrollToPosition(Math.max(0, newScrollPosition));
            } else {
                this.isScrolling = false;
            }
        } catch (error) {
            console.error('Error in desktop cursor scroll:', error);
            this.isScrolling = false;
        }
    },

    // Same smooth scroll methods as mobile
    smoothScrollToPosition(targetPosition) {
        document.documentElement.style.scrollBehavior = 'smooth';
        
        window.scrollTo({
            top: targetPosition,
            behavior: 'smooth'
        });
        
        setTimeout(() => {
            this.isScrolling = false;
            document.documentElement.style.scrollBehavior = '';
        }, 250);
    },

    smoothScrollTo(targetPosition) {
        const startPosition = window.pageYOffset || document.documentElement.scrollTop;
        const distance = targetPosition - startPosition;
        const duration = 200; // Faster for desktop
        const startTime = performance.now();
        
        let animationId;

        const animateScroll = (currentTime) => {
            if (!AutoScrollSettings.isEnabled()) {
                this.isScrolling = false;
                AutoScrollSettings.unregisterAnimation(animationId);
                return;
            }

            const elapsed = currentTime - startTime;
            const progress = Math.min(elapsed / duration, 1);
            
            const easeProgress = this.easeOutQuart(progress);
            const currentPosition = startPosition + (distance * easeProgress);
            
            window.scrollTo(0, currentPosition);
            
            if (progress < 1) {
                animationId = requestAnimationFrame(animateScroll);
                AutoScrollSettings.registerAnimation(animationId);
            } else {
                this.isScrolling = false;
                AutoScrollSettings.unregisterAnimation(animationId);
            }
        };

        animationId = requestAnimationFrame(animateScroll);
        AutoScrollSettings.registerAnimation(animationId);
    },

    easeOutQuart(t) {
        return 1 - Math.pow(1 - t, 4);
    },

    getCursorPosition() {
        if (!this.currentSelection) return null;

        try {
            if (this.currentSelection.tagName === 'INPUT' || this.currentSelection.tagName === 'TEXTAREA') {
                return this.getInputCursorPosition();
            } else {
                return this.getContentEditableCursorPosition();
            }
        } catch (error) {
            console.error('Error getting cursor position:', error);
            return this.currentSelection.getBoundingClientRect();
        }
    },

    getInputCursorPosition() {
        const element = this.currentSelection;
        const rect = element.getBoundingClientRect();
        
        // For inputs, use element bounds
        return {
            top: rect.top,
            left: rect.left,
            bottom: rect.bottom,
            right: rect.right,
            height: rect.height,
            width: rect.width
        };
    },

    getContentEditableCursorPosition() {
        const selection = window.getSelection();
        if (!selection.rangeCount) {
            // Fallback to element rect
            return this.currentSelection.getBoundingClientRect();
        }

        const range = selection.getRangeAt(0);
        let rect = range.getBoundingClientRect();
        
        if (rect.width === 0 && rect.height === 0) {
            // Cursor at end of line, insert temporary element
            const tempSpan = document.createElement('span');
            tempSpan.innerHTML = '&#8203;'; // Zero-width space
            range.insertNode(tempSpan);
            rect = tempSpan.getBoundingClientRect();
            tempSpan.remove();
        }
        
        return rect;
    },

    isMobile() {
        const userAgent = navigator.userAgent || navigator.vendor || window.opera;
        const isMobileUserAgent = /android|iphone|ipad|ipod|blackberry|iemobile|opera mini/i.test(userAgent);
        const isMobileViewport = window.innerWidth <= 768;
        const hasTouchScreen = 'ontouchstart' in window || navigator.maxTouchPoints > 0;
        
        return isMobileUserAgent || (isMobileViewport && hasTouchScreen);
    }
};

// ===== UNIVERSAL CURSOR MANAGER =====
const UniversalCursorManager = {
    init() {
        console.log('Initializing Universal Cursor Manager');
        
        // Initialize both managers
        MobileCursorManager.init();
        DesktopCursorManager.init();
        
        // Listen for resize events to switch between managers
        window.addEventListener('resize', () => {
            this.handleResize();
        });
    },

    handleResize() {
        const isMobile = window.innerWidth <= 768;
        console.log('Resize detected, isMobile:', isMobile);
        
        if (isMobile) {
            // Switch to mobile tracking
            DesktopCursorManager.stopTrackingCursor();
            // Mobile manager will be reinitialized if needed
        } else {
            // Switch to desktop tracking
            MobileCursorManager.stopTrackingCursor();
            DesktopCursorManager.setupDesktopTracking();
        }
    },

    // Unified method để stop tất cả tracking
    stopAllTracking() {
        MobileCursorManager.stopTrackingCursor();
        DesktopCursorManager.stopTrackingCursor();
    }
};

// ===== ENHANCED EDITOR FOCUS MANAGER =====
const EditorFocusManager = {
    isHandlingFocus: false,
    
    init() {
        console.log('Setting up universal editor focus handling');
        this.setupEnhancedFocusHandling();
    },

    setupEnhancedFocusHandling() {
        const editor = document.getElementById('evernote-editor');
        const titleInput = document.getElementById('note-title');

        if (editor) {
            editor.addEventListener('focus', (e) => {
                console.log('Editor focus - scheduling visibility check');
                setTimeout(() => {
                    this.ensureEditorVisible(editor);
                }, 200);
            });
        }

        if (titleInput) {
            titleInput.addEventListener('focus', (e) => {
                console.log('Title focus - scheduling visibility check');
                setTimeout(() => {
                    this.ensureElementVisible(titleInput);
                }, 200);
            });
        }
    },

    ensureEditorVisible(editor) {
        console.log('ensureEditorVisible called, auto-scroll enabled:', AutoScrollSettings.isEnabled());
        
        if (AppState.isFocusLocked || this.isHandlingFocus) {
            console.log('Focus locked or already handling, skipping');
            return;
        }
        
        if (!AutoScrollSettings.isEnabled()) {
            console.log('❌ Auto-scroll DISABLED - Blocking editor visibility');
            return;
        }
        
        console.log('✅ Auto-scroll ENABLED - Ensuring editor visible');
        
        this.isHandlingFocus = true;
        
        try {
            const rect = editor.getBoundingClientRect();
            const viewportHeight = window.visualViewport ? 
                window.visualViewport.height : window.innerHeight;
            
            if (rect.top < 80 || rect.top > viewportHeight - 200) {
                const targetScroll = editor.offsetTop - (viewportHeight * 0.25);
                
                window.scrollTo({
                    top: Math.max(0, targetScroll),
                    behavior: 'smooth'
                });
            }
        } finally {
            setTimeout(() => {
                this.isHandlingFocus = false;
            }, 300);
        }
    },

    ensureElementVisible(element) {
        console.log('ensureElementVisible called, auto-scroll enabled:', AutoScrollSettings.isEnabled());
        
        if (!AutoScrollSettings.isEnabled()) {
            console.log('❌ Auto-scroll DISABLED - Blocking element visibility');
            return;
        }
        
        console.log('✅ Auto-scroll ENABLED - Ensuring element visible');
        
        const rect = element.getBoundingClientRect();
        const viewportHeight = window.visualViewport ? 
            window.visualViewport.height : window.innerHeight;
        
        if (rect.top < 50 || rect.bottom > viewportHeight - 100) {
            element.scrollIntoView({
                behavior: 'smooth',
                block: 'center',
                inline: 'nearest'
            });
        }
    },

    isMobile() {
        return window.innerWidth <= 768;
    }
};

document.getElementById('deleteFolderModal').addEventListener('hidden.bs.modal', function (event) {
    // Reset form when modal is closed
    const form = this.querySelector('form');
    if (form) {
        form.reset();
    }
    
    // Reset button state
    const deleteBtn = document.getElementById('confirm-delete-folder-btn');
    if (deleteBtn) {
        deleteBtn.disabled = false;
        // Trả lại text gốc của nút trong HTML
        deleteBtn.innerHTML = 'Delete';
    
        // Clear folder ID để chuẩn bị cho lần mở sau
        delete deleteBtn.dataset.folderId;
    }
    
    console.log('Delete folder modal cleaned up');
});

// Also prevent backdrop clicking when processing
document.getElementById('deleteFolderModal').addEventListener('show.bs.modal', function (event) {
    console.log('Delete folder modal shown');
});
// ===== DRAG AND DROP MANAGER =====
const DragDropManager = {
    draggedNote: null,
    dragFeedback: null,
    
    init() {
        console.log('Initializing drag and drop manager');
        this.setupEventListeners();
    },
    
    setupEventListeners() {
        // We'll set up drag listeners when notes are rendered
        document.addEventListener('dragover', this.handleDragOver.bind(this));
        document.addEventListener('drop', this.handleDrop.bind(this));
        document.addEventListener('dragend', this.handleDragEnd.bind(this));
    },
    
    makeNotesDraggable() {
        const noteItems = document.querySelectorAll('.note-item');
        noteItems.forEach(item => {
            item.draggable = true;
            
            // FIX: Add dragstart listener to the item, not just content
            item.addEventListener('dragstart', this.handleDragStart.bind(this));
            item.addEventListener('dragend', this.handleDragEnd.bind(this));
        });
        
        // Setup drop zones
        this.setupDropZones();
    },
    
    setupDropZones() {
        // Folder drop zones
        const folderItems = document.querySelectorAll('.folder-item-content');
        folderItems.forEach(item => {
            item.addEventListener('dragenter', this.handleDragEnter.bind(this));
            item.addEventListener('dragleave', this.handleDragLeave.bind(this));
            item.addEventListener('dragover', this.handleDragOver.bind(this));
            item.addEventListener('drop', this.handleDrop.bind(this));
        });
        
        // All notes drop zone
        const allNotesItem = document.querySelector('.all-notes-content');
        if (allNotesItem) {
            allNotesItem.addEventListener('dragenter', this.handleDragEnter.bind(this));
            allNotesItem.addEventListener('dragleave', this.handleDragLeave.bind(this));
            allNotesItem.addEventListener('dragover', this.handleDragOver.bind(this));
            allNotesItem.addEventListener('drop', this.handleDrop.bind(this));
        }
    },
    
    handleDragStart(e) {
        console.log('Drag start');
        const noteItem = e.target.closest('.note-item');
        if (!noteItem) return;
        
        const noteId = parseInt(noteItem.dataset.noteId);
        this.draggedNote = AppState.notes.find(n => n.id === noteId);
        
        if (!this.draggedNote) {
            e.preventDefault();
            return;
        }
        
        noteItem.classList.add('dragging');
        
        // Create drag feedback
        this.createDragFeedback(this.draggedNote.title);
        
        // Set drag data
        e.dataTransfer.setData('text/plain', noteId.toString());
        e.dataTransfer.effectAllowed = 'move';
        
        console.log('Dragging note:', this.draggedNote.title);
    },
    
    createDragFeedback(title) {
        this.dragFeedback = document.createElement('div');
        this.dragFeedback.className = 'drag-feedback';
        document.body.appendChild(this.dragFeedback);
        
        // Position feedback at cursor
        document.addEventListener('dragover', this.updateFeedbackPosition.bind(this));
    },
    
    updateFeedbackPosition(e) {
        if (this.dragFeedback) {
            this.dragFeedback.style.left = e.clientX + 'px';
            this.dragFeedback.style.top = e.clientY + 'px';
        }
    },
    
    handleDragEnter(e) {
        e.preventDefault();
        const dropZone = e.target.closest('.folder-item-content, .all-notes-content');
        if (dropZone && this.draggedNote) {
            dropZone.classList.add('drag-over');
        }
    },
    
    handleDragLeave(e) {
        const dropZone = e.target.closest('.folder-item-content, .all-notes-content');
        if (dropZone) {
            // Only remove highlight if actually leaving the drop zone
            const rect = dropZone.getBoundingClientRect();
            const x = e.clientX;
            const y = e.clientY;
            
            if (x < rect.left || x > rect.right || y < rect.top || y > rect.bottom) {
                dropZone.classList.remove('drag-over');
            }
        }
    },
    
    handleDragOver(e) {
        e.preventDefault();
        e.dataTransfer.dropEffect = 'move';
    },
    
    async handleDrop(e) {
        e.preventDefault();
        console.log('Drop event');
        
        const dropZone = e.target.closest('.folder-item-content, .all-notes-content');
        if (!dropZone || !this.draggedNote) {
            console.log('Invalid drop - no drop zone or dragged note');
            return;
        }
        
        dropZone.classList.remove('drag-over');
        
        // Determine target folder
        let targetFolderId = null;
        if (dropZone.classList.contains('folder-item-content')) {
            targetFolderId = parseInt(dropZone.dataset.folderId);
        }
        // If dropping on all-notes, targetFolderId stays null (root)
        
        console.log('Dropping note', this.draggedNote.id, 'into folder', targetFolderId);
        
        // Don't move if already in target folder
        if (this.draggedNote.folder_id === targetFolderId) {
            console.log('Note already in target folder');
            return;
        }
        
        try {
            await this.moveNote(this.draggedNote.id, targetFolderId);
            
            // Show success animation
            dropZone.classList.add('move-success');
            setTimeout(() => {
                dropZone.classList.remove('move-success');
            }, 500);
            
        } catch (error) {
            console.error('Error moving note:', error);
            alert('Failed to move note: ' + error.message);
        }
    },
    
    handleDragEnd(e) {
        console.log('Drag end');
        
        // Clean up
        const noteItem = e.target.closest('.note-item');
        if (noteItem) {
            noteItem.classList.remove('dragging');
        }
        
        // Remove all drag-over classes
        document.querySelectorAll('.drag-over').forEach(el => {
            el.classList.remove('drag-over');
        });
        
        // Remove drag feedback
        if (this.dragFeedback) {
            document.removeEventListener('dragover', this.updateFeedbackPosition.bind(this));
            this.dragFeedback.remove();
            this.dragFeedback = null;
        }
        
        this.draggedNote = null;
    },
    
    async moveNote(noteId, targetFolderId) {
        try {
            const response = await fetch(`/api/evernote_notes/${noteId}/move`, {
                method: 'PUT',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    folder_id: targetFolderId
                })
            });
            
            if (!response.ok) {
                throw new Error(`HTTP ${response.status}: ${response.statusText}`);
            }
            
            const data = await response.json();
            
            if (data.status === 'error') {
                throw new Error(data.message);
            }
            
            console.log('Note moved successfully:', data);
            
            // Update local state
            const note = AppState.notes.find(n => n.id === noteId);
            if (note) {
                note.folder_id = targetFolderId;
            }
            
            // Refresh UI
            await this.refreshAfterMove(data.old_folder_id, data.new_folder_id);
            
            return data;
            
        } catch (error) {
            console.error('Error in moveNote:', error);
            throw error;
        }
    },
    
    async refreshAfterMove(oldFolderId, newFolderId) {
        try {
            // Reload folder tree to update counts (folders already sorted)
            await FolderManager.loadFolders();
            
            // If currently viewing the source folder, reload notes (sorted)
            if (FolderManager.currentFolderId === oldFolderId) {
                await NoteManager.loadNotes(oldFolderId);
            }
            // If currently viewing all notes, reload all notes (sorted)
            else if (FolderManager.currentFolderId === null) {
                await NoteManager.loadNotes(null);
            }
            
            console.log('UI refreshed after move with sorted order');
            
        } catch (error) {
            console.error('Error refreshing UI after move:', error);
        }
    }
};

// ===== UPDATE FOLDER MANAGER =====
// Update folder tree rendering to setup drop zones
const OriginalRenderFolderTree = FolderManager.renderFolderTree;
FolderManager.renderFolderTree = function() {
    // Call original method
    OriginalRenderFolderTree.call(this);
    
    // Setup drag and drop
    DragDropManager.setupDropZones();
};
const SidebarManager = {
    isCollapsed: false,
    isMobileOpen: false,
    isAnimating: false,

    init() {
        this.setupMobileToggle();
        this.setupOverlay();
        this.setupClickOutside();
    },

    setupMobileToggle() {
        if (!document.querySelector('.mobile-toggle-container')) {
            const mobileToggle = document.createElement('div');
            mobileToggle.className = 'mobile-toggle-container';
            mobileToggle.innerHTML = `
                <button class="sidebar-toggle" id="mobile-toggle-btn">
                    <i class="bi bi-chevron-right"></i>
                </button>
            `;
            document.body.appendChild(mobileToggle);
        }

        const mobileToggleBtn = document.getElementById('mobile-toggle-btn');
        if (mobileToggleBtn) {
            mobileToggleBtn.onclick = (e) => {
                e.preventDefault();
                this.toggleMobileSidebar();
            };
        }
    },

    setupOverlay() {
        if (!document.querySelector('.sidebar-overlay')) {
            const overlay = document.createElement('div');
            overlay.className = 'sidebar-overlay';
            overlay.onclick = () => this.closeMobileSidebar();
            document.body.appendChild(overlay);
        }
    },

    setupClickOutside() {
        document.addEventListener('click', (e) => {
            // Chỉ xử lý trên mobile và khi sidebar đang mở
            if (window.innerWidth <= 768 && this.isMobileOpen) {
                const sidebar = document.getElementById('note-sidebar');
                const toggleBtn = document.getElementById('mobile-toggle-btn');
                
                // Kiểm tra xem click có nằm trong sidebar hoặc toggle button không
                if (sidebar && !sidebar.contains(e.target) && 
                    toggleBtn && !toggleBtn.contains(e.target)) {
                    this.closeMobileSidebar();
                }
            }
        });
    },

    toggleMobileSidebar() {
        if (this.isAnimating) return;
        
        if (this.isMobileOpen) {
            this.closeMobileSidebar();
        } else {
            this.openMobileSidebar();
        }
    },

    openMobileSidebar() {
        this.isAnimating = true;
        
        const sidebar = document.getElementById('note-sidebar');
        const overlay = document.querySelector('.sidebar-overlay');
        const toggleContainer = document.querySelector('.mobile-toggle-container');
        
        if (sidebar) sidebar.classList.add('mobile-open');
        if (overlay) overlay.classList.add('visible');
        if (toggleContainer) toggleContainer.classList.add('sidebar-open');
        
        this.isMobileOpen = true;
        document.body.style.overflow = 'hidden';
        
        setTimeout(() => { this.isAnimating = false; }, 400);
    },

    closeMobileSidebar() {
        if (!this.isMobileOpen) return; // Tránh call khi đã closed
        
        this.isAnimating = true;
        
        const sidebar = document.getElementById('note-sidebar');
        const overlay = document.querySelector('.sidebar-overlay');
        const toggleContainer = document.querySelector('.mobile-toggle-container');
        
        if (sidebar) sidebar.classList.remove('mobile-open');
        if (overlay) overlay.classList.remove('visible');
        if (toggleContainer) toggleContainer.classList.remove('sidebar-open');
        
        this.isMobileOpen = false;
        document.body.style.overflow = '';
        
        console.log('Mobile sidebar closed');
        
        setTimeout(() => { 
            this.isAnimating = false; 
        }, 400);
    },

    // Thêm method để check mobile state
    isMobile() {
        return window.innerWidth <= 768;
    },

    toggleDesktopSidebar() {
    if (this.isAnimating || window.innerWidth <= 768) return;
    
    this.isAnimating = true;
    
    const sidebar = document.getElementById('note-sidebar');
    const layout = document.querySelector('.note-layout');

    if (this.isCollapsed) {
        // Expanding
        sidebar.classList.add('expanding');
        sidebar.classList.remove('collapsed');
        layout.classList.remove('sidebar-collapsed');
        
        // Remove expanding class sau khi transition xong
        setTimeout(() => {
            sidebar.classList.remove('expanding');
        }, 800);
    } else {
        // Collapsing  
        sidebar.classList.add('collapsing');
        sidebar.classList.add('collapsed');
        layout.classList.add('sidebar-collapsed');
        
        // Remove collapsing class sau khi transition xong
        setTimeout(() => {
            sidebar.classList.remove('collapsing');
        }, 800);
    }

    this.isCollapsed = !this.isCollapsed;
    localStorage.setItem('sidebarCollapsed', this.isCollapsed.toString());
    
    setTimeout(() => { 
        this.isAnimating = false; 
    }, 1000);
},

    setMobileDefault() {
        // Đặt mặc định sidebar collapsed trên mobile khi load page
        if (window.innerWidth <= 768) {
            const sidebar = document.getElementById('note-sidebar');
            const layout = document.querySelector('.note-layout');
            
            if (sidebar && layout) {
                sidebar.classList.add('collapsed');
                layout.classList.add('sidebar-collapsed');
                this.isCollapsed = true;
            }
        }
    },

    restoreState() {
        // Kiểm tra nếu là mobile thì set collapsed mặc định
        if (window.innerWidth <= 768) {
            // Trên mobile: KHÔNG set collapsed, để sidebar header hiển thị bình thường
            const sidebar = document.getElementById('note-sidebar');
            const layout = document.querySelector('.note-layout');
            
            if (sidebar && layout) {
                // Bỏ collapsed state để sidebar header hiển thị
                sidebar.classList.remove('collapsed');
                layout.classList.remove('sidebar-collapsed');
                this.isCollapsed = false;
            }
        } else {
            // Desktop: restore từ localStorage
            const savedState = localStorage.getItem('sidebarCollapsed');
            if (savedState === 'true') {
                setTimeout(() => {
                    this.toggleDesktopSidebar();
                }, 100);
            }
        }
    },

    handleResize() {
        const isMobile = window.innerWidth <= 768;
    
        if (isMobile) {
            // Khi chuyển sang mobile: đảm bảo sidebar header hiển thị
            const sidebar = document.getElementById('note-sidebar');
            const layout = document.querySelector('.note-layout');
            
            if (sidebar && layout) {
                sidebar.classList.remove('collapsed');
                layout.classList.remove('sidebar-collapsed');
                this.isCollapsed = false;
            }
            
            // Close mobile sidebar if open
            if (this.isMobileOpen) {
                this.closeMobileSidebar();
            }
        } else {
            // Desktop logic giữ nguyên
            const savedState = localStorage.getItem('sidebarCollapsed');
            if (savedState !== 'true' && this.isCollapsed) {
                const sidebar = document.getElementById('note-sidebar');
                const layout = document.querySelector('.note-layout');
                
                if (sidebar && layout) {
                    sidebar.classList.remove('collapsed');
                    layout.classList.remove('sidebar-collapsed');
                    this.isCollapsed = false;
                }
            }
            
            const overlay = document.querySelector('.sidebar-overlay');
            if (overlay) overlay.classList.remove('visible');
            
            this.isMobileOpen = false;
            document.body.style.overflow = '';
        }
    }
};






// Initialize focus handling flag
EditorFocusManager.isHandlingFocus = false;

// Expose managers globally
window.ImageManager = ImageManager;
window.AutoScrollSettings = AutoScrollSettings;
</script>
{% endblock %}