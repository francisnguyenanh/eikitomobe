{% extends "Memo/base.html" %}
{% block title %}Tomo Tasks{% endblock %}
{% block content %}
 <style>
/* === LAYOUT & POSITIONING === */
form#searchForm {
    position: sticky;
    top: 0;
    z-index: 100;
    background: var(--bg-color);
    padding: 0.5rem 0.75rem;
    border-radius: 6px;
    margin-bottom: 0.5rem;
    box-shadow: 0 1px 3px rgba(0, 0, 0, 0.08);
}

footer {
    position: fixed;
    right: 0;
    bottom: 0;
    z-index: 999;
    width: auto;
    min-width: 180px;
    background: rgba(255,255,255,0.8);
    font-size: 0.95em;
}

/* === BASIC COMPONENTS === */
.card, .modal-content, .table {
    background-color: var(--bg-color);
    color: var(--text-color);
}

.btn-primary {
    background-color: var(--primary-color);
    border-color: var(--primary-color);
}

/* === TASK TABLE (5 COLUMNS LAYOUT) === */
.task-table {
    table-layout: fixed;
    width: 100%;
    min-width: 500px;
    background-color: transparent !important;
    border: none;
    border-radius: 8px;
    overflow: hidden;
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.06);
    margin-bottom: 0.75rem;
}

.task-table thead {
    background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
    position: sticky;
    top: 0;
    z-index: 10;
    display: none; /* Ẩn header */
}

.task-table thead th {
    font-weight: 600;
    font-size: 0.7rem;
    color: #495057;
    text-transform: uppercase;
    letter-spacing: 0.3px;
    padding: 6px 6px;
    border: none;
    background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%) !important;
    position: relative;
}

.task-table thead th::after {
    content: '';
    position: absolute;
    bottom: 0;
    left: 0;
    right: 0;
    height: 2px;
    background: linear-gradient(90deg, #0d6efd 0%, #20c997 50%, #fd7e14 100%);
}

.task-table tbody tr {
    background: rgba(255, 255, 255, 0.95);
    border: none;
    transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    position: relative;
    outline: 4px solid transparent;
    outline-offset: -4px;
}

.task-table tbody tr::before {
    display: none;
}

.task-table tbody tr:hover {
    background: rgba(13, 110, 253, 0.04);
    transform: translateY(-2px);
    box-shadow: 0 8px 25px rgba(0, 0, 0, 0.1);
    z-index: 5;
}

.task-table tbody tr:hover::before {
    background: linear-gradient(180deg, #0d6efd 0%, #20c997 100%);
}

.task-table tbody tr:nth-child(even) {
    background: rgba(248, 249, 250, 0.5);
}

.task-table tbody tr:nth-child(even):hover {
    background: rgba(13, 110, 253, 0.04);
}

.task-table th, .task-table td {
    vertical-align: middle !important;
    padding: 4px 6px;
    border: none !important;
    background: transparent !important;
    position: relative;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
}

/* 5-Column Layout: Checkbox | Title | Content | Due Date | Actions */
.task-table th:nth-child(1), .task-table td:nth-child(1) { 
    width: 14px; 
    min-width: 14px; 
    max-width: 18px; 
    text-align: center;
    padding: 1px !important;
}
.task-table th:nth-child(2), .task-table td:nth-child(2) { 
    width: 20%; 
    min-width: 120px; 
    max-width: 200px; 
}
.task-table th:nth-child(3), .task-table td:nth-child(3) { 
    width: 52%; 
    min-width: 200px; 
    max-width: none; 
}
.task-table th:nth-child(4), .task-table td:nth-child(4) { 
    width: 12%; 
    min-width: 75px; 
    max-width: 100px; 
}
.task-table th:nth-child(5), .task-table td:nth-child(5) { 
    width: 8%; 
    min-width: 85px; 
    max-width: 100px;
    text-align: center;
}

/* Task content styling */
.task-table .task-title {
    font-weight: 600;
    font-size: 0.9rem;
    color: #2c3e50;
    line-height: 1.3;
    cursor: pointer;
    transition: color 0.2s ease;
}

.task-table .task-title:hover {
    color: #0d6efd;
}

/* Completed task title styling */
.task-table tbody tr.completed .task-title {
    color: #28a745 !important;
    text-decoration: line-through;
    opacity: 0.8;
}

.task-table .task-content {
    color: #6c757d;
    font-size: 0.85em;
    line-height: 1.3;
    cursor: pointer;
    transition: color 0.2s ease;
}

.task-table .task-content:hover {
    color: #495057;
}

/* Task Checkbox Styling */
.task-checkbox {
    width: 14px;
    height: 14px;
    cursor: pointer;
    accent-color: #28a745;
    transform: scale(1);
    transition: transform 0.2s ease;
    margin: 0;
}

.task-checkbox:hover {
    transform: scale(1.15);
}

.task-checkbox:checked {
    accent-color: #28a745;
}

/* Due Date Cell Styling */
.due-date-cell {
    position: relative;
    transition: all 0.2s ease;
}

.due-date-cell:hover {
    background-color: rgba(13, 110, 253, 0.1) !important;
    transform: scale(1.02);
}

.due-date-cell:active {
    transform: scale(0.98);
}

.task-table .task-due {
    font-size: 0.7rem;
    font-weight: 500;
    color: #fd7e14;
    background: rgba(253, 126, 20, 0.1);
    padding: 3px 6px;
    border-radius: 12px;
    display: inline-flex;
    align-items: center;
    justify-content: center;
    min-width: 55px;
    text-align: center;
    cursor: pointer;
    transition: all 0.3s ease;
    border: 1px solid rgba(253, 126, 20, 0.2);
    user-select: none;
}

.task-table .task-due:hover {
    background: rgba(253, 126, 20, 0.2);
    transform: scale(1.05);
    box-shadow: 0 2px 8px rgba(253, 126, 20, 0.3);
}

/* Completed task styling */
.task-table .task-due.completed {
    background: rgba(40, 167, 69, 0.15);
    color: #28a745;
    border-color: rgba(40, 167, 69, 0.3);
    font-weight: 600;
}

.task-table .task-due.completed:hover {
    background: rgba(40, 167, 69, 0.25);
    box-shadow: 0 2px 8px rgba(40, 167, 69, 0.3);
}

.task-table .task-due.completed i {
    color: #28a745;
    font-size: 1rem;
}

.task-table tbody tr.completed {
    opacity: 0.85;
    background: rgba(40, 167, 69, 0.03);
}

.task-table tbody tr.completed .task-content {
    text-decoration: line-through;
    color: #9e9e9e;
}

/* Function buttons styling */
.task-table .function-buttons {
    display: flex;
    gap: 4px;
    align-items: center;
    justify-content: center;
}

.task-table .function-buttons .btn {
    width: 28px;
    height: 28px;
    border-radius: 6px;
    display: flex;
    align-items: center;
    justify-content: center;
    padding: 0;
    font-size: 0.85rem;
    transition: all 0.2s ease;
    border: none;
    background: rgba(108, 117, 125, 0.1);
    color: #6c757d;
}

.task-table .function-buttons .btn:hover {
    transform: translateY(-2px);
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
}

.task-table .function-buttons .btn:nth-child(1) {
    background: rgba(32, 201, 151, 0.1);
    color: #20c997;
}

.task-table .function-buttons .btn:nth-child(1):hover {
    background: #20c997;
    color: white;
}

.task-table .function-buttons .btn:nth-child(2) {
    background: rgba(253, 126, 20, 0.1);
    color: #fd7e14;
}

.task-table .function-buttons .btn:nth-child(2):hover {
    background: #fd7e14;
    color: white;
}

.task-table .delete-btn {
    color: #dc3545;
    cursor: pointer;
    font-size: 0.85em;
    transition: all 0.2s ease;
    width: 28px;
    height: 28px;
    border-radius: 6px;
    display: flex;
    align-items: center;
    justify-content: center;
    background: rgba(220, 53, 69, 0.1);
}

.task-table .delete-btn:hover {
    background: #dc3545;
    color: white;
    transform: translateY(-2px) scale(1.1);
    box-shadow: 0 4px 12px rgba(220, 53, 69, 0.3);
}

/* Table wrapper */
.category-table-wrapper {
    overflow-x: auto;
    border-radius: 8px;
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.06);
    background: white;
    margin-bottom: 0.5rem;
}

.category-table-wrapper.collapsed {
    display: none;
}

/* === CATEGORY COMPONENTS === */
.task-category {
    font-weight: bold;
    font-size: 0.95rem;
    margin: 0.25rem 0;
    color: #0d6efd;
    letter-spacing: 0.3px;
}

.toggle-category {
    background: linear-gradient(135deg, var(--primary-color, #0d6efd) 0%, rgba(13, 110, 253, 0.8) 100%) !important;
    border: none !important;
    border-radius: 8px !important;
    padding: 6px 12px !important;
    font-weight: 600 !important;
    font-size: 0.85rem !important;
    color: white !important;
    text-decoration: none !important;
    transition: all 0.2s ease !important;
    box-shadow: 0 2px 6px rgba(13, 110, 253, 0.12) !important;
    position: relative !important;
    overflow: hidden !important;
    min-height: 32px !important;
    display: inline-flex !important;
    align-items: center !important;
    justify-content: flex-start !important;
    gap: 6px !important;
    min-width: 100px !important;
    text-align: left !important;
}

.toggle-category:hover {
    transform: translateY(-2px) !important;
    box-shadow: 0 8px 20px rgba(13, 110, 253, 0.25) !important;
    background: linear-gradient(135deg, rgba(13, 110, 253, 0.9) 0%, var(--primary-color, #0d6efd) 100%) !important;
    color: white !important;
}

.toggle-category:active {
    transform: translateY(0) !important;
    box-shadow: 0 4px 12px rgba(13, 110, 253, 0.2) !important;
}

.toggle-category::before {
    content: '';
    position: absolute;
    top: 50%;
    left: 50%;
    width: 0;
    height: 0;
    border-radius: 50%;
    background: rgba(255, 255, 255, 0.3);
    transform: translate(-50%, -50%);
    transition: width 0.6s, height 0.6s;
}

.toggle-category:active::before {
    width: 300px;
    height: 300px;
}

.toggle-category i {
    font-size: 0.9rem !important;
    transition: transform 0.3s ease !important;
    width: 16px !important;
    height: 16px !important;
    display: flex !important;
    align-items: center !important;
    justify-content: center !important;
}

.toggle-category .category-name {
    flex: 1;
    white-space: normal;
    word-wrap: break-word;
    overflow-wrap: break-word;
    font-weight: 600;
    line-height: 1.4;
}

.task-count {
    font-size: 1.0rem;
    font-weight: 500;
    color: #f0051c;
    margin-left: 10px;
    padding: 2px 8px;
    background: rgba(108, 117, 125, 0.08);
    border-radius: 12px;
    border: 1px solid rgba(108, 117, 125, 0.12);
    backdrop-filter: blur(4px);
    transition: all 0.2s ease;
}

.task-count.has-completed {
    background: rgba(40, 167, 69, 0.08);
    border-color: rgba(40, 167, 69, 0.15);
    color: #28a745;
    font-weight: 600;
}

.category-label {
    min-width: 120px;
    max-width: 100%;
    height: 38px;
    padding: 0 16px;
    font-size: 1rem;
    text-align: center;
    white-space: nowrap;
    box-sizing: border-box;
    display: inline-flex;
    align-items: center;
    justify-content: center;
    border-radius: 0.5rem;
}

.category-card {
    background-color: var(--card-bg);
    border: none;
    border-radius: 10px;
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15), 0 2px 6px rgba(0, 0, 0, 0.1);
    position: relative;
    padding: 20px;
    overflow: hidden;
    transition: transform 0.3s ease, box-shadow 0.3s ease;
    animation: slideIn 0.5s ease forwards;
}

/* === MODAL COMPONENTS === */
/* Category Color Picker Styling */
.form-control-color {
    width: 100% !important;
    height: 50px !important;
    padding: 5px !important;
    border: 2px solid #dee2e6 !important;
    border-radius: 8px !important;
    cursor: pointer !important;
    transition: all 0.3s ease !important;
}

.form-control-color:hover {
    border-color: #0d6efd !important;
    box-shadow: 0 0 0 0.2rem rgba(13, 110, 253, 0.25) !important;
}

.form-control-color:focus {
    border-color: #0d6efd !important;
    box-shadow: 0 0 0 0.25rem rgba(13, 110, 253, 0.5) !important;
    outline: none !important;
}

#addCategoryForm .row.align-items-end {
    align-items: center !important;
}

#addCategoryForm .col {
    flex: 1;
    min-width: 0;
}

#addCategoryForm .col-auto {
    flex: 0 0 auto;
    padding-left: 10px;
}

/* Category Card Styling in Modal */
.category-card-item {
    transition: all 0.2s ease;
    border-radius: 8px !important;
}

.category-card-item:hover {
    transform: translateY(-2px);
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
}

.category-actions .btn {
    padding: 0.25rem 0.5rem;
    font-size: 0.8rem;
}

.category-actions .btn:hover {
    transform: scale(1.1);
}

#manageCategoriesModal .modal-dialog {
    max-width: 800px;
    height: 90vh;
    margin: 5vh auto;
}

#manageCategoriesModal .modal-content {
    height: 100%;
    display: flex;
    flex-direction: column;
}

/* Add Memo Modal - 95% height, 90% width */
#addMemoModal .modal-dialog {
    width: 90vw;
    max-width: 90vw;
    height: 95vh;
    max-height: 95vh;
    margin: 2.5vh auto;
}

#addMemoModal .modal-content {
    height: 95vh;
    max-height: 95vh;
    display: flex;
    flex-direction: column;
}

#addMemoModal .modal-body {
    flex: 1 1 auto;
    overflow: hidden;
    padding: 1rem;
    display: flex;
    flex-direction: column;
}

#addMemoModal form {
    display: flex;
    flex-direction: column;
    height: 100%;
}

#addMemoModal .row {
    flex: 1 1 auto;
    overflow: hidden;
}

/* Edit Memo Modal - same size as Add Modal */
#editMemoModal .modal-dialog {
    width: 90vw;
    max-width: 90vw;
    height: 95vh;
    max-height: 95vh;
    margin: 2.5vh auto;
}

#editMemoModal .modal-content {
    height: 95vh;
    max-height: 95vh;
    display: flex;
    flex-direction: column;
}

#editMemoModal .modal-body {
    flex: 1 1 auto;
    overflow: hidden;
    padding: 1rem;
    display: flex;
    flex-direction: column;
}

#editMemoModal form {
    display: flex;
    flex-direction: column;
    height: 100%;
}

#editMemoModal .row {
    flex: 1 1 auto;
    overflow: hidden;
}

/* View Memo Modal - same size as Add/Edit Modal */
#viewMemoModal .modal-dialog {
    width: 90vw;
    max-width: 90vw;
    height: 95vh;
    max-height: 95vh;
    margin: 2.5vh auto;
}

#viewMemoModal .modal-content {
    height: 95vh;
    max-height: 95vh;
    display: flex;
    flex-direction: column;
}

#viewMemoModal .modal-body {
    flex: 1 1 auto;
    overflow: hidden;
    padding: 1rem;
    display: flex;
    flex-direction: column;
}

#viewMemoModal .row {
    flex: 1 1 auto;
    overflow: hidden;
}

#manageCategoriesModal .modal-body {
    flex: 1;
    overflow-y: auto;
    padding: 1.5rem;
}

#manageCategoriesModal #addCategoryForm {
    background: #f8f9fa;
    padding: 1rem;
    border-radius: 8px;
    border: 1px solid #dee2e6;
    margin-bottom: 1.5rem;
}

#manageCategoriesModal #categoriesContainer {
    flex: 1;
    overflow-y: auto;
}

#viewMemoModal .modal-body,
#viewMemoModal #viewMemoTitle,
#viewMemoModal #viewMemoContent {
    font-family: 'Noto Sans JP', 'Noto Sans', 'Segoe UI', Arial, 'Hiragino Kaku Gothic Pro', 'Meiryo', 'MS PGothic', 'Tahoma', 'Geneva', sans-serif !important;
    font-size: 1.1rem;
    letter-spacing: 0.01em;
}

#viewMemoModal #viewMemoTitle {
    font-family: 'Kosugi Maru', sans-serif;
    font-size: 1.5rem;
}

#viewMemoModal #viewMemoContent {
    background-color: var(--bg-color);
    padding: 18px;
    border-radius: 5px;
    min-height: 200px;
    max-height: 400px;
    overflow-y: auto;
    white-space: pre-wrap;
    word-wrap: break-word;
    border: 1px solid #ddd;
    transition: background-color 0.2s ease;
}

/* === MODAL INPUT STYLING === */
#addMemoModal #memoTitle,
#addMemoModal #memoContent,
#editMemoModal #editMemoTitle,
#editMemoModal #editMemoContent {
    border: 2px solid #ced4da !important;
    border-radius: 8px !important;
    transition: all 0.3s ease;
}

#addMemoModal #memoTitle:focus,
#addMemoModal #memoContent:focus,
#editMemoModal #editMemoTitle:focus,
#editMemoModal #editMemoContent:focus {
    border-color: #0d6efd !important;
    box-shadow: 0 0 0 0.25rem rgba(13, 110, 253, 0.25) !important;
    outline: none;
}

/* === CALENDAR MODAL === */
#calendarModal .modal-dialog {
    width: 95vw;
    max-width: 95vw;
    height: 90vh;
    max-height: 90vh;
    margin: 5vh auto;
}

#calendarModal .modal-content {
    height: 90vh;
    max-height: 90vh;
    display: flex;
    flex-direction: column;
}

#calendarModal .modal-body {
    flex: 1 1 auto;
    overflow: hidden;
    padding: 0.5rem;
}

#calendar {
    height: calc(90vh - 60px);
    min-height: 400px;
}

/* === IMAGE COMPONENTS === */
#imagePreview img, 
#editImagePreview img, 
#viewMemoImages img {
    border: 1px solid #ddd;
    border-radius: 5px;
    padding: 5px;
    margin-right: 10px;
    margin-bottom: 10px;
}

.position-relative {
    display: inline-block;
}

.position-relative .btn-danger {
    padding: 2px 6px;
    font-size: 12px;
}

/* === INTERACTIVE STATES === */
.reminder-item.clicked {
    background-color: var(--primary-color) !important;
    color: #ffffff;
}

.reminder-item.clicked:hover {
    background-color: #28a745 !important;
    color: #ffffff;
}

.reminder-item:hover {
    background-color: #ffca2c;
}

.link-input[readonly] {
    background-color: #f3f3f3 !important;
    color: #555;
    cursor: pointer;
    transition: background 0.2s;
}

.link-input:not([readonly]) {
    background-color: #fffbe6 !important;
    color: #212529;
    transition: background 0.2s;
}

.link-input:focus {
    background-color: #fffde7 !important;
    border-color: #ffe066;
    outline: none;
}

/* === MOBILE RESPONSIVE === */
@media (max-width: 768px) {
    /* Search form adjustments */
    form#searchForm {
        padding: 0.75rem;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
    }

    form#searchForm .row.g-2 {
        gap: 0.5rem;
    }

    form#searchForm .col-12.col-md {
        order: 0;
        margin-bottom: 0.5rem;
    }

    form#searchForm .btn {
        padding: 0.375rem 0.5rem;
        font-size: 0.875rem;
    }

    form#searchForm .form-check-label {
        font-size: 0.875rem;
    }

    .container {
        padding-top: 0;
    }

    /* Task table mobile adjustments - 5 columns */
    .task-table {
        min-width: 450px;
        font-size: 0.85rem;
    }

    .task-table th, .task-table td {
        padding: 6px 4px;
    }

    /* Mobile column widths for 5-column layout */
    .task-table th:nth-child(1), .task-table td:nth-child(1) { 
        width: 12px; 
        min-width: 12px; 
        max-width: 16px;
        padding: 1px !important;
    }
    .task-table th:nth-child(2), .task-table td:nth-child(2) { 
        width: 20%; 
        min-width: 80px; 
        max-width: 110px; 
    }
    .task-table th:nth-child(3), .task-table td:nth-child(3) { 
        width: 42%; 
        min-width: 120px; 
        max-width: none; 
    }
    .task-table th:nth-child(4), .task-table td:nth-child(4) { 
        width: 14%; 
        min-width: 55px; 
        max-width: 70px; 
    }
    .task-table th:nth-child(5), .task-table td:nth-child(5) { 
        width: 16%; 
        min-width: 70px; 
        max-width: 85px; 
    }

    .task-checkbox {
        transform: scale(1);
    }

    .task-table .function-buttons {
        flex-direction: row;
        gap: 2px;
    }

    .task-table .function-buttons .btn {
        width: 24px;
        height: 24px;
        font-size: 0.75rem;
    }

    .task-table .delete-btn {
        width: 24px;
        height: 24px;
        font-size: 0.75rem;
    }

    .task-table .task-due {
        font-size: 0.7rem;
        padding: 4px 6px;
        min-width: 60px;
    }

    /* Category toggle mobile adjustments */
    .toggle-category {
        padding: 10px 16px !important;
        font-size: 0.9rem !important;
        min-width: 120px !important;
        min-height: 40px !important;
    }
    
    .toggle-category i {
        font-size: 0.8rem !important;
    }

    /* Modal mobile improvements */
    #viewMemoModal #viewMemoContent {
        cursor: pointer;
        position: relative;
        user-select: none;
        -webkit-user-select: none;
        -webkit-touch-callout: none;
    }
    
    #viewMemoModal #viewMemoContent:hover {
        background-color: #f8f9fa;
    }
    
    #viewMemoModal #viewMemoContent:active {
        background-color: #e9ecef;
    }
    
    #viewMemoModal .btn {
        min-height: 44px;
        padding: 12px 20px;
        font-size: 1rem;
    }
    
    #viewMemoModal .modal-body {
        padding: 1.5rem;
    }
    
    #viewMemoModal .nav-tabs .nav-link {
        min-height: 44px;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 1rem;
    }
    
    #viewMemoModal .tab-content {
        margin-top: 1rem;
    }
    
    #viewMemoModal #viewMemoTitle {
        font-size: 1.3rem;
        margin-bottom: 1rem;
    }
    
    #viewMemoModal p {
        font-size: 1rem;
        line-height: 1.5;
        margin-bottom: 0.75rem;
    }

    /* Calendar mobile adjustments */
    #calendarModal .modal-dialog {
        width: 100vw;
        max-width: 100vw;
        height: 100vh;
        max-height: 100vh;
        margin: 0;
        border-radius: 0;
    }

    #calendarModal .modal-content {
        height: 100vh;
        max-height: 100vh;
        border-radius: 0;
        border: none;
        position: relative;
    }

    #calendarModal .modal-body {
        padding: 0.25rem;
        overflow: hidden;
        padding-top: 50px;
    }

    #calendar {
        height: calc(100vh - 60px);
        min-height: calc(100vh - 60px);
    }

    #calendarModal .btn-close {
        position: fixed;
        top: 15px;
        right: 15px;
        z-index: 1070;
        background: rgba(0,0,0,0.8);
        border-radius: 50%;
        width: 40px;
        height: 40px;
        display: flex;
        align-items: center;
        justify-content: center;
        border: 2px solid rgba(255,255,255,0.3);
        transition: all 0.3s ease;
        box-shadow: 0 2px 10px rgba(0,0,0,0.3);
    }

    #calendarModal .btn-close:hover,
    #calendarModal .btn-close:focus {
        background: rgba(0,0,0,0.9);
        border-color: rgba(255,255,255,0.5);
        transform: scale(1.1);
    }

    #calendarModal .btn-close::before {
        content: '×';
        color: white;
        font-size: 24px;
        font-weight: bold;
        line-height: 1;
    }

    /* FullCalendar mobile optimizations */
    .fc .fc-toolbar {
        flex-direction: column;
        gap: 0.5rem;
    }

    .fc .fc-toolbar-chunk {
        display: flex;
        justify-content: center;
        flex-wrap: wrap;
        gap: 0.25rem;
    }

    .fc .fc-button-group {
        margin: 0 0.25rem;
    }

    .fc .fc-button {
        font-size: 0.8rem;
        padding: 0.25rem 0.5rem;
    }

    .fc .fc-toolbar-title {
        font-size: 1.1rem;
        margin: 0.25rem 0;
    }

    .fc .fc-daygrid-day {
        min-height: 60px;
    }

    .fc .fc-daygrid-day-number {
        font-size: 0.9rem;
        padding: 0.25rem;
    }

    .fc .fc-event {
        font-size: 0.75rem;
        margin: 1px 0;
        padding: 1px 3px;
    }

    .fc .fc-event-title {
        font-weight: normal;
    }

    .fc .fc-timegrid-slot {
        height: 2em;
    }

    .fc .fc-timegrid-slot-label {
        font-size: 0.8rem;
    }

    .fc .fc-list-event {
        font-size: 0.9rem;
    }

    .fc .fc-list-event-time {
        font-size: 0.8rem;
    }
}

/* === TABLET RESPONSIVE === */
@media (min-width: 769px) and (max-width: 1024px) {
    #calendarModal .modal-dialog {
        width: 90vw;
        max-width: 90vw;
        height: 85vh;
        max-height: 85vh;
    }

    #calendarModal .modal-content {
        height: 85vh;
        max-height: 85vh;
    }

    #calendar {
        height: calc(85vh - 50px);
    }

    .fc .fc-button {
        font-size: 0.9rem;
        padding: 0.375rem 0.75rem;
    }

    .fc .fc-toolbar-title {
        font-size: 1.25rem;
    }
}

/* === DARK MODE SUPPORT === */
[data-bs-theme="dark"] .task-table thead {
    background: linear-gradient(135deg, #343a40 0%, #495057 100%);
}

[data-bs-theme="dark"] .task-table thead th {
    color: #f8f9fa;
    background: linear-gradient(135deg, #343a40 0%, #495057 100%) !important;
}

[data-bs-theme="dark"] .task-table tbody tr {
    background: rgba(52, 58, 64, 0.8);
}

[data-bs-theme="dark"] .task-table tbody tr:hover {
    background: rgba(13, 110, 253, 0.1);
}

[data-bs-theme="dark"] .task-table .task-title {
    color: #f8f9fa;
}

[data-bs-theme="dark"] .task-table .task-content {
    color: #adb5bd;
}

[data-bs-theme="dark"] .category-table-wrapper {
    background: #212529;
}

[data-bs-theme="dark"] .toggle-category {
    background: linear-gradient(135deg, #6c757d 0%, rgba(108, 117, 125, 0.8) 100%) !important;
    box-shadow: 0 4px 12px rgba(108, 117, 125, 0.15) !important;
}

[data-bs-theme="dark"] .toggle-category:hover {
    background: linear-gradient(135deg, rgba(108, 117, 125, 0.9) 0%, #6c757d 100%) !important;
    box-shadow: 0 8px 20px rgba(108, 117, 125, 0.25) !important;
}

/* === CSS GRID ALTERNATIVE (Optional) === */
.task-grid {
    display: grid;
    grid-template-columns: 1fr 1fr 200px 150px; /* 4 columns: Title | Content | Due Date | Actions */
    gap: 0;
    border-radius: 12px;
    overflow: hidden;
    box-shadow: 0 4px 20px rgba(0, 0, 0, 0.08);
}

.grid-header, .grid-row {
    display: contents;
}

.grid-header > div {
    background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
    padding: 18px 16px;
    font-weight: 600;
    position: sticky;
    top: 0;
    z-index: 10;
}

.grid-row > div {
    padding: 16px;
    border-bottom: 1px solid #f0f0f0;
    background: rgba(255, 255, 255, 0.95);
}

@media (max-width: 768px) {
    .task-grid {
        grid-template-columns: 1fr 1fr 120px 100px;
        min-width: 480px;
    }
}

.image-preview-item {
    transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
}

.image-preview-item:hover {
    transform: scale(1.05);
    box-shadow: 0 4px 12px rgba(13, 110, 253, 0.15);
}

/* Drag over effects */
.modal-body.drag-over {
    background-color: rgba(13, 110, 253, 0.05);
    border: 2px dashed #007bff;
    border-radius: 8px;
}

/* Better image preview styling */
#imagePreview, #editImagePreview {
    min-height: 60px;
    border-radius: 8px;
    transition: all 0.3s ease;
}

#imagePreview:empty, #editImagePreview:empty {
    background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
    border: 2px dashed #dee2e6;
}

/* Image drop placeholder styling */
.image-drop-placeholder {
    transition: all 0.3s ease;
}

.image-drop-placeholder:hover {
    background: #e9ecef !important;
    border-color: #0d6efd !important;
}

/* Image preview item improvements */
.image-preview-item {
    position: relative;
    transition: all 0.3s ease;
}

.image-preview-item img {
    transition: opacity 0.3s ease;
}

.image-preview-item:hover img {
    opacity: 0.9;
}

/* Loading overlay for image upload */
.image-upload-loading {
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: rgba(255, 255, 255, 0.8);
    display: flex;
    align-items: center;
    justify-content: center;
    border-radius: 8px;
    z-index: 10;
}

.image-upload-loading .spinner-border {
    width: 2rem;
    height: 2rem;
}

/* Mobile responsive cho image previews */
@media (max-width: 768px) {
    .image-preview-item {
        width: calc(50% - 10px);
    }
    
    .image-preview-item .img-container {
        width: 100px;
        height: 100px;
    }
}

/* Toast Notifications - Fixed position, no layout shift */
.toast-container {
    position: fixed;
    top: 20px;
    right: 20px;
    z-index: 9999;
    width: 350px;
    max-width: calc(100vw - 40px);
    pointer-events: none;
}

.toast-notification {
    pointer-events: auto;
    margin-bottom: 10px;
    padding: 16px 20px;
    border-radius: 8px;
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15), 0 0 0 1px rgba(0, 0, 0, 0.05);
    display: flex;
    align-items: center;
    justify-content: space-between;
    animation: slideInRight 0.3s ease-out;
    background: white;
    border-left: 4px solid;
    min-height: 60px;
}

.toast-notification.success {
    border-left-color: #198754;
    background: linear-gradient(to right, rgba(25, 135, 84, 0.05) 0%, white 10%);
}

.toast-notification.danger,
.toast-notification.error {
    border-left-color: #dc3545;
    background: linear-gradient(to right, rgba(220, 53, 69, 0.05) 0%, white 10%);
}

.toast-notification.warning {
    border-left-color: #ffc107;
    background: linear-gradient(to right, rgba(255, 193, 7, 0.05) 0%, white 10%);
}

.toast-notification.info {
    border-left-color: #0dcaf0;
    background: linear-gradient(to right, rgba(13, 202, 240, 0.05) 0%, white 10%);
}

.toast-notification .toast-content {
    flex: 1;
    display: flex;
    align-items: center;
    gap: 12px;
}

.toast-notification .toast-icon {
    font-size: 24px;
    flex-shrink: 0;
}

.toast-notification.success .toast-icon {
    color: #198754;
}

.toast-notification.danger .toast-icon,
.toast-notification.error .toast-icon {
    color: #dc3545;
}

.toast-notification.warning .toast-icon {
    color: #ffc107;
}

.toast-notification.info .toast-icon {
    color: #0dcaf0;
}

.toast-notification .toast-message {
    font-size: 14px;
    font-weight: 500;
    color: #212529;
    line-height: 1.5;
}

.toast-notification .toast-close {
    background: none;
    border: none;
    color: #6c757d;
    font-size: 20px;
    cursor: pointer;
    padding: 0;
    width: 24px;
    height: 24px;
    display: flex;
    align-items: center;
    justify-content: center;
    border-radius: 4px;
    transition: all 0.2s ease;
    flex-shrink: 0;
}

.toast-notification .toast-close:hover {
    background: rgba(0, 0, 0, 0.05);
    color: #212529;
}

@keyframes slideInRight {
    from {
        transform: translateX(400px);
        opacity: 0;
    }
    to {
        transform: translateX(0);
        opacity: 1;
    }
}

.toast-notification.removing {
    animation: slideOutRight 0.3s ease-out forwards;
}

@keyframes slideOutRight {
    from {
        transform: translateX(0);
        opacity: 1;
    }
    to {
        transform: translateX(400px);
        opacity: 0;
    }
}

/* Mobile responsive */
@media (max-width: 576px) {
    .toast-container {
        top: 10px;
        right: 10px;
        left: 10px;
        width: auto;
        max-width: none;
    }
    
    .toast-notification {
        padding: 12px 16px;
        min-height: 50px;
    }
    
    .toast-notification .toast-message {
        font-size: 13px;
    }
}
</style>

    <!-- Search Form -->
    <form class="mb-3" id="searchForm">
        <div class="row g-2 align-items-center">
            
            <div class="col-12 col-md order-1 order-md-0">
                <input type="text" class="form-control" id="searchInput" name="search" placeholder="Search notes..." value="{{ search_query }}">
            </div>
            <div class="col-auto">
                <button class="btn btn-primary" type="button" data-bs-toggle="modal" data-bs-target="#addMemoModal" title="Add New Note">
                    <i class="bi bi-plus-circle"></i>
                </button>
                <button type="button" class="btn btn-primary" data-bs-toggle="modal" data-bs-target="#manageCategoriesModal">
                    <i class="bi bi-tags"></i> 
                </button>
            </div>
            <div class="col-auto">
                <div class="form-check form-switch mb-0">
                    <input class="form-check-input" type="checkbox" id="showCompleted" name="show_completed" value="1" {% if show_completed %}checked{% endif %}>
                    <label class="form-check-label" for="showCompleted">Completed</label>
                </div>
            </div>
        </div>
    </form>

    <!-- Notes Container -->
    <div id="notesContainer">
        {% for category in categories %}
            {% set category_notes = notes|selectattr('category_id', 'equalto', category.id)|list %}
            {% set has_notes = category_notes|length > 0 %}
            {% if has_notes %}
                {% set completed_count = category_notes|selectattr('is_completed')|list|length %}
                {% set total_count = category_notes|length %}
                <div class="task-category d-flex align-items-center">
                    <button class="toggle-category" type="button" data-category-id="{{ category.id }}" style="background: linear-gradient(135deg, {{ category.color or '#0d6efd' }} 0%, {{ category.color or '#0d6efd' }}CC 100%) !important;">
                        <i class="bi bi-chevron-right" id="toggle-icon-{{ category.id }}"></i>
                        <span class="category-name">{{ category.name }}</span>
                    </button>
                    <span class="task-count {% if completed_count > 0 %}has-completed{% endif %}">
                        {% if completed_count > 0 %}
                            {{ completed_count }}/{{ total_count }}
                        {% else %}
                            {{ total_count }}
                        {% endif %}
                    </span>
                </div>
                <div class="category-table-wrapper collapsed" id="category-table-{{ category.id }}">
                    <table class="table task-table">
                        <thead>
                            <tr>
                                <th><i class="bi bi-check2-square"></i></th>
                                <th><i class="bi bi-file-text me-1"></i>Title</th>
                                <th><i class="bi bi-card-text me-1"></i>Content</th>
                                <th><i class="bi bi-calendar-event me-1"></i>Due</th>
                                <th><i class="bi bi-gear me-1"></i>Act</th>
                            </tr>
                        </thead>
                        <tbody>
                            {% for note in category_notes %}
                                <tr data-task-id="{{ note.id }}" class="{% if note.is_completed %}completed{% endif %}">
                                    <td class="text-center">
                                        <input type="checkbox" class="task-checkbox" 
                                               data-note-id="{{ note.id }}" 
                                               {% if note.is_completed %}checked{% endif %}
                                               title="Mark as {% if note.is_completed %}incomplete{% else %}complete{% endif %}">
                                    </td>
                                    <td onclick="openEditMemoModal({{ note.id }})" style="cursor:pointer;">
                                        <div class="task-title">{{ note.title }}</div>
                                    </td>
                                    <td onclick="openEditMemoModal({{ note.id }})" style="cursor:pointer;">
                                        <div class="task-content">{{ note.content|truncate(80) }}</div>
                                    </td>
                                    <td class="due-date-cell" data-note-id="{{ note.id }}" style="cursor:pointer;" title="Click to toggle completion">
                                        <div class="task-due due-date {% if note.is_completed %}completed{% endif %}" data-due-date="{{ note.due_date.isoformat() if note.due_date else '' }}">
                                            {% if note.is_completed %}
                                                <i class="bi bi-check-circle-fill me-1"></i>
                                            {% endif %}
                                            {{ note.due_date.strftime('%m/%d %H:%M') if note.due_date else 'No due' }}
                                        </div>
                                    </td>
                                    <td>
                                        <div class="function-buttons">
                                            <a href="{{ url_for('export_note', id=note.id) }}" class="btn" title="Export TXT">
                                                <i class="bi bi-file-earmark-text"></i>
                                            </a>
                                            <a href="{{ url_for('export_pdf', id=note.id) }}" class="btn" title="Export PDF">
                                                <i class="bi bi-file-earmark-pdf"></i>
                                            </a>
                                            <div class="delete-btn btn-delete-memo" data-note-id="{{ note.id }}" title="Delete Task">
                                                <i class="bi bi-trash"></i>
                                            </div>
                                        </div>
                                    </td>
                                </tr>
                            {% endfor %}
                        </tbody>
                    </table>
                </div>
            {% endif %}
        {% endfor %}
    </div>

    <!-- Modals -->
    <!-- Calendar Modal -->
    <div class="modal fade" id="calendarModal" tabindex="-1" aria-hidden="true">
    <div class="modal-dialog modal-lg">
        <div class="modal-content">
            <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            <div class="modal-body">
                <div id="calendar"></div>

            </div>
        </div>
    </div>
</div>

        <!-- Add Memo Modal -->
    {% if categories %}
    <div class="modal fade" id="addMemoModal" tabindex="-1" aria-hidden="true">
        <div class="modal-dialog">
            <div class="modal-content">
                <div class="modal-body">
                    <form id="addMemoForm" method="POST" action="{{ url_for('add_note') }}" enctype="multipart/form-data">
                        <div class="row">
                            <!-- Left Column: Title and Content -->
                            <div class="col-md-7">
                                <div class="mb-3">
                                    <input type="text" class="form-control" id="memoTitle" name="title" placeholder="Title" required tabindex="1">
                                </div>
                                <div class="mb-3">
                                    <textarea class="form-control" id="memoContent" name="content" rows="20" placeholder="Content" required tabindex="2" style="resize: vertical;"></textarea>
                                </div>
                            </div>
                            <!-- Right Column: Meta fields -->
                            <div class="col-md-5">
                                <div class="mb-3">
                                    <label class="form-label">Images</label>
                                    <input type="file" class="form-control" id="memoImages" name="images" multiple accept="image/png,image/jpeg,image/gif,image/heic">
                                    <div id="imagePreview" class="mt-2 d-flex flex-wrap gap-2" style="max-height: 200px; overflow-y: auto;"></div>
                                </div>
                                <div class="mb-3">
                                    <div class="form-check mb-2">
                                        <input class="form-check-input" type="checkbox" id="setDueDateCheckbox" checked>
                                        <label class="form-check-label" for="setDueDateCheckbox">
                                            Set Due Date
                                        </label>
                                    </div>
                                    <div id="dueDateInputContainer">
                                        <input type="datetime-local" class="form-control" id="memoDueDate" name="due_date" step="60">
                                    </div>
                                </div>
                                <div class="mb-3">
                                    <label class="form-label">Category</label>
                                    <select class="form-select" id="memoCategory" name="category_id" required></select>
                                </div>
                            </div>
                        </div>
                        <div class="d-flex justify-content-end mt-2">
                            <button type="submit" class="btn btn-primary">Save Memo</button>
                        </div>
                    </form>
                </div>
            </div>
        </div>
    </div>
    {% endif %}

    <!-- View Memo Modal -->
    <div class="modal fade" id="viewMemoModal" tabindex="-1" aria-hidden="true">
        <div class="modal-dialog">
            <div class="modal-content">
                <div class="modal-body">
                    <div class="row">
                        <!-- Left Column: Title and Content -->
                        <div class="col-md-7">
                            <h6 id="viewMemoTitle" class="mb-3"></h6>
                            <div id="viewMemoContent" style="white-space: pre-wrap; overflow-y: auto; max-height: calc(95vh - 200px);"></div>
                        </div>
                        <!-- Right Column: Meta fields -->
                        <div class="col-md-5">
                            <div class="mb-3">
                                <label class="form-label fw-bold">Images</label>
                                <div id="viewMemoImages" class="mt-2 d-flex flex-wrap gap-2" style="max-height: 200px; overflow-y: auto;"></div>
                            </div>
                            <div class="mb-3">
                                <label class="form-label fw-bold">Due Date</label>
                                <p id="viewMemoDueDate" class="text-muted mb-1"></p>
                            </div>
                            <div class="mb-3">
                                <label class="form-label fw-bold">Category</label>
                                <p id="viewMemoCategory" class="text-muted mb-1"></p>
                            </div>
                            <div class="mb-3">
                                <label class="form-label fw-bold">Share</label>
                                <p id="viewMemoShare" class="text-muted mb-1"></p>
                            </div>
                            <div class="mb-3">
                                <label class="form-label fw-bold">Status</label>
                                <p id="viewMemoCompleted" class="text-muted mb-1"></p>
                            </div>
                        </div>
                    </div>
                    <div class="d-flex justify-content-end mt-2">
                        <button type="button" class="btn btn-primary" onclick="noteManager.openEditModal(this.dataset.noteId)">Edit</button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Edit Memo Modal -->
    {% if categories %}
    <div class="modal fade" id="editMemoModal" tabindex="-1" aria-hidden="true">
        <div class="modal-dialog">
            <div class="modal-content">
                <div class="modal-body">
                    <form id="editMemoForm" method="POST" enctype="multipart/form-data">
                        <input type="hidden" id="editMemoId" name="id">
                        <div class="row">
                            <!-- Left Column: Title and Content -->
                            <div class="col-md-7">
                                <div class="mb-3">
                                    <input type="text" class="form-control" id="editMemoTitle" name="title" required tabindex="1">
                                </div>
                                <div class="mb-3">
                                    <textarea class="form-control" id="editMemoContent" name="content" rows="20" required tabindex="2" style="resize: vertical;"></textarea>
                                </div>
                            </div>
                            <!-- Right Column: Meta fields -->
                            <div class="col-md-5">
                                <div class="mb-3">
                                    <label class="form-label">Images</label>
                                    <input type="file" class="form-control" id="editMemoImages" name="images" multiple accept="image/png,image/jpeg,image/gif,image/heic">
                                    <div id="editImagePreview" class="mt-2 d-flex flex-wrap gap-2" style="max-height: 200px; overflow-y: auto;"></div>
                                </div>
                                <div class="mb-3">
                                    <label class="form-label">Due Date</label>
                                    <input type="datetime-local" class="form-control" id="editMemoDueDate" name="due_date" step="60">
                                </div>
                                <div class="mb-3">
                                    <label class="form-label">Category</label>
                                    <select class="form-select" id="editMemoCategory" name="category_id" required></select>
                                </div>
                            </div>
                        </div>
                        <div class="d-flex justify-content-end mt-2">
                            <button type="submit" class="btn btn-primary">Update Memo</button>
                        </div>
                    </form>
                </div>
            </div>
        </div>
    </div>
    {% endif %}

    <!-- Manage Categories Modal -->
    <div class="modal fade" id="manageCategoriesModal" tabindex="-1" aria-hidden="true">
        <div class="modal-dialog">
            <div class="modal-content">
                <div class="modal-body">
                    <form id="addCategoryForm" class="mb-3">
                        <div class="mb-3">
                            <label for="categoryName" class="form-label fw-bold">Category Name</label>
                            <input type="text" class="form-control" id="categoryName" name="name" placeholder="Enter category name" required>
                        </div>
                        <div class="row mb-3 align-items-end">
                            <div class="col">
                                <label for="categoryColor" class="form-label fw-bold">Category Color</label>
                                <input type="color" class="form-control form-control-color" id="categoryColor" name="color" value="#0d6efd" title="Choose category color">
                            </div>
                            <div class="col-auto">
                                <button type="submit" class="btn btn-primary px-4">Add Category</button>
                            </div>
                        </div>
                    </form>
                    <div id="categoriesContainer" class="row">
                        {% for category in categories %}
                        <div class="col-12 col-md-6 mb-3">
                            <div class="card" style="background-color: {{ category.color or '#ffffff' }};">
                                <div class="card-body d-flex justify-content-between align-items-center">
                                    <span class="category-label" style="background-color: {{ category.color or '#0d6efd' }}; color: {{ category.color|contrast_text_color }}; font-weight: bold; margin-right: 10px;">
                                        {{ category.name }}
                                    </span>
                                    <div>
                                        <button class="btn btn-sm me-1 edit-category" data-category-id="{{ category.id }}" data-category-name="{{ category.name }}" data-category-color="{{ category.color or '#ffffff' }}">
                                            <i class="bi bi-pencil"></i>
                                        </button>
                                        <button class="btn btn-sm delete-category" data-category-id="{{ category.id }}">
                                            <i class="bi bi-trash"></i>
                                        </button>
                                    </div>
                                </div>
                            </div>
                        </div>
                        {% endfor %}
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Utility Modals -->
    <div class="modal fade" id="imageViewModal" tabindex="-1" aria-hidden="true">
        <div class="modal-dialog modal-lg">
            <div class="modal-content">
                <div class="modal-body text-center">
                    <img id="enlargedImage" src="" style="max-width: 100%; max-height: 80vh; object-fit: contain;">
                </div>
            </div>
        </div>
    </div>

    <div class="modal fade" id="confirmDeleteModal" tabindex="-1" aria-hidden="true">
        <div class="modal-dialog modal-dialog-centered">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title">Confirm Delete</h5>
                    <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
                </div>
                <div class="modal-body">
                    Are you sure you want to delete this memo?
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-danger" id="confirmDeleteBtn">Delete</button>
                </div>
            </div>
        </div>
    </div>


    <script>
// === CONSTANTS & STATE ===
const SELECTORS = {
    forms: {
        addMemo: '#addMemoForm',
        editMemo: '#editMemoForm',
        addCategory: '#addCategoryForm',
        search: '#searchForm'
    },
    inputs: {
        search: '#searchInput',
        showCompleted: '#showCompleted',
        themeSelect: '#themeSelect'
    },
    containers: {
        notes: '#notesContainer',
        categories: '#categoriesContainer',
        imagePreview: '#imagePreview',
        editImagePreview: '#editImagePreview'
    }
};

// Image upload configuration
const IMAGE_CONFIG = {
    maxFileSize: 10 * 1024 * 1024, // 10MB
    maxFiles: 10,
    allowedTypes: ['image/jpeg', 'image/png', 'image/gif', 'image/heic'],
    allowedExtensions: ['.jpg', '.jpeg', '.png', '.gif', '.heic']
};

// State variables
const state = {
    notes: [],
    categories: [],
    selectedFilesAdd: [],
    selectedFilesEdit: [],
    existingImagesEdit: [],
    isUploading: false,
    objectURLs: [], // Track ObjectURLs for cleanup
    currentTheme: localStorage.getItem('theme') || '{{ session.get("theme", "light") }}'
};

// Initialize data
try {
    state.notes = {{ notes_data | tojson }};
    state.categories = {{ categories | tojson }};
} catch (e) {
    console.error('Error parsing initial data:', e);
}

// === MODAL MANAGEMENT ===
// Chỉ giữ lại các modal thực sự được sử dụng
const modals = Object.fromEntries([
    'addMemo', 'editMemo', 'viewMemo', 'imageView', 'confirmDelete', 
    'manageCategories', 'calendar'
].map(name => [name, new bootstrap.Modal(document.getElementById(`${name}Modal`))]));

function cleanBackdrops() {
    document.querySelectorAll('.modal-backdrop').forEach(el => el.remove());
    Object.assign(document.body.style, { overflow: '', paddingRight: '' });
    document.body.classList.remove('modal-open');
    document.body.removeAttribute('aria-hidden');
}

// === UTILITIES ===
const utils = {
    debounce(func, wait) {
        let timeout;
        return (...args) => {
            clearTimeout(timeout);
            timeout = setTimeout(() => func.apply(this, args), wait);
        };
    },

    linkify(text) {
        if (!text) return '';
        const urlRegex = /(https?:\/\/[^\s<]+[^\s<.,:;"')\]\}])/g;
        return text.replace(urlRegex, url => 
            `<a href="${url}" target="_blank" rel="noopener noreferrer">${url}</a>`
        );
    },

    formatDateJST(isoDate) {
        if (!isoDate) return '';
        const date = new Date(isoDate);
        const options = {
            year: 'numeric', month: '2-digit', day: '2-digit',
            weekday: 'short', hour: '2-digit', minute: '2-digit',
            hour12: false, timeZone: 'Asia/Tokyo'
        };
        const formatter = new Intl.DateTimeFormat('ja-JP', options);
        const parts = Object.fromEntries(
            formatter.formatToParts(date).map(part => [part.type, part.value])
        );
        return `${parts.year}/${parts.month}/${parts.day} (${parts.weekday}) ${parts.hour}:${parts.minute}`;
    }

    
};

// === UI MANAGEMENT ===
const ui = {
    showFlashMessage(category, message) {
        // Use global showFlashMessage function from baseall.html
        if (typeof window.showFlashMessage === 'function') {
            window.showFlashMessage(category, message);
        }
    },

    updateCategorySelect(selectElement = null, selectedId = null) {
        const elements = selectElement ? [selectElement] : 
            document.querySelectorAll('#memoCategory, #editMemoCategory');
        
        elements.forEach(select => {
            if (!select) return;
            
            select.innerHTML = '';
            
            state.categories.forEach(category => {
                const option = new Option(category.name, category.id);
                if (category.id == selectedId) option.selected = true;
                select.appendChild(option);
            });
        });
    },

    updateImagePreview(container, files, isAddModal, noteId = null)  {
        if (!container) return;
        
        // Cleanup old ObjectURLs to prevent memory leak
        state.objectURLs.forEach(url => URL.revokeObjectURL(url));
        state.objectURLs = [];
    
        container.innerHTML = '';
        
        if (!files || files.length === 0) {
            container.innerHTML = `
                <div class="image-drop-placeholder" style="
                    padding: 2rem;
                    text-align: center;
                    color: #6c757d;
                    border: 2px dashed #dee2e6;
                    border-radius: 8px;
                    background: #f8f9fa;
                    margin: 1rem 0;
                    cursor: pointer;
                ">
                    <i class="bi bi-images" style="font-size: 2rem; margin-bottom: 0.5rem;"></i>
                    <div>Drag & drop images here or click to select</div>
                    <small>Supports JPG, PNG, GIF, HEIC (max ${IMAGE_CONFIG.maxFileSize / 1024 / 1024}MB each, max ${IMAGE_CONFIG.maxFiles} files)</small>
                </div>
            `;
            return;
        }
        
        // Show file count if near limit
        if (files.length >= IMAGE_CONFIG.maxFiles - 2) {
            const countIndicator = document.createElement('div');
            countIndicator.className = 'text-muted small mb-2';
            countIndicator.textContent = `${files.length}/${IMAGE_CONFIG.maxFiles} images`;
            container.appendChild(countIndicator);
        }
        
        files.forEach((fileObj, index) => {
            const preview = imageManager.createImagePreview(fileObj, index, async (removeIndex) => {
                if (isAddModal) {
                    state.selectedFilesAdd.splice(removeIndex, 1);
                    ui.updateImagePreview(container, state.selectedFilesAdd, true);
                } else {
                    // Handle existing vs new files
                    if (removeIndex < state.existingImagesEdit.length) {
                        // Remove existing image
                        state.existingImagesEdit.splice(removeIndex, 1);
                    } else {
                        // Remove new file
                        const selectedIndex = removeIndex - state.existingImagesEdit.length;
                        state.selectedFilesEdit.splice(selectedIndex, 1);
                    }
                    ui.updateImagePreview(container, [...state.existingImagesEdit, ...state.selectedFilesEdit], false, noteId);
                }
            }, noteId);
            container.appendChild(preview);
        });
    },

    adjustCategoryButtonWidths() {
        // Category buttons now auto-adjust to content width
        // No fixed width needed - buttons will wrap text naturally
        const buttons = document.querySelectorAll('.toggle-category');
        if (!buttons.length) return;
    },

    highlightDueDates() {
        const now = new Date();
        document.querySelectorAll('.task-due.due-date').forEach(el => {
            const isoDate = el.getAttribute('data-due-date');
            if (!isoDate) return;
            
            const due = new Date(isoDate);
            const timeDiff = due - now;
            
            el.style.backgroundColor = '';
            if (timeDiff < 0) {
                el.style.backgroundColor = '#ffd6d6';
            } else if (timeDiff <= 24 * 60 * 60 * 1000) {
                el.style.backgroundColor = '#fff7cc';
            }
        });
    },

    updateDueDateDisplays() {
        document.querySelectorAll('.due-date').forEach(el => {
            const isoDate = el.getAttribute('data-due-date');
            if (isoDate) el.textContent = utils.formatDateJST(isoDate);
        });
    }
};

// === API HANDLERS ===
const api = {
    async request(url, options = {}) {
        const defaultOptions = {
            headers: { 'X-Requested-With': 'XMLHttpRequest' }
        };
        
        try {
            const response = await fetch(url, { ...defaultOptions, ...options });
            
            if (response.redirected) {
                window.location.href = response.url;
                return null;
            }
            
            const result = await response.json();
            
            // If the response includes updated note data, update local state
            if (result?.note && options.method === 'POST') {
                const noteIndex = state.notes.findIndex(n => n.id == result.note.id);
                if (noteIndex !== -1) {
                    state.notes[noteIndex] = result.note;
                } else if (result.status === 'success' && url.includes('/add_note')) {
                    // Add new note to state
                    state.notes.push(result.note);
                }
            }
            
            return result;
        } catch (error) {
            ui.showFlashMessage('danger', error.message || 'Network error occurred');
            throw error;
        }
    },

    async fetchNoteData(noteId) {
        const data = await this.request(`/edit_note/${noteId}`);
        if (data?.status !== 'success') {
            throw new Error(data?.message || 'Failed to load note data');
        }
        return data;
    },

    async prepareFormData(form, isEdit = false, selectedFiles = [], existingImages = []) {
        const formData = new FormData(form);
    
        // Remove existing images field
        formData.delete('images');
        
        // Add selected files directly (no compression)
        for (const file of selectedFiles) {
            formData.append('images', file);
        }
        
        return formData;
    }
};

// === EVENT HANDLERS ===
const eventHandlers = {
    attachDueDateClickListeners() {
        document.querySelectorAll('.due-date-cell').forEach(cell => {
            // Xóa event listener cũ nếu có
            if (cell._clickListener) {
                cell.removeEventListener('click', cell._clickListener);
            }
            
            // Tạo function riêng cho mỗi cell
            cell._clickListener = async function(event) {
                event.stopPropagation(); // Prevent opening view modal
                
                const noteId = parseInt(this.dataset.noteId);
                const dueDateEl = this.querySelector('.task-due');
                const isCurrentlyCompleted = dueDateEl.classList.contains('completed');
                
                try {
                    // Visual feedback immediately
                    this.style.opacity = '0.6';
                    
                    const data = await api.request(`/toggle_complete/${noteId}`, { 
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        }
                    });
                    
                    if (data?.status === 'success') {
                        // Update local state
                        const noteIndex = state.notes.findIndex(n => n.id === noteId);
                        if (noteIndex !== -1) {
                            state.notes[noteIndex].is_completed = !isCurrentlyCompleted;
                        }
                        
                        // Update UI
                        const row = this.closest('tr');
                        if (!isCurrentlyCompleted) {
                            // Mark as completed
                            dueDateEl.classList.add('completed');
                            row.classList.add('completed');
                            
                            // Add check icon if not exists
                            if (!dueDateEl.querySelector('i')) {
                                const icon = document.createElement('i');
                                icon.className = 'bi bi-check-circle-fill me-1';
                                dueDateEl.insertBefore(icon, dueDateEl.firstChild);
                            }
                        } else {
                            // Mark as incomplete
                            dueDateEl.classList.remove('completed');
                            row.classList.remove('completed');
                            
                            // Remove check icon
                            const icon = dueDateEl.querySelector('i');
                            if (icon) icon.remove();
                        }
                        
                        // Update task counts
                        noteManager.updateTaskCounts();
                        
                        // Update checkbox state
                        const checkbox = row.querySelector('.task-checkbox');
                        if (checkbox) {
                            checkbox.checked = !isCurrentlyCompleted;
                        }
                        
                        // Show brief feedback
                        ui.showFlashMessage('success', 
                            !isCurrentlyCompleted ? 'Task marked as completed' : 'Task marked as incomplete'
                        );
                        
                    } else {
                        ui.showFlashMessage('danger', data?.message || 'Failed to update completion status');
                    }
                } catch (error) {
                    console.error('Toggle completion error:', error);
                    ui.showFlashMessage('danger', 'Error updating completion status');
                } finally {
                    // Reset visual feedback
                    this.style.opacity = '1';
                }
            };
            
            cell.addEventListener('click', cell._clickListener);
        });
    },

    attachCheckboxListeners() {
        document.querySelectorAll('.task-checkbox').forEach(checkbox => {
            if (checkbox._changeListener) {
                checkbox.removeEventListener('change', checkbox._changeListener);
            }
            
            checkbox._changeListener = async function(event) {
                event.stopPropagation();
                
                const noteId = parseInt(this.dataset.noteId);
                const isNowChecked = this.checked;
                const row = this.closest('tr');
                const dueDateEl = row.querySelector('.task-due');
                
                try {
                    this.disabled = true;
                    
                    const data = await api.request(`/toggle_complete/${noteId}`, { 
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        }
                    });
                    
                    if (data?.status === 'success') {
                        // Update local state
                        const noteIndex = state.notes.findIndex(n => n.id === noteId);
                        if (noteIndex !== -1) {
                            state.notes[noteIndex].is_completed = isNowChecked;
                        }
                        
                        // Update row styling
                        if (isNowChecked) {
                            row.classList.add('completed');
                            dueDateEl.classList.add('completed');
                            if (!dueDateEl.querySelector('i')) {
                                const icon = document.createElement('i');
                                icon.className = 'bi bi-check-circle-fill me-1';
                                dueDateEl.insertBefore(icon, dueDateEl.firstChild);
                            }
                        } else {
                            row.classList.remove('completed');
                            dueDateEl.classList.remove('completed');
                            const icon = dueDateEl.querySelector('i');
                            if (icon) icon.remove();
                        }
                        
                        noteManager.updateTaskCounts();
                        ui.showFlashMessage('success', 
                            isNowChecked ? 'Task completed!' : 'Task marked as incomplete'
                        );
                    } else {
                        // Revert checkbox state
                        this.checked = !isNowChecked;
                        ui.showFlashMessage('danger', data?.message || 'Failed to update');
                    }
                } catch (error) {
                    console.error('Checkbox toggle error:', error);
                    this.checked = !isNowChecked;
                    ui.showFlashMessage('danger', 'Error updating task');
                } finally {
                    this.disabled = false;
                }
            };
            
            checkbox.addEventListener('change', checkbox._changeListener);
        });
    },

    attachCategoryToggleListeners() {
        document.querySelectorAll('.toggle-category').forEach(button => {
            const newButton = button.cloneNode(true);
            button.parentNode.replaceChild(newButton, button);
            
            newButton.addEventListener('click', () => {
                const categoryId = newButton.dataset.categoryId;
                const tableWrapper = document.getElementById(`category-table-${categoryId}`);
                const icon = document.getElementById(`toggle-icon-${categoryId}`);
                
                if (tableWrapper && icon) {
                    tableWrapper.classList.toggle('collapsed');
                    icon.classList.toggle('bi-chevron-down');
                    icon.classList.toggle('bi-chevron-right');
                }
            });
        });
        ui.adjustCategoryButtonWidths();
    },

    attachCategoryEventListeners() {
        const container = document.querySelector(SELECTORS.containers.categories);
        if (!container) return;
        
        container.querySelectorAll('.edit-category').forEach(button => {
            button.onclick = () => categoryManager.editCategory(button.dataset);
        });
        
        container.querySelectorAll('.delete-category').forEach(button => {
            button.onclick = () => categoryManager.deleteCategory(button.dataset.categoryId);
        });
    }
};

// === MANAGERS ===
const noteManager = {
    // Add properties to track calendar state
    isInCalendarMode: false,
    calendarInstance: null,
    currentCalendarView: null, // Store current view type

    async openViewModal(noteId, fromCalendar = false) {
        try {
            // Track if opened from calendar and save current view
            this.isInCalendarMode = fromCalendar;
            if (fromCalendar && this.calendarInstance) {
                this.currentCalendarView = this.calendarInstance.view.type;
                console.log('Saved calendar view:', this.currentCalendarView); // Debug log
            }
            
            const data = await api.fetchNoteData(noteId);
            const note = data.note;
            
            Object.entries({
                '#viewMemoTitle': note.title || '',
                '#viewMemoDueDate': note.due_date ? `Due: ${utils.formatDateJST(note.due_date)}` : '',
                '#viewMemoCategory': `Category: ${note.category_name || 'None'}`,
                '#viewMemoCompleted': `Status: ${note.is_completed ? 'Completed' : 'Incomplete'}`
            }).forEach(([selector, content]) => {
                const el = document.querySelector(selector);
                if (el) el.textContent = content;
            });
            
            const contentEl = document.querySelector('#viewMemoContent');
            if (contentEl) {
                contentEl.innerHTML = utils.linkify(note.content || '');
                
                // Remove any existing click handlers
                contentEl.onclick = null;
                contentEl.removeEventListener('click', contentEl._editHandler);
                
                // Create new click handler
                contentEl._editHandler = (e) => {
                    // Don't trigger if clicking on a link
                    if (e.target.tagName === 'A') return;
                    
                    e.preventDefault();
                    e.stopPropagation();
                    
                    // Open edit modal and track calendar mode
                    modals.viewMemo.hide();
                    setTimeout(() => this.openEditModal(noteId, this.isInCalendarMode), 300);
                };
                
                // Add click event listener
                contentEl.addEventListener('click', contentEl._editHandler);
                
                // Add visual feedback for mobile
                const isMobile = window.innerWidth <= 768;
                if (isMobile) {
                    contentEl.style.cursor = 'pointer';
                    contentEl.title = 'Tap to edit';
                    
                    // Add touch feedback
                    contentEl.addEventListener('touchstart', () => {
                        contentEl.style.backgroundColor = '#f8f9fa';
                    });
                    
                    contentEl.addEventListener('touchend', () => {
                        setTimeout(() => {
                            contentEl.style.backgroundColor = '';
                        }, 150);
                    });
                }
            }
            
            const shareEl = document.querySelector('#viewMemoShare');
            if (shareEl) {
                shareEl.innerHTML = note.share_id ? 
                    `Share: <a href="{{ url_for('share_note', share_id='') }}${note.share_id}" target="_blank">Link</a>` : '';
            }
            
            this.populateImages('#viewMemoImages', note.images, true);
            
            // Store noteId for edit button and track calendar mode
            const editBtn = document.querySelector('#viewMemoModal .btn-primary');
            if (editBtn) {
                editBtn.dataset.noteId = noteId;
                editBtn.onclick = () => {
                    modals.viewMemo.hide();
                    setTimeout(() => this.openEditModal(noteId, this.isInCalendarMode), 300);
                };
            }
            
            modals.viewMemo.show();
            if (note.images) {
                try {
                    const images = typeof note.images === 'string' ? JSON.parse(note.images) : note.images;
                    this.populateImages('#viewMemoImages', images, true);
                } catch (e) {
                    console.error('Error parsing images:', e);
                }
            }
        } catch (error) {
            console.error('Error opening view modal:', error);
        }

            
    },

    async openEditModal(noteId, fromCalendar = false) {
        try {
            const data = await api.fetchNoteData(noteId);
            const note = data.note;
            
            // ✅ SỬA: Populate form fields trước khi show modal
            document.querySelector('#editMemoId').value = noteId;
            document.querySelector('#editMemoTitle').value = note.title || '';
            document.querySelector('#editMemoContent').value = note.content || '';
            
            // ✅ SỬA: Xử lý due_date đúng cách
            const dueDateInput = document.querySelector('#editMemoDueDate');
            if (dueDateInput) {
                if (note.due_date) {
                    // Backend đã format đúng YYYY-MM-DDTHH:MM, chỉ cần set trực tiếp
                    dueDateInput.value = note.due_date;
                    console.log('Set due date:', note.due_date); // Debug log
                } else {
                    dueDateInput.value = '';
                    console.log('No due date'); // Debug log
                }
            }
            
            // ✅ SỬA: Update category select
            ui.updateCategorySelect(document.querySelector('#editMemoCategory'), note.category_id);
            
            // ✅ SỬA: Load images từ file paths
            if (note.images && Array.isArray(note.images)) {
                state.existingImagesEdit = note.images.map(img => ({
                    filename: img.filename,
                    path: img.path,
                    original_name: img.original_name || img.filename
                }));
            } else {
                state.existingImagesEdit = [];
            }
            
            state.selectedFilesEdit = [];
            
            // Clear file input
            const fileInput = document.querySelector('#editMemoImages');
            if (fileInput) fileInput.value = '';
            
            // Update image preview
            ui.updateImagePreview(
                document.querySelector('#editImagePreview'),
                [...state.existingImagesEdit, ...state.selectedFilesEdit],
                false,
                noteId
            );
            
            // ✅ QUAN TRỌNG: Show modal sau khi đã populate data
            modals.editMemo.show();
            
        } catch (error) {
            console.error('Error opening edit modal:', error);
            ui.showFlashMessage('danger', 'Failed to load note data');
        }
    },

    // XÓA HÀM backToCalendar() THỨ 2 và chỉ giữ lại hàm này
    async backToCalendar() {
        if (this.isInCalendarMode) {
            console.log('Returning to calendar, restoring view:', this.currentCalendarView); // Debug log
            
            // Refresh data first
            await this.refreshData();
            
            // Show calendar modal again
            modals.calendar.show();
            
            // Update calendar and restore previous view
            setTimeout(() => {
                renderCalendar();
                
                // Restore the previous view after calendar is rendered
                if (this.currentCalendarView && this.calendarInstance) {
                    console.log('Restoring calendar view to:', this.currentCalendarView); // Debug log
                    setTimeout(() => {
                        try {
                            this.calendarInstance.changeView(this.currentCalendarView);
                            console.log('Successfully restored view to:', this.currentCalendarView); // Debug log
                        } catch (error) {
                            console.error('Error restoring calendar view:', error);
                        }
                    }, 500); // Increased timeout to ensure calendar is fully rendered
                }
            }, 300);
        } else {
            // Reset calendar mode when not from calendar
            this.isInCalendarMode = false;
            this.currentCalendarView = null;
        }
    },

    // Add method to refresh data from server
    async refreshData() {
        try {
            const response = await fetch('/task', {
                headers: { 'X-Requested-With': 'XMLHttpRequest' }
            });
            
            if (response.ok) {
                const html = await response.text();
                const parser = new DOMParser();
                const doc = parser.parseFromString(html, 'text/html');
                
                // Parse updated data from script
                const scriptContent = doc.querySelector('script')?.textContent;
                if (scriptContent) {
                    try {
                        const notesMatch = scriptContent.match(/notes_data\s*=\s*(\[.*?\]);/s);
                        const categoriesMatch = scriptContent.match(/categories\s*=\s*(\[.*?\]);/s);
                        
                        if (notesMatch) {
                            state.notes = JSON.parse(notesMatch[1]);
                        }
                        if (categoriesMatch) {
                            state.categories = JSON.parse(categoriesMatch[1]);
                        }
                    } catch (parseError) {
                        console.warn('Could not parse updated data:', parseError);
                    }
                }
            }
        } catch (error) {
            console.error('Error refreshing data:', error);
        }
    },

    populateImages(selector, images, isClickable = false) {
        const container = document.querySelector(selector);
        if (!container || !images) return;
        
        container.innerHTML = '';
        
        if (images.length === 0) {
            container.innerHTML = '<p class="text-muted">No images</p>';
            return;
        }
        
        images.forEach(image => {
            const wrapper = document.createElement('div');
            wrapper.className = 'position-relative d-inline-block me-2 mb-2';
            wrapper.style.cssText = 'border: 1px solid #ddd; border-radius: 8px; overflow: hidden;';
            
            const img = document.createElement('img');
            img.src = image.path; // Use file path instead of base64
            img.style.cssText = 'width: 120px; height: 120px; object-fit: cover;';
            
            if (isClickable) {
                img.style.cursor = 'pointer';
                img.onclick = () => imageManager.showImageModal(image.path);
            }
            
            // Add filename tooltip
            img.title = image.original_name || image.filename;
            
            wrapper.appendChild(img);
            container.appendChild(wrapper);
        });
    },

    async updateSearch() {
        const container = document.querySelector(SELECTORS.containers.notes);
        if (!container) return;
        
        try {
            // Xóa category_id parameter, mặc định search tất cả
            const params = new URLSearchParams({
                search: document.querySelector(SELECTORS.inputs.search)?.value || '',
                show_completed: document.querySelector(SELECTORS.inputs.showCompleted)?.checked ? 1 : 0
            });
            
            const response = await fetch(`/task?${params.toString()}`);
            
            if (!response.ok) {
                throw new Error(`HTTP ${response.status}: ${response.statusText}`);
            }
            
            const html = await response.text();
            
            const parser = new DOMParser();
            const doc = parser.parseFromString(html, 'text/html');
            const newContainer = doc.querySelector(SELECTORS.containers.notes);
            
            if (newContainer) {
                container.innerHTML = newContainer.innerHTML;
            }
            
            // Safely parse script content
            const scriptContent = doc.querySelector('script')?.textContent;
            if (scriptContent) {
                try {
                    const notesMatch = scriptContent.match(/notes_data\s*=\s*(\[.*?\]);/s);
                    const categoriesMatch = scriptContent.match(/categories\s*=\s*(\[.*?\]);/s);
                    
                    if (notesMatch) {
                        state.notes = JSON.parse(notesMatch[1]);
                    }
                    if (categoriesMatch) {
                        state.categories = JSON.parse(categoriesMatch[1]);
                        ui.updateCategorySelect();
                    }
                } catch (parseError) {
                    console.warn('Could not parse script data:', parseError);
                }
            }
            
            // Update task counts after search - SỬA LỖI TẠI ĐÂY
            noteManager.updateTaskCounts();
            
            // Sử dụng noteManager.updateEventListeners thay vì this.updateEventListeners
            noteManager.updateEventListeners();
        } catch (error) {
            console.error('Search error details:', error);
            ui.showFlashMessage('danger', `Error searching notes: ${error.message}`);
        }
    },

    // Add new method to update task counts dynamically
    updateTaskCounts() {
        document.querySelectorAll('.task-category').forEach(categoryEl => {
            const toggleBtn = categoryEl.querySelector('.toggle-category');
            const countEl = categoryEl.querySelector('.task-count');
            
            if (!toggleBtn || !countEl) return;
            
            const categoryId = toggleBtn.dataset.categoryId;
            const categoryNotes = state.notes.filter(note => note.category_id == categoryId);
            const completedCount = categoryNotes.filter(note => note.is_completed).length;
            const totalCount = categoryNotes.length;
            
            // Update count display
            if (completedCount > 0) {
                countEl.textContent = `${completedCount}/${totalCount}`;
                countEl.classList.add('has-completed');
            } else {
                countEl.textContent = totalCount;
                countEl.classList.remove('has-completed');
            }
        });
    },

    updateEventListeners() {
        eventHandlers.attachDueDateClickListeners(); // Thay thế attachToggleSwitchListeners()
        eventHandlers.attachCheckboxListeners(); // Checkbox toggle listeners
        ui.highlightDueDates();
        ui.updateDueDateDisplays();
        eventHandlers.attachCategoryToggleListeners();
    },
};

const categoryManager = {
    isEditing: false,
    editingCategoryId: null,
    
    async editCategory({ categoryId, categoryName, categoryColor }) {
        const form = document.querySelector(SELECTORS.forms.addCategory);
        if (!form) return;
        
        this.isEditing = true;
        this.editingCategoryId = categoryId;
        
        form.querySelector('#categoryName').value = categoryName;
        form.querySelector('#categoryColor').value = categoryColor || '#0d6efd';
        
        const submitBtn = form.querySelector('button[type="submit"]');
        submitBtn.textContent = 'Update Category';
        submitBtn.classList.remove('btn-primary');
        submitBtn.classList.add('btn-success');
        
        // Add cancel button if not exists
        if (!form.querySelector('.btn-cancel-edit')) {
            const cancelBtn = document.createElement('button');
            cancelBtn.type = 'button';
            cancelBtn.className = 'btn btn-secondary ms-2 btn-cancel-edit';
            cancelBtn.textContent = 'Cancel';
            cancelBtn.onclick = () => this.resetForm();
            submitBtn.parentNode.appendChild(cancelBtn);
        }
        
        // Focus on name input
        form.querySelector('#categoryName').focus();
    },

    async submitCategory(e) {
        e.preventDefault();
        const form = e.target;
        const formData = new FormData(form);
        
        if (this.isEditing && this.editingCategoryId) {
            // Update existing category
            try {
                const data = await api.request(`/edit_category/${this.editingCategoryId}`, {
                    method: 'POST',
                    body: formData
                });
                
                if (data?.status === 'success') {
                    const index = state.categories.findIndex(c => c.id == this.editingCategoryId);
                    if (index !== -1) state.categories[index] = data.category;
                    
                    this.updateDisplays();
                    this.resetForm();
                    ui.showFlashMessage('success', 'Category updated successfully');
                } else {
                    ui.showFlashMessage('danger', data?.message || 'Failed to update category');
                }
            } catch (error) {
                ui.showFlashMessage('danger', 'Error updating category');
            }
        } else {
            // Add new category
            try {
                const data = await api.request('/add_category', {
                    method: 'POST',
                    body: formData
                });
                
                if (data?.status === 'success') {
                    state.categories.push(data.category);
                    this.updateDisplays();
                    this.resetForm();
                    ui.showFlashMessage('success', 'Category added successfully');
                } else {
                    ui.showFlashMessage('danger', data?.message || 'Failed to add category');
                }
            } catch (error) {
                ui.showFlashMessage('danger', 'Error adding category');
            }
        }
    },

    async deleteCategory(categoryId) {
        if (!confirm('Are you sure you want to delete this category? All notes in this category will be moved to "Uncategorized".')) return;
        
        try {
            const data = await api.request(`/delete_category/${categoryId}`, { method: 'POST' });
            if (data?.status === 'success') {
                state.categories = state.categories.filter(c => c.id != categoryId);
                this.updateDisplays();
                noteManager.updateSearch();
                ui.showFlashMessage('success', 'Category deleted successfully');
            } else {
                ui.showFlashMessage('danger', data?.message || 'Failed to delete category');
            }
        } catch (error) {
            ui.showFlashMessage('danger', 'Error deleting category');
        }
    },

    updateDisplays() {
        this.updateCategoriesDisplay();
        ui.updateCategorySelect();
    },

    updateCategoriesDisplay() {
        const container = document.querySelector(SELECTORS.containers.categories);
        if (!container) return;
        
        container.innerHTML = '';
        state.categories.forEach(category => {
            const div = document.createElement('div');
            div.className = 'col-12 col-md-6 mb-3';
            div.innerHTML = `
                <div class="card category-card-item" style="background-color: ${category.color || '#f8f9fa'}; border: 2px solid ${category.color || '#dee2e6'};">
                    <div class="card-body d-flex justify-content-between align-items-center py-2">
                        <span class="category-label" style="
                            background-color: ${category.color || '#0d6efd'};
                            color: ${category.color ? this.getContrastColor(category.color) : '#ffffff'};
                            font-weight: bold;
                            display: inline-flex;
                            align-items: center;
                            justify-content: center;
                            border-radius: 0.5rem;
                            margin-right: 10px;
                            min-width: 100px;
                            height: 32px;
                            padding: 0 12px;
                            font-size: 0.9rem;
                        ">${category.name}</span>
                        <div class="category-actions">
                            <button class="btn btn-sm btn-outline-secondary me-1 edit-category" 
                                data-category-id="${category.id}" 
                                data-category-name="${category.name}" 
                                data-category-color="${category.color || '#0d6efd'}"
                                title="Edit category">
                                <i class="bi bi-pencil"></i>
                            </button>
                            <button class="btn btn-sm btn-outline-danger delete-category" 
                                data-category-id="${category.id}"
                                title="Delete category">
                                <i class="bi bi-trash"></i>
                            </button>
                        </div>
                    </div>
                </div>
            `;
            container.appendChild(div);
        });
        
        eventHandlers.attachCategoryEventListeners();
    },

    getContrastColor(hexColor) {
        const rgb = hexColor.match(/\w\w/g)?.map(x => parseInt(x, 16)) || [255, 255, 255];
        const luminance = (0.299 * rgb[0] + 0.587 * rgb[1] + 0.114 * rgb[2]) / 255;
        return luminance > 0.5 ? '#000000' : '#ffffff';
    },

    resetForm() {
        const form = document.querySelector(SELECTORS.forms.addCategory);
        if (!form) return;
        
        this.isEditing = false;
        this.editingCategoryId = null;
        
        form.reset();
        form.querySelector('#categoryColor').value = '#0d6efd';
        
        const submitBtn = form.querySelector('button[type="submit"]');
        submitBtn.textContent = 'Add Category';
        submitBtn.classList.remove('btn-success');
        submitBtn.classList.add('btn-primary');
        
        // Remove cancel button if exists
        const cancelBtn = form.querySelector('.btn-cancel-edit');
        if (cancelBtn) cancelBtn.remove();
    }
};

// === CALENDAR ===
function renderCalendar() {
    const calendarEl = document.getElementById('calendar');
    if (!calendarEl) return;
    
    // Destroy existing calendar if any
    if (noteManager.calendarInstance) {
        noteManager.calendarInstance.destroy();
    }
    
    calendarEl.innerHTML = '';
    
    const events = state.notes
        .filter(n => n.due_date)
        .map(note => {
            const category = state.categories.find(c => c.id === note.category_id);
            return {
                id: String(note.id),
                title: note.title || 'Untitled',
                start: note.due_date,
                backgroundColor: category?.color || '#0d6efd',
                borderColor: category?.color || '#0d6efd',
                textColor: '#fff',
                extendedProps: {
                    noteId: note.id,
                    content: note.content?.substring(0, 50) + (note.content?.length > 50 ? '...' : ''),
                    categoryName: category?.name || 'No Category'
                }
            };
        });
    
    // Detect device type
    const isMobile = window.innerWidth <= 768;
    const isTablet = window.innerWidth > 768 && window.innerWidth <= 1024;
    
    const calendar = new FullCalendar.Calendar(calendarEl, {
        initialView: isMobile ? 'listMonth' : 'dayGridMonth',
        headerToolbar: {
            left: isMobile ? 'prev,next' : 'prev,next today',
            center: 'title',
            right: isMobile ? 'dayGridMonth,timeGridWeek,timeGridDay,listMonth' : 'dayGridMonth,timeGridWeek,timeGridDay,listMonth'
        },
        themeSystem: 'bootstrap5',
        events: events,
        displayEventTime: true,
        height: 'auto',
        aspectRatio: isMobile ? 0.8 : (isTablet ? 1.35 : 1.6),
        
        // Mobile-specific settings
        dayMaxEvents: isMobile ? 1 : 3,
        moreLinkClick: 'popover',
        eventTextColor: '#fff',
        
        // Touch/mobile interaction
        selectable: true,
        selectMirror: true,
        
        // Mobile-optimized view configurations
        views: {
            dayGridMonth: {
                dayMaxEvents: isMobile ? 1 : 3,
                eventDisplay: 'block',
                dayHeaderFormat: isMobile ? { weekday: 'short' } : { weekday: 'short', day: 'numeric' }
            },
            timeGridWeek: {
                slotMinTime: '06:00:00',
                slotMaxTime: '23:00:00',
                slotDuration: isMobile ? '01:00:00' : '00:30:00',
                slotLabelInterval: isMobile ? '02:00:00' : '01:00:00',
                allDaySlot: true,
                nowIndicator: true,
                dayHeaderFormat: isMobile ? { weekday: 'short', day: 'numeric' } : { weekday: 'short', month: 'short', day: 'numeric' },
                eventMinHeight: isMobile ? 20 : 30
            },
            timeGridDay: {
                slotMinTime: '06:00:00',
                slotMaxTime: '23:00:00',
                slotDuration: isMobile ? '01:00:00' : '00:30:00',
                slotLabelInterval: isMobile ? '01:00:00' : '00:30:00',
                allDaySlot: true,
                nowIndicator: true,
                dayHeaderFormat: { weekday: 'long', month: 'short', day: 'numeric' },
                eventMinHeight: isMobile ? 25 : 35
            },
            listMonth: {
                listDayFormat: isMobile ? { weekday: 'short', day: 'numeric' } : { weekday: 'long', month: 'short', day: 'numeric' },
                listDaySideFormat: false,
                noEventsContent: 'No tasks scheduled for this month'
            }
        },
        
        eventClick: info => {
            // DON'T close calendar modal - just open view modal on top
            noteManager.openViewModal(info.event.id, true); // Pass true to indicate from calendar
        },
        
        eventDidMount: info => {
            // Add tooltips for desktop, enhance mobile display
            if (!isMobile && info.event.extendedProps?.content) {
                new bootstrap.Tooltip(info.el, {
                    title: `${info.event.extendedProps.categoryName}: ${info.event.extendedProps.content}`,
                    placement: 'top',
                    trigger: 'hover',
                    container: 'body'
                });
            }
            
            // Enhanced mobile event styling
            if (isMobile) {
                info.el.style.fontSize = '0.75rem';
                info.el.style.padding = '1px 3px';
                info.el.style.margin = '1px 0';
                info.el.style.borderRadius = '3px';
                
                // Add category info for mobile
                const titleEl = info.el.querySelector('.fc-event-title');
                if (titleEl && info.event.extendedProps?.categoryName) {
                    titleEl.innerHTML = `<small style="opacity: 0.8;">${info.event.extendedProps.categoryName}:</small><br>${info.event.title}`;
                }
            }
        },
        
        // Responsive view switching
        windowResize: function() {
            const newIsMobile = window.innerWidth <= 768;
            if (newIsMobile !== isMobile) {
                // Reload calendar with new mobile settings
                renderCalendar();
            }
        },
        
        // Custom event rendering for better mobile experience
        eventContent: function(arg) {
            if (isMobile) {
                return {
                    html: `<div style="font-size: 0.7rem; line-height: 1.1;">
                            <div style="font-weight: bold; margin-bottom: 1px;">${arg.event.title}</div>
                            <div style="opacity: 0.8; font-size: 0.65rem;">${arg.event.extendedProps.categoryName}</div>
                           </div>`
                };
            }
            return false; // Use default rendering for desktop
        }
    });
    
    calendar.render();
    // Store calendar instance
    noteManager.calendarInstance = calendar;
    
    // Add mobile-specific event listeners
    if (isMobile) {
        // Enhanced swipe gestures for navigation
        let startX = null;
        let startY = null;
        
        calendarEl.addEventListener('touchstart', (e) => {
            startX = e.touches[0].clientX;
            startY = e.touches[0].clientY;
        });
        
        calendarEl.addEventListener('touchend', (e) => {
            if (!startX || !startY) return;
            
            const endX = e.changedTouches[0].clientX;
            const endY = e.changedTouches[0].clientY;
            const diffX = startX - endX;
            const diffY = startY - endY;
            
            // Only trigger if horizontal swipe is dominant and significant
            if (Math.abs(diffX) > Math.abs(diffY) && Math.abs(diffX) > 80) {
                if (diffX > 0) {
                    calendar.next(); // Swipe left = next
                } else {
                    calendar.prev(); // Swipe right = previous
                }
            }
            
            startX = null;
            startY = null;
        });
        
        // Add double tap to change view on mobile
        let lastTap = 0;
        calendarEl.addEventListener('touchend', (e) => {
            const currentTime = new Date().getTime();
            const tapLength = currentTime - lastTap;
            
            if (tapLength < 500 && tapLength > 0) {
                // Double tap detected - cycle through views
                const currentView = calendar.view.type;
                const mobileViews = ['listMonth', 'dayGridMonth', 'timeGridWeek', 'timeGridDay'];
                const currentIndex = mobileViews.indexOf(currentView);
                const nextIndex = (currentIndex + 1) % mobileViews.length;
                calendar.changeView(mobileViews[nextIndex]);
            }
            
            lastTap = currentTime;
        });
    }
}

// === INITIALIZATION ===
document.addEventListener('DOMContentLoaded', () => {
    imageManager.setupDragAndDrop();

    // Setup modal event listeners
    const addMemoModal = document.getElementById('addMemoModal');
    if (addMemoModal) {
        addMemoModal.addEventListener('show.bs.modal', () => {
            cleanBackdrops();
            const dueDateInput = document.getElementById('memoDueDate');
            const setDueDateCheckbox = document.getElementById('setDueDateCheckbox');
            const dueDateContainer = document.getElementById('dueDateInputContainer');
            
            // Set initial state - checkbox checked, show input with today's date
            if (setDueDateCheckbox) {
                setDueDateCheckbox.checked = true;
            }
            if (dueDateContainer) {
                dueDateContainer.style.display = 'block';
            }
            if (dueDateInput) {
                const now = new Date();
                now.setHours(23, 59, 0, 0);
                const pad = n => n.toString().padStart(2, '0');
                dueDateInput.value = `${now.getFullYear()}-${pad(now.getMonth() + 1)}-${pad(now.getDate())}T${pad(now.getHours())}:${pad(now.getMinutes())}`;
            }
            // Initialize empty image preview
            ui.updateImagePreview(document.querySelector(SELECTORS.containers.imagePreview), [], true);
        });
        
        // Handle due date checkbox toggle
        const setDueDateCheckbox = document.getElementById('setDueDateCheckbox');
        const dueDateInput = document.getElementById('memoDueDate');
        const dueDateContainer = document.getElementById('dueDateInputContainer');
        
        if (setDueDateCheckbox && dueDateInput && dueDateContainer) {
            setDueDateCheckbox.addEventListener('change', function() {
                if (this.checked) {
                    // Show date input and set to today 23:59
                    dueDateContainer.style.display = 'block';
                    const now = new Date();
                    now.setHours(23, 59, 0, 0);
                    const pad = n => n.toString().padStart(2, '0');
                    dueDateInput.value = `${now.getFullYear()}-${pad(now.getMonth() + 1)}-${pad(now.getDate())}T${pad(now.getHours())}:${pad(now.getMinutes())}`;
                } else {
                    // Hide date input and set to far future date
                    dueDateContainer.style.display = 'none';
                    dueDateInput.value = '2099-01-01T23:59';
                }
            });
        }
        
        addMemoModal.addEventListener('hidden.bs.modal', () => {
            cleanBackdrops();
            const form = document.querySelector(SELECTORS.forms.addMemo);
            if (form) {
                form.reset();
                // Clear selected files and cleanup ObjectURLs
                state.selectedFilesAdd = [];
                state.objectURLs.forEach(url => URL.revokeObjectURL(url));
                state.objectURLs = [];
                const preview = document.querySelector(SELECTORS.containers.imagePreview);
                if (preview) preview.innerHTML = '';
            }
        });
    }
    
    // Setup editMemoModal cleanup
    const editMemoModal = document.getElementById('editMemoModal');
    if (editMemoModal) {
        editMemoModal.addEventListener('hidden.bs.modal', () => {
            cleanBackdrops();
            const form = document.querySelector(SELECTORS.forms.editMemo);
            if (form) {
                form.reset();
            }
            // Clear state and ObjectURLs
            state.selectedFilesEdit = [];
            state.existingImagesEdit = [];
            state.objectURLs.forEach(url => URL.revokeObjectURL(url));
            state.objectURLs = [];
            const preview = document.querySelector(SELECTORS.containers.editImagePreview);
            if (preview) preview.innerHTML = '';
            
            // If opened from calendar and not submitted, go back to calendar with preserved view
            if (noteManager.isInCalendarMode) {
                setTimeout(() => {
                    noteManager.backToCalendar();
                }, 300);
            }
        });
    }
    
    // Setup form submissions
    const setupFormHandler = (selector, handler) => {
        const form = document.querySelector(selector);
        if (form) form.addEventListener('submit', handler);
    };
    
    setupFormHandler(SELECTORS.forms.addMemo, async (e) => {
        e.preventDefault();
        
        try {
            // First create the note
            const formData = await api.prepareFormData(e.target, false, state.selectedFilesAdd, []);
            const data = await api.request('/add_note', {
                method: 'POST',
                body: formData
            });
            
            if (data?.status === 'success') {
                modals.addMemo.hide();
                
                // Refresh data from server (updateSearch already fetches and updates state.notes)
                await noteManager.updateSearch();
                ui.showFlashMessage('success', 'Memo added successfully');
            } else {
                ui.showFlashMessage('danger', data?.message || 'Failed to add memo');
            }
        } catch (error) {
            console.error('Add memo error:', error);
            ui.showFlashMessage('danger', 'Error adding memo');
        }
    });

    setupFormHandler(SELECTORS.forms.editMemo, async (e) => {
        e.preventDefault();
        
        try {
            const noteId = document.querySelector('#editMemoId').value;
            
            // ✅ KIỂM TRA: Validate form trước khi submit
            const title = document.querySelector('#editMemoTitle').value.trim();
            const content = document.querySelector('#editMemoContent').value.trim();
            
            if (!title) {
                ui.showFlashMessage('danger', 'Title is required');
                document.querySelector('#editMemoTitle').focus();
                return;
            }
            
            if (!content) {
                ui.showFlashMessage('danger', 'Content is required');
                document.querySelector('#editMemoContent').focus();
                return;
            }
            
            // ✅ SỬA: Sử dụng FormData trực tiếp từ form
            const formData = new FormData(e.target);
            
            // Add new images if any
            for (const file of state.selectedFilesEdit) {
                formData.append('images', file);
            }
            
            const data = await api.request(`/edit_note/${noteId}`, {
                method: 'POST',
                body: formData
            });
            
            if (data?.status === 'success') {
                modals.editMemo.hide();
                noteManager.updateSearch();
                ui.showFlashMessage('success', 'Memo updated successfully');
            } else {
                ui.showFlashMessage('danger', data?.message || 'Failed to update memo');
            }
        } catch (error) {
            console.error('Edit memo error:', error);
            ui.showFlashMessage('danger', 'Error updating memo');
        }
    });
    
    
    setupFormHandler(SELECTORS.forms.addCategory, (e) => {
        categoryManager.submitCategory(e);
    });
    
    // Setup file input handlers with validation
    const setupFileHandler = (selector, fileArray, previewContainer) => {
        const input = document.querySelector(selector);
        if (!input || input._fileHandlerSetup) return;
        input._fileHandlerSetup = true;
        
        // Click handler cho file input with validation
        input.addEventListener('change', function() {
            const files = Array.from(this.files);
            
            if (fileArray === 'add') {
                const currentCount = state.selectedFilesAdd.length;
                const validFiles = imageManager.filterValidFiles(files, currentCount);
                if (validFiles.length > 0) {
                    state.selectedFilesAdd = [...state.selectedFilesAdd, ...validFiles];
                    ui.updateImagePreview(document.querySelector(previewContainer), state.selectedFilesAdd, true);
                }
            } else {
                const currentCount = state.existingImagesEdit.length + state.selectedFilesEdit.length;
                const validFiles = imageManager.filterValidFiles(files, currentCount);
                if (validFiles.length > 0) {
                    state.selectedFilesEdit = [...state.selectedFilesEdit, ...validFiles];
                    ui.updateImagePreview(document.querySelector(previewContainer), [...state.existingImagesEdit, ...state.selectedFilesEdit], false);
                }
            }
            
            // Reset input to allow selecting same file again
            this.value = '';
        });
        
        // Make preview area clickable to trigger file input
        const previewEl = document.querySelector(previewContainer);
        if (previewEl && !previewEl._clickHandlerSetup) {
            previewEl._clickHandlerSetup = true;
            previewEl.style.cursor = 'pointer';
            previewEl.addEventListener('click', (e) => {
                // Only trigger if clicking on empty area, placeholder, or not on existing images
                const isPlaceholder = e.target.closest('.image-drop-placeholder');
                const isPreviewItem = e.target.closest('.image-preview-item');
                if (e.target === previewEl || isPlaceholder || !isPreviewItem) {
                    input.click();
                }
            });
        }
    };
    
    setupFileHandler('#memoImages', 'add', SELECTORS.containers.imagePreview);
    setupFileHandler('#editMemoImages', 'edit', SELECTORS.containers.editImagePreview);
    
    // Setup search and filter handlers
    const searchInput = document.querySelector(SELECTORS.inputs.search);
    if (searchInput) {
        searchInput.addEventListener('input', utils.debounce(() => noteManager.updateSearch(), 300));
    }
    
    const showCompleted = document.getElementById('showCompleted');
    if (showCompleted) {
        showCompleted.addEventListener('change', () => noteManager.updateSearch());
    }
    
    // Setup delete confirmation
    document.addEventListener('click', (e) => {
        const deleteBtn = e.target.closest('.btn-delete-memo');
        if (deleteBtn) {
            const noteId = deleteBtn.dataset.noteId;
            const confirmBtn = document.getElementById('confirmDeleteBtn');
            if (confirmBtn) {
                confirmBtn.onclick = async () => {
                    try {
                        const data = await api.request(`/delete_note/${noteId}`, { method: 'POST' });
                        if (data?.status === 'success') {
                            modals.confirmDelete.hide();
                            noteManager.updateSearch();
                            ui.showFlashMessage('success', 'Memo deleted successfully');
                        } else {
                            ui.showFlashMessage('danger', data?.message || 'Failed to delete memo');
                        }
                    } catch (error) {
                        ui.showFlashMessage('danger', 'Error deleting memo');
                    }
                };
                modals.confirmDelete.show();
            }
        }
    });
    

    // Setup calendar modal
    const calendarModal = document.getElementById('calendarModal');
if (calendarModal) {
    calendarModal.addEventListener('show.bs.modal', cleanBackdrops);
    calendarModal.addEventListener('shown.bs.modal', renderCalendar);
    
    // Add event listener for when calendar modal is closed
    calendarModal.addEventListener('hidden.bs.modal', async () => {
        cleanBackdrops();
        
        // Reset calendar mode and view state ONLY when modal is truly closed
        if (!noteManager.isInCalendarMode) {
            console.log('Calendar modal closed, resetting state'); // Debug log
            noteManager.currentCalendarView = null;
            
            // Refresh main screen data when calendar is closed
            try {
                await noteManager.refreshData();
                noteManager.updateSearch(); // Refresh the main view
            } catch (error) {
                console.error('Error refreshing main screen:', error);
            }
        } else {
            console.log('Calendar modal hidden but still in calendar mode'); // Debug log
        }
        
        // Always reset when truly closing calendar
        setTimeout(() => {
            if (!document.getElementById('calendarModal').classList.contains('show')) {
                noteManager.isInCalendarMode = false;
                noteManager.currentCalendarView = null;
                console.log('Calendar truly closed, state reset'); // Debug log
            }
        }, 500);
    });
}

    // Setup modal event listeners
    const viewMemoModal = document.getElementById('viewMemoModal');
    if (viewMemoModal) {
        viewMemoModal.addEventListener('hidden.bs.modal', () => {
            cleanBackdrops();
            // If opened from calendar, go back to calendar with preserved view
            if (noteManager.isInCalendarMode) {
                setTimeout(() => {
                    noteManager.backToCalendar();
                }, 300);
            }
        });
    }
    
    // Initialize UI
    ui.updateCategorySelect();
    noteManager.updateEventListeners();
    ui.highlightDueDates();
    
    // Setup manage categories modal
    const manageCategoriesModal = document.getElementById('manageCategoriesModal');
    if (manageCategoriesModal) {
        manageCategoriesModal.addEventListener('shown.bs.modal', () => {
            // Attach event listeners when modal is shown
            eventHandlers.attachCategoryEventListeners();
            categoryManager.resetForm();
        });
        
        manageCategoriesModal.addEventListener('hidden.bs.modal', () => {
            cleanBackdrops();
            categoryManager.resetForm();
        });
    }

    // Make functions globally available
    window.openViewMemoModal = (noteId) => noteManager.openViewModal(noteId, false); // Default not from calendar
    window.openEditMemoModal = (noteId) => noteManager.openEditModal(noteId, false); // Default not from calendar

    // Check URL parameters and open edit modal if needed
    const urlParams = new URLSearchParams(window.location.search);
    const editTaskId = urlParams.get('edit');
    if (editTaskId) {
        // Wait for data to be loaded then open edit modal
        setTimeout(() => {
            window.openEditMemoModal(editTaskId);
            // Clean URL after opening modal
            window.history.replaceState({}, document.title, window.location.pathname);
        }, 500);
    }
});

// === IMAGE UPLOAD MANAGEMENT (Tham khảo từ evernote) ===
const imageManager = {
    _dropZonesSetup: false, // Flag to prevent duplicate setup
    
    // Validate file before adding
    validateFile(file) {
        // Check file size
        if (file.size > IMAGE_CONFIG.maxFileSize) {
            const sizeMB = (file.size / 1024 / 1024).toFixed(2);
            return { valid: false, error: `File "${file.name}" is too large (${sizeMB}MB). Max size is ${IMAGE_CONFIG.maxFileSize / 1024 / 1024}MB.` };
        }
        
        // Check file type
        const ext = '.' + file.name.split('.').pop().toLowerCase();
        const isValidType = IMAGE_CONFIG.allowedTypes.includes(file.type) || 
                           IMAGE_CONFIG.allowedExtensions.includes(ext);
        if (!isValidType) {
            return { valid: false, error: `File "${file.name}" is not a supported image format.` };
        }
        
        return { valid: true };
    },
    
    // Filter and validate files
    filterValidFiles(files, currentCount) {
        const validFiles = [];
        const errors = [];
        
        for (const file of files) {
            // Check max files limit
            if (currentCount + validFiles.length >= IMAGE_CONFIG.maxFiles) {
                errors.push(`Maximum ${IMAGE_CONFIG.maxFiles} images allowed.`);
                break;
            }
            
            const validation = this.validateFile(file);
            if (validation.valid) {
                validFiles.push(file);
            } else {
                errors.push(validation.error);
            }
        }
        
        if (errors.length > 0) {
            ui.showFlashMessage('warning', errors[0]);
        }
        
        return validFiles;
    },
    
    // Drag & Drop handlers
    setupDragAndDrop() {
        // Prevent duplicate setup
        if (this._dropZonesSetup) return;
        this._dropZonesSetup = true;
        
        // Setup cho Add Modal
        this.setupDropZone('#addMemoModal .modal-body', () => state.selectedFilesAdd, (files) => {
            const validFiles = this.filterValidFiles(files, state.selectedFilesAdd.length);
            if (validFiles.length > 0) {
                state.selectedFilesAdd = [...state.selectedFilesAdd, ...validFiles];
                ui.updateImagePreview(document.querySelector('#imagePreview'), state.selectedFilesAdd, true);
            }
        });
        
        // Setup cho Edit Modal
        this.setupDropZone('#editMemoModal .modal-body', () => [...state.existingImagesEdit, ...state.selectedFilesEdit], (files) => {
            const currentCount = state.existingImagesEdit.length + state.selectedFilesEdit.length;
            const validFiles = this.filterValidFiles(files, currentCount);
            if (validFiles.length > 0) {
                state.selectedFilesEdit = [...state.selectedFilesEdit, ...validFiles];
                ui.updateImagePreview(document.querySelector('#editImagePreview'), [...state.existingImagesEdit, ...state.selectedFilesEdit], false);
            }
        });
    },

    setupDropZone(selector, getCurrentFiles, setFiles) {
        const dropZone = document.querySelector(selector);
        if (!dropZone || dropZone._dropZoneSetup) return;
        dropZone._dropZoneSetup = true; // Mark as setup

        // Prevent default drag behaviors
        ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
            dropZone.addEventListener(eventName, this.preventDefaults, false);
        });

        // Highlight drop zone when item is dragged over it
        ['dragenter', 'dragover'].forEach(eventName => {
            dropZone.addEventListener(eventName, () => this.highlight(dropZone), false);
        });

        ['dragleave', 'drop'].forEach(eventName => {
            dropZone.addEventListener(eventName, () => this.unhighlight(dropZone), false);
        });

        // Handle dropped files
        dropZone.addEventListener('drop', (e) => {
            const files = Array.from(e.dataTransfer.files).filter(file => 
                file.type.startsWith('image/') || file.name.toLowerCase().endsWith('.heic')
            );
            
            if (files.length > 0) {
                setFiles(files);
                ui.showFlashMessage('success', `${files.length} image(s) added`);
            }
        }, false);
    },

    preventDefaults(e) {
        e.preventDefault();
        e.stopPropagation();
    },

    highlight(element) {
        element.style.backgroundColor = 'rgba(13, 110, 253, 0.1)';
        element.style.border = '2px dashed #007bff';
        element.style.borderRadius = '8px';
    },

    unhighlight(element) {
        element.style.backgroundColor = '';
        element.style.border = '';
        element.style.borderRadius = '';
    },

    // Upload images to server (tương tự evernote)
    async uploadImages(files, noteId) {
        if (!files || files.length === 0) return [];

        const formData = new FormData();
        formData.append('note_id', noteId);

        // Append files without compression (server sẽ xử lý)
        for (const file of files) {
            formData.append('images', file);
        }

        try {
            const response = await fetch('/upload_task_images', {
                method: 'POST',
                body: formData,
                headers: {
                    'X-Requested-With': 'XMLHttpRequest'
                }
            });

            const result = await response.json();
            if (result.status === 'success') {
                return result.images || [];
            } else {
                throw new Error(result.message || 'Upload failed');
            }
        } catch (error) {
            ui.showFlashMessage('danger', `Image upload failed: ${error.message}`);
            return [];
        }
    },

    // Delete image from server
    async deleteImage(noteId, filename) {
        try {
            const response = await fetch('/delete_task_image', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'X-Requested-With': 'XMLHttpRequest'
                },
                body: JSON.stringify({
                    note_id: noteId,
                    filename: filename
                })
            });

            const result = await response.json();
            if (result.status !== 'success') {
                throw new Error(result.message || 'Delete failed');
            }
            
            return result;
        } catch (error) {
            ui.showFlashMessage('danger', `Failed to delete image: ${error.message}`);
            throw error;
        }
    },

    // Create image preview (cập nhật để dùng file paths)
    createImagePreview(fileObj, index, onRemove, noteId = null) {
        const wrapper = document.createElement('div');
        wrapper.className = 'position-relative image-preview-item';
        wrapper.style.cssText = `
            display: inline-block;
            margin: 5px;
            border: 1px solid #ddd;
            border-radius: 8px;
            overflow: hidden;
            background: #f8f9fa;
            transition: all 0.3s ease;
        `;

        const imgContainer = document.createElement('div');
        imgContainer.style.cssText = `
            width: 120px;
            height: 120px;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            overflow: hidden;
        `;

        // Create image element based on file type
        if (fileObj?.path) {
            // Existing image from server (file storage)
            const img = document.createElement('img');
            img.src = fileObj.path;
            img.alt = fileObj.original_name || 'Image';
            img.loading = 'lazy'; // Lazy load for performance
            img.style.cssText = 'max-width: 100%; max-height: 100%; object-fit: contain; cursor: pointer;';
            img.onclick = () => this.showImageModal(fileObj.path);
            img.onerror = () => {
                imgContainer.innerHTML = `
                    <div style="text-align: center; color: #dc3545;">
                        <i class="bi bi-exclamation-triangle" style="font-size: 1.5rem;"></i>
                        <div style="font-size: 0.7rem; margin-top: 5px;">Image not found</div>
                    </div>
                `;
            };
            imgContainer.appendChild(img);
        } else if (fileObj instanceof File) {
            // New file being uploaded
            if (fileObj.type === 'image/heic' || fileObj.name?.toLowerCase().endsWith('.heic')) {
                imgContainer.innerHTML = `
                    <div style="text-align: center; color: #6c757d;">
                        <i class="bi bi-image" style="font-size: 2rem;"></i>
                        <div style="font-size: 0.8rem; margin-top: 5px;">HEIC</div>
                        <div style="font-size: 0.7rem; max-width: 100px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;" title="${fileObj.name}">${fileObj.name}</div>
                    </div>
                `;
            } else {
                const objectURL = URL.createObjectURL(fileObj);
                state.objectURLs.push(objectURL); // Track for cleanup
                const img = document.createElement('img');
                img.src = objectURL;
                img.alt = fileObj.name;
                img.style.cssText = 'max-width: 100%; max-height: 100%; object-fit: contain; cursor: pointer;';
                img.onclick = () => this.showImageModal(objectURL);
                imgContainer.appendChild(img);
            }
        }

        // Remove button
        const removeBtn = document.createElement('button');
        removeBtn.type = 'button';
        removeBtn.className = 'btn btn-danger btn-sm';
        removeBtn.style.cssText = `
            position: absolute;
            top: 5px;
            right: 5px;
            width: 24px;
            height: 24px;
            padding: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
            z-index: 10;
        `;
        removeBtn.innerHTML = '<i class="bi bi-x" style="font-size: 0.8rem;"></i>';
        
        // Handle remove button click
        removeBtn.onclick = async () => {
            if (fileObj?.filename && noteId) {
                // Delete from server
                try {
                    await this.deleteImage(noteId, fileObj.filename);
                    onRemove(index);
                } catch (error) {
                    // Error already shown in deleteImage
                }
            } else {
                // Remove from local array
                onRemove(index);
            }
        };

        wrapper.appendChild(imgContainer);
        wrapper.appendChild(removeBtn);

        // Hover effects
        wrapper.addEventListener('mouseenter', () => {
            wrapper.style.transform = 'scale(1.05)';
            wrapper.style.boxShadow = '0 4px 12px rgba(0,0,0,0.15)';
        });

        wrapper.addEventListener('mouseleave', () => {
            wrapper.style.transform = 'scale(1)';
            wrapper.style.boxShadow = 'none';
        });

        return wrapper;
    },

    showImageModal(src) {
        const enlargedImg = document.querySelector('#enlargedImage');
        if (enlargedImg) {
            enlargedImg.src = src;
            modals.imageView.show();
        }
    }
};
</script>
{% endblock %}