{% extends "Mindmap/base.html" %}

{% block head %}
<style>
    /* Mindmap specific styles */
    .mindmap-container {
        position: relative;
        width: 100%;
        height: calc(100vh - 200px);
        overflow: hidden;
        background: var(--card-bg);
        border-radius: 15px;
        box-shadow: 0 4px 20px rgba(0,0,0,0.1);
    }
    
    .mindmap-canvas {
        position: absolute;
        top: 0;
        left: 0;
        width: 50000px; /* Kích thước lớn để chứa tất cả node */
        height: 50000px;
        cursor: grab;
        background-image: 
            radial-gradient(circle, rgba(var(--primary-color-rgb), 0.1) 1px, transparent 1px);
        background-size: 20px 20px;
        background-color: var(--bg-color);
        transform-origin: 0 0; /* Đặt origin để scale chính xác */
    }

    .mindmap-canvas:active {
        cursor: grabbing;
    }
    
    .mindmap-node {
        position: absolute;
        min-width: 120px;
        min-height: 60px;
        background: var(--card-bg);
        border: 2px solid var(--primary-color);
        border-radius: 25px;
        padding: 10px 15px;
        cursor: move;
        user-select: none;
        box-shadow: 0 4px 15px rgba(0,0,0,0.1);
        transition: all 0.3s ease;
        display: flex;
        align-items: center;
        justify-content: center;
        font-weight: 500;
        color: var(--text-color);
    }
    
    .mindmap-node.dragging {
        transition: none;
        transform: scale(1.02);
        box-shadow: 0 8px 25px rgba(0,0,0,0.2);
        z-index: 1000;
    }
    
    .mindmap-node:hover {
        transform: scale(1.05);
        box-shadow: 0 6px 20px rgba(0,0,0,0.15);
    }
    
    .mindmap-node.selected {
        border-color: var(--accent-color);
        background: rgba(var(--accent-color-rgb), 0.1);
    }
    
    .mindmap-node.drop-target {
        border-color: var(--alert-danger-color);
        background: rgba(240, 25, 161, 0.2);
        box-shadow: 0 0 20px rgba(239, 17, 17, 0.8);
        transform: scale(1.05);
    }
    
    .mindmap-node.root {
        background: linear-gradient(135deg, var(--primary-color), var(--accent-color));
        color: white;
        font-size: 1.2rem;
        font-weight: 600;
        min-width: 150px;
        min-height: 80px;
    }
    
    .mindmap-connection {
        position: absolute;
        stroke: var(--primary-color);
        stroke-width: 2;
        fill: none;
        pointer-events: none;
    }
    
    .mindmap-toolbar {
        position: absolute;
        top: 10px;
        left: 10px;
        z-index: 1000;
        background: var(--card-bg);
        border-radius: 10px;
        padding: 10px;
        box-shadow: 0 4px 15px rgba(0,0,0,0.1);
        display: flex;
        gap: 10px;
        flex-wrap: wrap;
    }
    
    .mindmap-controls {
        position: absolute;
        top: 10px;
        right: 10px;
        z-index: 1000;
        background: var(--card-bg);
        border-radius: 10px;
        padding: 10px;
        box-shadow: 0 4px 15px rgba(0,0,0,0.1);
        display: flex;
        gap: 5px;
    }
    
    .node-editor {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        z-index: 1001;
        background: var(--card-bg);
        border-radius: 15px;
        padding: 20px;
        box-shadow: 0 10px 30px rgba(0,0,0,0.2);
        min-width: 300px;
        display: none;
    }
    
    .color-picker {
        display: flex;
        gap: 5px;
        margin: 10px 0;
    }
    
    .color-option {
        width: 30px;
        height: 30px;
        border-radius: 50%;
        cursor: pointer;
        border: 2px solid transparent;
        transition: all 0.3s ease;
    }
    
    .color-option:hover,
    .color-option.selected {
        border-color: var(--text-color);
        transform: scale(1.1);
    }
    
    .zoom-controls {
        display: flex;
        align-items: center;
        gap: 5px;
        background: var(--card-bg);
        border-radius: 20px;
        padding: 5px;
    }
    
    .btn-icon {
        width: 35px;
        height: 35px;
        border-radius: 50%;
        border: none;
        background: var(--primary-color);
        color: white;
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        transition: all 0.3s ease;
    }
    
    .btn-icon:hover {
        background: var(--accent-color);
        transform: scale(1.1);
    }
    
    .btn-icon:disabled {
        background: var(--secondary-color);
        cursor: not-allowed;
        transform: none;
    }
    
    .mindmap-list {
        background: var(--card-bg);
        border-radius: 15px;
        padding: 20px;
        margin-bottom: 20px;
    }
    
    .mindmap-item {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 15px;
        border-radius: 10px;
        margin-bottom: 10px;
        background: rgba(var(--primary-color-rgb), 0.05);
        transition: all 0.3s ease;
    }
    
    .mindmap-item:hover {
        background: rgba(var(--primary-color-rgb), 0.1);
        transform: translateX(5px);
    }
    
    .mindmap-meta {
        font-size: 0.9rem;
        color: var(--secondary-color);
    }
    
    .context-menu {
        position: absolute;
        background: var(--card-bg);
        border-radius: 8px;
        box-shadow: 0 4px 15px rgba(0,0,0,0.2);
        padding: 5px 0;
        z-index: 1002;
        display: none;
        min-width: 150px;
    }
    
    .context-menu-item {
        padding: 8px 15px;
        cursor: pointer;
        transition: background 0.2s ease;
        display: flex;
        align-items: center;
        gap: 8px;
    }
    
    .context-menu-item:hover {
        background: rgba(var(--primary-color-rgb), 0.1);
    }
</style>
{% endblock %}

{% block content %}
<div class="row">
    <div class="col-12">
        <div class="d-flex justify-content-between align-items-center mb-4">
            <h2><i class="bi bi-diagram-3 me-2"></i>Mind Map</h2>
            <div>
                <button class="btn btn-primary" onclick="createNewMindmap()">
                    <i class="bi bi-plus-circle me-1"></i>New Mind Map
                </button>
                <button class="btn btn-secondary" onclick="loadMindmaps()">
                    <i class="bi bi-folder2-open me-1"></i>Load
                </button>
            </div>
        </div>
    </div>
</div>

<!-- Mind Map List -->
<div id="mindmapList" class="mindmap-list" style="display: none;">
    <h4>Your Mind Maps</h4>
    <div id="mindmapItems"></div>
</div>

<!-- Main Mindmap Canvas -->
<div class="mindmap-container" id="mindmapContainer">
    
    <!-- Zoom Controls -->
    <div class="mindmap-controls">
        <button class="btn btn-sm btn-success" onclick="saveMindmap()" title="Save">
            <i class="bi bi-save"></i>
        </button>
        <button class="btn btn-sm btn-warning" onclick="exportMindmap()" title="Export">
            <i class="bi bi-download"></i>
        </button>
        <button class="btn btn-sm btn-info" onclick="importMindmap()" title="Import">
            <i class="bi bi-upload"></i>
        </button>
        <div class="zoom-controls">
            <button class="btn-icon" onclick="zoomOut()" title="Zoom Out">
                <i class="bi bi-dash"></i>
            </button>
            <span id="zoomLevel">100%</span>
            <button class="btn-icon" onclick="zoomIn()" title="Zoom In">
                <i class="bi bi-plus"></i>
            </button>
        </div>
        <button class="btn-icon" onclick="resetView()" title="Reset View">
            <i class="bi bi-house"></i>
        </button>
        <button class="btn-icon" onclick="autoLayout()" title="Auto Layout">
            <i class="bi bi-diagram-2"></i>
        </button>
        <button class="btn-icon" id="fullscreenBtn" onclick="toggleFullscreen()" title="Toàn màn hình">
            <i class="bi bi-arrows-fullscreen" id="fullscreenIcon"></i>
        </button>
    </div>
    
    <!-- Canvas -->
    <div class="mindmap-canvas" id="mindmapCanvas">
    </div>
    
    <!-- SVG for connections - placed outside canvas to avoid transform issues -->
    <svg id="connectionSvg" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 1; overflow: visible;"></svg>
</div>

<!-- Node Editor Modal -->
<div class="node-editor" id="nodeEditor">
    <h5>Edit Node</h5>
    <div class="mb-3">
        <label class="form-label">Text:</label>
        <input type="text" class="form-control" id="nodeText" placeholder="Enter node text">
    </div>
    <div class="mb-3">
        <label class="form-label">Color:</label>
        <div class="color-picker">
            <div class="color-option" style="background: #3498db" data-color="#3498db"></div>
            <div class="color-option" style="background: #e74c3c" data-color="#e74c3c"></div>
            <div class="color-option" style="background: #2ecc71" data-color="#2ecc71"></div>
            <div class="color-option" style="background: #f39c12" data-color="#f39c12"></div>
            <div class="color-option" style="background: #9b59b6" data-color="#9b59b6"></div>
            <div class="color-option" style="background: #1abc9c" data-color="#1abc9c"></div>
            <div class="color-option" style="background: #34495e" data-color="#34495e"></div>
        </div>
    </div>
    <div class="mb-3">
        <label class="form-label">Font Size:</label>
        <select class="form-select" id="nodeFontSize">
            <option value="12px">Small</option>
            <option value="14px" selected>Medium</option>
            <option value="16px">Large</option>
            <option value="18px">Extra Large</option>
        </select>
    </div>
    <div class="d-flex gap-2">
        <button class="btn btn-primary" onclick="saveNodeEdit()">Save</button>
        <button class="btn btn-secondary" onclick="cancelNodeEdit()">Cancel</button>
    </div>
</div>

<!-- Context Menu -->
<div class="context-menu" id="contextMenu">
    <div class="context-menu-item" onclick="addChildNode()">
        <i class="bi bi-plus-circle"></i>
        Add Child
    </div>
    <div class="context-menu-item" onclick="editNode()">
        <i class="bi bi-pencil"></i>
        Edit
    </div>
    <div class="context-menu-item" onclick="deleteNode()">
        <i class="bi bi-trash"></i>
        Delete
    </div>
    <div class="context-menu-item" onclick="changeNodeColor()">
        <i class="bi bi-palette"></i>
        Change Color
    </div>
</div>

<!-- Save Modal -->
<div class="modal fade" id="saveModal" tabindex="-1">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title">Save Mind Map</h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
            </div>
            <div class="modal-body">
                <div class="mb-3">
                    <label class="form-label">Title:</label>
                    <input type="text" class="form-control" id="mindmapTitle" placeholder="Enter title">
                </div>
                <div class="mb-3">
                    <label class="form-label">Description:</label>
                    <textarea class="form-control" id="mindmapDescription" rows="3" placeholder="Enter description (optional)"></textarea>
                </div>
                <div class="mb-3">
                    <label class="form-label">Category:</label>
                    <select class="form-select" id="mindmapCategory">
                        <option value="personal">Personal</option>
                        <option value="work">Work</option>
                        <option value="study">Study</option>
                        <option value="project">Project</option>
                    </select>
                </div>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancel</button>
                <button type="button" class="btn btn-primary" onclick="confirmSaveMindmap()">Save</button>
            </div>
        </div>
    </div>
</div>
{% endblock %}

{% block scripts %}
{{ super() }}
<script>
class MindMap {
    constructor() {
        this.nodes = new Map();
        this.connections = [];
        this.selectedNode = null;
        this.editingNode = null;
        this.zoom = 1;
        this.panX = 0;
        this.panY = 0;
        this.isDragging = false;
        this.dragOffset = { x: 0, y: 0 };
        this.nodeIdCounter = 1;
        this.currentMindmapId = null;
        this.draggedNode = null;
        this.potentialParent = null;
        
        this.canvas = document.getElementById('mindmapCanvas');
        this.svg = document.getElementById('connectionSvg');
        this.container = document.getElementById('mindmapContainer');
        
        this.initializeEvents();
        this.createRootNode();
    }
    
    initializeEvents() {
        // Canvas events
        this.canvas.addEventListener('mousedown', this.onCanvasMouseDown.bind(this));
        this.canvas.addEventListener('mousemove', this.onCanvasMouseMove.bind(this));
        this.canvas.addEventListener('mouseup', this.onCanvasMouseUp.bind(this));
        this.canvas.addEventListener('wheel', this.onCanvasWheel.bind(this));
        this.canvas.addEventListener('contextmenu', this.onCanvasContextMenu.bind(this));
        
        // Color picker events
        document.querySelectorAll('.color-option').forEach(option => {
            option.addEventListener('click', () => {
                document.querySelectorAll('.color-option').forEach(o => o.classList.remove('selected'));
                option.classList.add('selected');
            });
        });
        
        // Hide context menu on click outside
        document.addEventListener('click', () => {
            document.getElementById('contextMenu').style.display = 'none';
        });
    }
    
    createRootNode() {
        // Đặt node trung tâm ở giữa mindmap-canvas (canvas mới: 50000x50000)
        const canvasWidth = 50000;
        const canvasHeight = 50000;
        const nodeWidth = 150; // root node min-width
        const nodeHeight = 80; // root node min-height
        const centerX = canvasWidth / 2 - nodeWidth / 2;
        const centerY = canvasHeight / 2 - nodeHeight / 2;
        const node = this.createNode(
            centerX,
            centerY,
            'Central Idea',
            true
        );
        this.selectNode(node);

        // Đặt vùng hiển thị (container) sao cho node trung tâm nằm giữa vùng nhìn thấy
        this.zoom = 1;
        const containerRect = this.container.getBoundingClientRect();
        this.panX = (containerRect.width / 2) - (centerX + nodeWidth / 2);
        this.panY = (containerRect.height / 2) - (centerY + nodeHeight / 2);
        this.updateCanvasTransform();
        this.updateZoomDisplay();
    }
    
    createNode(x, y, text = 'Node', isRoot = false) {
        // Tạo node id duy nhất dựa trên timestamp và random (tránh trùng khi import/export)
        const nodeId = `node_${Date.now()}_${Math.floor(Math.random() * 1000000)}`;
        const nodeElement = document.createElement('div');
        nodeElement.className = `mindmap-node ${isRoot ? 'root' : ''}`;
        nodeElement.id = nodeId;
        nodeElement.style.left = x + 'px';
        nodeElement.style.top = y + 'px';
        nodeElement.textContent = text;

        nodeElement.addEventListener('mousedown', (e) => this.onNodeMouseDown(e, nodeElement));
        nodeElement.addEventListener('dblclick', () => this.editNode(this.nodes.get(nodeElement.id)));
        nodeElement.addEventListener('contextmenu', (e) => this.onNodeContextMenu(e, nodeElement));

        this.canvas.appendChild(nodeElement);

        const nodeData = {
            id: nodeId,
            element: nodeElement,
            x: x,
            y: y,
            text: text,
            isRoot: isRoot,
            color: isRoot ? '#3498db' : '#ffffff',
            fontSize: '14px',
            parent: null,
            children: []
        };

        this.nodes.set(nodeId, nodeData);
        return nodeData;
    }
    
    resizeCanvasIfNeeded() {
        const nodes = Array.from(this.nodes.values());
        let maxWidth = 50000; // Kích thước canvas mặc định
        let maxHeight = 50000;

        nodes.forEach(node => {
            const right = node.x + node.element.offsetWidth;
            const bottom = node.y + node.element.offsetHeight;
            maxWidth = Math.max(maxWidth, right + 500); // Thêm padding
            maxHeight = Math.max(maxHeight, bottom + 500);
        });

        this.canvas.style.width = `${maxWidth}px`;
        this.canvas.style.height = `${maxHeight}px`;
        this.svg.style.width = `${maxWidth}px`;
        this.svg.style.height = `${maxHeight}px`;
    }

    onNodeMouseDown(e, nodeElement) {
        e.stopPropagation();
        this.selectNode(this.nodes.get(nodeElement.id));
        
        this.isDragging = true;
        this.draggedNode = this.selectedNode;
        nodeElement.classList.add('dragging');
        const rect = this.canvas.getBoundingClientRect();
        this.dragOffset = {
            x: (e.clientX - rect.left - this.panX) / this.zoom - nodeElement.offsetLeft,
            y: (e.clientY - rect.top - this.panY) / this.zoom - nodeElement.offsetTop
        };
    }
    
    onCanvasMouseDown(e) {
        if (e.target === this.canvas) {
            this.selectedNode = null;
            this.updateNodeSelection();
            
            // Start panning
            this.isPanning = true;
            this.lastPanPoint = { x: e.clientX, y: e.clientY };
        }
    }
    
    onCanvasMouseMove(e) {
        const rect = this.canvas.getBoundingClientRect();
        const mouseX = (e.clientX - rect.left - this.panX) / this.zoom;
        const mouseY = (e.clientY - rect.top - this.panY) / this.zoom;

        if (this.isDragging && this.selectedNode) {
            const newX = mouseX - this.dragOffset.x;
            const newY = mouseY - this.dragOffset.y;

            this.selectedNode.x = newX;
            this.selectedNode.y = newY;
            this.selectedNode.element.style.left = newX + 'px';
            this.selectedNode.element.style.top = newY + 'px';

            // Kiểm tra node nào đang được drag qua
            this.checkDropTarget(newX, newY);

            this.updateConnections();
            this.resizeCanvasIfNeeded();
        } else if (this.isPanning) {
            const deltaX = e.clientX - this.lastPanPoint.x;
            const deltaY = e.clientY - this.lastPanPoint.y;

            this.panX += deltaX;
            this.panY += deltaY;

            this.updateCanvasTransform();
            this.lastPanPoint = { x: e.clientX, y: e.clientY };
        }
    }
    
    onCanvasMouseUp(e) {
        if (this.isDragging && this.selectedNode) {
            this.selectedNode.element.classList.remove('dragging');
            
            // Nếu có potential parent và khác với parent hiện tại, thay đổi parent
            if (this.potentialParent && this.potentialParent !== this.selectedNode && 
                this.potentialParent.id !== this.selectedNode.parent) {
                this.changeNodeParent(this.selectedNode, this.potentialParent);
                
                // Force immediate update of connections after parent change
                requestAnimationFrame(() => {
                    this.updateConnections();
                });
            }
            
            // Clear drop target highlight
            this.clearDropTargets();
        }
        this.isDragging = false;
        this.isPanning = false;
        this.draggedNode = null;
        this.potentialParent = null;
        
        // Update connections one final time to ensure they're correct
        if (this.selectedNode) {
            requestAnimationFrame(() => {
                this.updateConnections();
            });
        }
    }
    
    onCanvasWheel(e) {
        e.preventDefault();
        // Lấy vị trí con trỏ chuột so với container (vùng hiển thị)
        const containerRect = this.container.getBoundingClientRect();
        const mouseX = e.clientX - containerRect.left;
        const mouseY = e.clientY - containerRect.top;

        // Nếu muốn zoom theo trung tâm màn hình, lấy giữa container
        const centerX = containerRect.width / 2;
        const centerY = containerRect.height / 2;

        // Tính vị trí điểm trung tâm màn hình hiện tại trên canvas (trước khi zoom)
        const beforeZoomX = (centerX - this.panX) / this.zoom;
        const beforeZoomY = (centerY - this.panY) / this.zoom;

        // Thay đổi zoom
        const delta = e.deltaY > 0 ? 0.9 : 1.1;
        const newZoom = Math.max(0.1, Math.min(3, this.zoom * delta));

        // Sau khi zoom, tính lại panX, panY để điểm trung tâm vẫn giữ nguyên trên canvas
        this.panX = centerX - beforeZoomX * newZoom;
        this.panY = centerY - beforeZoomY * newZoom;
        this.zoom = newZoom;

        this.updateCanvasTransform();
        this.updateZoomDisplay();
    }
    
    onCanvasContextMenu(e) {
        e.preventDefault();
        if (e.target === this.canvas) {
            
        }
    }
    
    onNodeContextMenu(e, nodeElement) {
        e.preventDefault();
        e.stopPropagation();
        
        this.selectNode(this.nodes.get(nodeElement.id));
        
        const contextMenu = document.getElementById('contextMenu');
        contextMenu.style.display = 'block';

        contextMenu.style.left = e.clientX + 'px';
        contextMenu.style.top = e.clientY + 'px';
    }
    
    selectNode(node) {
        this.selectedNode = node;
        this.updateNodeSelection();
    }
    
    checkDropTarget(draggedX, draggedY) {
        // Clear previous drop target
        this.clearDropTargets();
        
        const draggedNode = this.selectedNode;
        if (!draggedNode) return;
        
        const draggedRect = {
            x: draggedX,
            y: draggedY,
            width: draggedNode.element.offsetWidth,
            height: draggedNode.element.offsetHeight
        };
        
        // Kiểm tra tất cả các node khác
        for (const [nodeId, node] of this.nodes) {
            if (nodeId === draggedNode.id) continue;
            
            const nodeRect = {
                x: node.x,
                y: node.y,
                width: node.element.offsetWidth,
                height: node.element.offsetHeight
            };
            
            // Kiểm tra overlap
            if (this.isOverlapping(draggedRect, nodeRect)) {
                // Không thể drop vào chính node con của nó (tránh circular reference)
                if (!this.isDescendant(node, draggedNode)) {
                    this.potentialParent = node;
                    node.element.classList.add('drop-target');
                    break;
                }
            }
        }
    }
    
    isOverlapping(rect1, rect2) {
        return !(rect1.x > rect2.x + rect2.width || 
                rect2.x > rect1.x + rect1.width || 
                rect1.y > rect2.y + rect2.height || 
                rect2.y > rect1.y + rect1.height);
    }
    
    isDescendant(parentNode, childNode) {
        // Kiểm tra xem parentNode có phải là con cháu của childNode không
        const visited = new Set();
        const checkChildren = (node) => {
            if (visited.has(node.id)) return false;
            visited.add(node.id);
            
            for (const childId of node.children) {
                if (childId === parentNode.id) return true;
                const child = this.nodes.get(childId);
                if (child && checkChildren(child)) return true;
            }
            return false;
        };
        return checkChildren(childNode);
    }
    
    clearDropTargets() {
        document.querySelectorAll('.drop-target').forEach(node => {
            node.classList.remove('drop-target');
        });
        this.potentialParent = null;
    }
    
    changeNodeParent(node, newParent) {
        // Xóa node khỏi parent cũ
        if (node.parent) {
            const oldParent = this.nodes.get(node.parent);
            if (oldParent) {
                oldParent.children = oldParent.children.filter(id => id !== node.id);
            }
            // Xóa connection cũ khỏi connections array
            this.connections = this.connections.filter(conn => 
                !(conn.from === node.parent && conn.to === node.id)
            );
        }
        // Thêm node vào parent mới
        node.parent = newParent.id;
        newParent.children.push(node.id);
        // Thêm connection mới
        this.connections.push({
            from: newParent.id,
            to: node.id
        });
        // Di chuyển node con ra cạnh node cha để tránh chồng lên nhau
        const offset = 5;
        node.x = newParent.x + newParent.element.offsetWidth + offset;
        node.y = newParent.y;
        node.element.style.left = node.x + 'px';
        node.element.style.top = node.y + 'px';
        // Cập nhật lại canvas và connections
        this.resizeCanvasIfNeeded();
        this.updateConnections();
        setTimeout(() => {
            this.updateConnections();
        }, 10);
    }
    
    updateNodeSelection() {
        document.querySelectorAll('.mindmap-node').forEach(node => {
            node.classList.remove('selected');
        });
        
        if (this.selectedNode) {
            this.selectedNode.element.classList.add('selected');
        }
    }
    
    updateCanvasTransform() {
        this.canvas.style.transform = `translate(${this.panX}px, ${this.panY}px) scale(${this.zoom})`;
        this.canvas.style.transformOrigin = '0 0';
        // Cập nhật connections khi transform canvas
        this.updateConnections();
    }
    
    updateZoomDisplay() {
        document.getElementById('zoomLevel').textContent = Math.round(this.zoom * 100) + '%';
    }
    
    addNode() {
        if (!this.selectedNode) {
            alert('Please select a parent node first');
            return;
        }
        
        const parentNode = this.selectedNode;
        const newX = parentNode.x + 200;
        const newY = parentNode.y + Math.random() * 100 - 50;
        
        const newNode = this.createNode(newX, newY);
        this.connectNodes(parentNode, newNode);
        this.selectNode(newNode);
        this.resizeCanvasIfNeeded(); // Gọi để mở rộng canvas
    }
    
    addNodeAt(x, y) {
        const newNode = this.createNode(x, y);
        this.selectNode(newNode);
    }
    
    addChildNode() {
        this.addNode();
        document.getElementById('contextMenu').style.display = 'none';
        this.resizeCanvasIfNeeded(); // Gọi để mở rộng canvas
    }
    
    deleteNode() {
        if (!this.selectedNode || this.selectedNode.isRoot) {
            return;
        }

        const nodeToDelete = this.selectedNode;
        const parentId = nodeToDelete.parent;
        const childrenIds = [...nodeToDelete.children];

        // Remove connections liên quan đến node bị xoá
        this.connections = this.connections.filter(conn =>
            conn.from !== nodeToDelete.id && conn.to !== nodeToDelete.id
        );

        // Xoá node khỏi danh sách con của parent
        if (parentId) {
            const parent = this.nodes.get(parentId);
            parent.children = parent.children.filter(id => id !== nodeToDelete.id);
        }

        // Nếu node có 1 parent và có >=1 child, nối tất cả child với parent
        if (parentId && childrenIds.length > 0) {
            const parent = this.nodes.get(parentId);
            childrenIds.forEach(childId => {
                const child = this.nodes.get(childId);
                if (child) {
                    // Xoá parent cũ (node bị xoá)
                    child.parent = parentId;
                    // Thêm child vào danh sách con của parent nếu chưa có
                    if (!parent.children.includes(childId)) {
                        parent.children.push(childId);
                    }
                    // Thêm connection mới
                    this.connections.push({
                        from: parentId,
                        to: childId
                    });
                }
            });
        }

        // Xoá parent của các child (nếu không có parent)
        if (!parentId && childrenIds.length > 0) {
            childrenIds.forEach(childId => {
                const child = this.nodes.get(childId);
                if (child) {
                    child.parent = null;
                }
            });
        }

        // Xoá node khỏi DOM và map
        nodeToDelete.element.remove();
        this.nodes.delete(nodeToDelete.id);

        this.selectedNode = null;
        this.updateNodeSelection();
        this.updateConnections();

        document.getElementById('contextMenu').style.display = 'none';
    }
    
    editNode(node = this.selectedNode) {
        if (!node) return;
        
        this.editingNode = node;
        document.getElementById('nodeText').value = node.text;
        document.getElementById('nodeFontSize').value = node.fontSize;
        
        // Set selected color
        document.querySelectorAll('.color-option').forEach(option => {
            option.classList.remove('selected');
            if (option.dataset.color === node.color) {
                option.classList.add('selected');
            }
        });
        
        document.getElementById('nodeEditor').style.display = 'block';
        document.getElementById('contextMenu').style.display = 'none';

        document.getElementById('nodeText').focus();
    }
    
    saveNodeEdit() {
        if (!this.editingNode) return;

        const newText = document.getElementById('nodeText').value.trim();
        const newFontSize = document.getElementById('nodeFontSize').value;
        const selectedColor = document.querySelector('.color-option.selected')?.dataset.color || '#ffffff';

        if (newText && this.editingNode && this.editingNode.element) {
            this.editingNode.text = newText;
            this.editingNode.fontSize = newFontSize;
            this.editingNode.color = selectedColor;

            this.editingNode.element.textContent = newText;
            this.editingNode.element.style.fontSize = newFontSize;
            this.editingNode.element.style.borderColor = selectedColor;

            if (!this.editingNode.isRoot) {
                this.editingNode.element.style.backgroundColor = selectedColor;
            }
            // Cập nhật lại connections vì node có thể thay đổi kích thước
            this.updateConnections();
        }

        this.cancelNodeEdit();
    }
    
    cancelNodeEdit() {
        document.getElementById('nodeEditor').style.display = 'none';
        this.editingNode = null;
    }
    
    connectNodes(fromNode, toNode) {
        // Set parent-child relationship
        fromNode.children.push(toNode.id);
        toNode.parent = fromNode.id;
        
        // Add connection
        this.connections.push({
            from: fromNode.id,
            to: toNode.id
        });
        
        this.updateConnections();
    }
    
    updateConnections() {
        // Clear existing connections first
        this.svg.innerHTML = '';
        
        // Use requestAnimationFrame to ensure DOM has been updated
        requestAnimationFrame(() => {
            this.svg.innerHTML = '';

            function getRectEdgeIntersection(rect, cx, cy, tx, ty) {
                const dx = tx - cx;
                const dy = ty - cy;
                if (dx === 0 && dy === 0) return { x: cx, y: cy };

                const sides = [];
                if (dx !== 0) {
                    const t = (rect.left - cx) / dx;
                    if (t > 0 && t < 1) {
                        const y = cy + t * dy;
                        if (y >= rect.top && y <= rect.bottom) sides.push({ x: rect.left, y });
                    }
                }
                if (dx !== 0) {
                    const t = (rect.right - cx) / dx;
                    if (t > 0 && t < 1) {
                        const y = cy + t * dy;
                        if (y >= rect.top && y <= rect.bottom) sides.push({ x: rect.right, y });
                    }
                }
                if (dy !== 0) {
                    const t = (rect.top - cy) / dy;
                    if (t > 0 && t < 1) {
                        const x = cx + t * dx;
                        if (x >= rect.left && x <= rect.right) sides.push({ x, y: rect.top });
                    }
                }
                if (dy !== 0) {
                    const t = (rect.bottom - cy) / dy;
                    if (t > 0 && t < 1) {
                        const x = cx + t * dx;
                        if (x >= rect.left && x <= rect.right) sides.push({ x, y: rect.bottom });
                    }
                }
                if (sides.length === 0) return { x: cx, y: cy };
                sides.sort((a, b) => {
                    const da = (a.x - cx) ** 2 + (a.y - cy) ** 2;
                    const db = (b.x - cx) ** 2 + (b.y - cy) ** 2;
                    return da - db;
                });
                return sides[0];
            }

            // Lọc ra những connections hợp lệ (cả 2 node đều tồn tại)
            const validConnections = this.connections.filter(conn => 
                this.nodes.has(conn.from) && this.nodes.has(conn.to)
            );

            validConnections.forEach(conn => {
                const fromNode = this.nodes.get(conn.from);
                const toNode = this.nodes.get(conn.to);
                if (fromNode && toNode && fromNode.element && toNode.element) {
                    const line = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                    
                    // Lấy vị trí thực tế của node trên màn hình
                    const fromRect = fromNode.element.getBoundingClientRect();
                    const toRect = toNode.element.getBoundingClientRect();
                    const containerRect = this.container.getBoundingClientRect();
                    
                    // Tính toán vị trí tương đối với container
                    const fromX = fromRect.left - containerRect.left;
                    const fromY = fromRect.top - containerRect.top;
                    const fromWidth = fromRect.width;
                    const fromHeight = fromRect.height;
                    
                    const toX = toRect.left - containerRect.left;
                    const toY = toRect.top - containerRect.top;
                    const toWidth = toRect.width;
                    const toHeight = toRect.height;
                    
                    const fromNodeRect = {
                        left: fromX,
                        top: fromY,
                        right: fromX + fromWidth,
                        bottom: fromY + fromHeight
                    };
                    const toNodeRect = {
                        left: toX,
                        top: toY,
                        right: toX + toWidth,
                        bottom: toY + toHeight
                    };
                    
                    const fromCenterX = (fromNodeRect.left + fromNodeRect.right) / 2;
                    const fromCenterY = (fromNodeRect.top + fromNodeRect.bottom) / 2;
                    const toCenterX = (toNodeRect.left + toNodeRect.right) / 2;
                    const toCenterY = (toNodeRect.top + toNodeRect.bottom) / 2;
                    
                    const fromEdge = getRectEdgeIntersection(fromNodeRect, fromCenterX, fromCenterY, toCenterX, toCenterY);
                    const toEdge = getRectEdgeIntersection(toNodeRect, toCenterX, toCenterY, fromCenterX, fromCenterY);
                    
                    const midX = (fromEdge.x + toEdge.x) / 2;
                    const midY = (fromEdge.y + toEdge.y) / 2;
                    const controlX = midX + (fromEdge.y - toEdge.y) * 0.2;
                    const controlY = midY + (toEdge.x - fromEdge.x) * 0.2;
                    
                    const pathData = `M ${fromEdge.x} ${fromEdge.y} Q ${controlX} ${controlY} ${toEdge.x} ${toEdge.y}`;
                    line.setAttribute('d', pathData);
                    line.setAttribute('class', 'mindmap-connection');
                    line.setAttribute('stroke', '#3498db');
                    line.setAttribute('stroke-width', '2');
                    line.setAttribute('fill', 'none');
                    this.svg.appendChild(line);
                }
            });
        });
    }

    resetView() {
        const rootNode = Array.from(this.nodes.values()).find(node => node.isRoot);
        if (!rootNode) return;

        this.zoom = 1;
        const containerRect = this.container.getBoundingClientRect();
        const nodeWidth = rootNode.element.offsetWidth;
        const nodeHeight = rootNode.element.offsetHeight;
        this.panX = (containerRect.width / 2) - (rootNode.x + nodeWidth / 2);
        this.panY = (containerRect.height / 2) - (rootNode.y + nodeHeight / 2);
        this.updateCanvasTransform();
        this.updateZoomDisplay();

        // Đảm bảo connections luôn đúng sau khi transform
        requestAnimationFrame(() => this.updateConnections());
    }
    
    autoLayout() {
        const rootNode = Array.from(this.nodes.values()).find(node => node.isRoot);
        if (!rootNode) return;

        // Đưa node trung tâm về giữa mindmap-canvas
        const canvasWidth = 50000;
        const canvasHeight = 50000;
        const nodeWidth = rootNode.element.offsetWidth;
        const nodeHeight = rootNode.element.offsetHeight;
        rootNode.x = canvasWidth / 2 - nodeWidth / 2;
        rootNode.y = canvasHeight / 2 - nodeHeight / 2;
        rootNode.element.style.left = rootNode.x + 'px';
        rootNode.element.style.top = rootNode.y + 'px';

        // Sắp xếp các node con
        this.layoutRadial(rootNode);
        this.updateConnections();

        // Sau khi sắp xếp, đưa node trung tâm ra giữa vùng hiển thị
        requestAnimationFrame(() => {
            resetView();
        });
    }
    
    layoutRadial(rootNode) {
        // Giữ nguyên vị trí node trung tâm, chỉ layout các node con xung quanh nó
        const centerX = rootNode.x + rootNode.element.offsetWidth / 2;
        const centerY = rootNode.y + rootNode.element.offsetHeight / 2;
        this.layoutChildren(rootNode, centerX, centerY, 150, 0, 360);
    }
    
    layoutChildren(parentNode, centerX, centerY, radius, startAngle, endAngle) {
        const children = parentNode.children.map(id => this.nodes.get(id)).filter(Boolean);
        if (children.length === 0) return;
        
        const angleStep = (endAngle - startAngle) / Math.max(children.length, 1);
        
        children.forEach((child, index) => {
            const angle = startAngle + (index + 0.5) * angleStep;
            const radian = (angle * Math.PI) / 180;
            
            child.x = centerX + Math.cos(radian) * radius - child.element.offsetWidth / 2;
            child.y = centerY + Math.sin(radian) * radius - child.element.offsetHeight / 2;
            child.element.style.left = child.x + 'px';
            child.element.style.top = child.y + 'px';
            
            // Layout grandchildren
            const childAngleRange = angleStep * 0.8;
            const childStartAngle = angle - childAngleRange / 2;
            const childEndAngle = angle + childAngleRange / 2;
            
            this.layoutChildren(child, centerX, centerY, radius + 120, childStartAngle, childEndAngle);
        });
    }
    
    exportMindmap() {
        // Create a simple data structure for export
        const data = {
            title: this.currentMindmapId ? `Mindmap_${this.currentMindmapId}` : 'New_Mindmap',
            nodes: Array.from(this.nodes.values()).map(node => ({
                id: node.id,
                text: node.text,
                x: node.x,
                y: node.y,
                color: node.color,
                fontSize: node.fontSize,
                isRoot: node.isRoot,
                parent: node.parent,
                children: node.children
            })),
            connections: this.connections
        };
        
        // Export as JSON
        const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `${data.title}.json`;
        a.click();
        URL.revokeObjectURL(url);
    }
    
    importMindmap() {
        const input = document.createElement('input');
        input.type = 'file';
        input.accept = '.json';
        input.onchange = (e) => {
            const file = e.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = (event) => {
                    try {
                        const data = JSON.parse(event.target.result);
                        this.loadMindmapData(data);
                    } catch (error) {
                        alert('Invalid file format');
                        console.error('Import error:', error);
                    }
                };
                reader.readAsText(file);
            }
        };
        input.click();
    }
    
    loadMindmapData(data) {
        // Clear existing
        this.nodes.clear();
        this.connections = [];
        this.canvas.innerHTML = '';
        this.svg = document.getElementById('connectionSvg');
        
        // Load nodes
        if (data.nodes) {
            let maxId = 0;
            data.nodes.forEach(nodeData => {
                // Update counter to avoid ID conflicts
                const nodeNum = parseInt(nodeData.id.replace('node_', ''));
                if (nodeNum > maxId) maxId = nodeNum;
                
                const nodeElement = document.createElement('div');
                nodeElement.className = `mindmap-node ${nodeData.isRoot ? 'root' : ''}`;
                nodeElement.id = nodeData.id;
                nodeElement.style.left = nodeData.x + 'px';
                nodeElement.style.top = nodeData.y + 'px';
                nodeElement.style.fontSize = nodeData.fontSize || '14px';
                nodeElement.style.borderColor = nodeData.color || '#3498db';
                nodeElement.textContent = nodeData.text;
                
                if (!nodeData.isRoot && nodeData.color !== '#ffffff') {
                    nodeElement.style.backgroundColor = nodeData.color;
                }
                
                nodeElement.addEventListener('mousedown', (e) => this.onNodeMouseDown(e, nodeElement));
                nodeElement.addEventListener('dblclick', () => this.editNode(this.nodes.get(nodeElement.id)));
                nodeElement.addEventListener('contextmenu', (e) => this.onNodeContextMenu(e, nodeElement));
                
                this.canvas.appendChild(nodeElement);
                this.nodes.set(nodeData.id, {
                    ...nodeData,
                    element: nodeElement
                });
            });
            
            // Update node counter
            this.nodeIdCounter = maxId + 1;
        }
        
        // Load connections
        if (data.connections) {
            this.connections = data.connections;
            this.updateConnections();
        }
        
        this.resizeCanvasIfNeeded(); // Gọi để mở rộng canvas sau khi load
    }
    
    saveMindmap() {
        // Tự động điền lại thông tin mindmap hiện tại (nếu có)
        if (this.currentMindmapId) {
            document.getElementById('mindmapTitle').value = this.title || '';
            document.getElementById('mindmapDescription').value = this.description || '';
            document.getElementById('mindmapCategory').value = this.category || 'personal';
        } else {
            document.getElementById('mindmapTitle').value = '';
            document.getElementById('mindmapDescription').value = '';
            document.getElementById('mindmapCategory').value = 'personal';
        }
        new bootstrap.Modal(document.getElementById('saveModal')).show();
    }
    
    async confirmSave() {
        const title = document.getElementById('mindmapTitle').value.trim();
        const description = document.getElementById('mindmapDescription').value.trim();
        const category = document.getElementById('mindmapCategory').value;
        
        if (!title) {
            alert('Please enter a title');
            return;
        }
        
        const data = {
            title: title,
            description: description,
            category: category,
            nodes: Array.from(this.nodes.values()).map(node => ({
                id: node.id,
                text: node.text,
                x: node.x,
                y: node.y,
                color: node.color,
                fontSize: node.fontSize,
                isRoot: node.isRoot,
                parent: node.parent,
                children: node.children
            })),
            connections: this.connections
        };
        
        try {
            const url = this.currentMindmapId ? `/api/mindmaps/${this.currentMindmapId}` : '/api/mindmaps';
            const method = this.currentMindmapId ? 'PUT' : 'POST';
            
            const response = await fetch(url, {
                method: method,
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify(data)
            });
            
            if (response.ok) {
                const result = await response.json();
                this.currentMindmapId = result.id;
                bootstrap.Modal.getInstance(document.getElementById('saveModal')).hide();
                alert('Mind map saved successfully!');
            } else {
                const error = await response.text();
                console.error('Save error:', error);
                alert('Failed to save mind map: ' + error);
            }
        } catch (error) {
            console.error('Error saving mindmap:', error);
            alert('Error saving mind map: ' + error.message);
        }
    }
}

// Global functions
let mindmap;

function createNewMindmap() {
    document.getElementById('mindmapList').style.display = 'none';
    document.getElementById('mindmapContainer').style.display = 'block';
    mindmap = new MindMap();
}

function loadMindmaps() {
    document.getElementById('mindmapContainer').style.display = 'none';
    document.getElementById('mindmapList').style.display = 'block';
    fetchMindmaps();
}

async function fetchMindmaps() {
    try {
        const response = await fetch('/api/mindmaps');
        const mindmaps = await response.json();
        
        const container = document.getElementById('mindmapItems');
        container.innerHTML = '';
        
        mindmaps.forEach(mm => {
            const item = document.createElement('div');
            item.className = 'mindmap-item';
            item.innerHTML = `
                <div>
                    <h5>${mm.title}</h5>
                    <p class="mindmap-meta">${mm.description || 'No description'}</p>
                    <small class="text-muted">Category: ${mm.category} | Created: ${new Date(mm.created_at).toLocaleDateString()}</small>
                </div>
                <div>
                    <button class="btn btn-sm btn-primary me-2" onclick="loadMindmap(${mm.id})">
                        <i class="bi bi-folder-open"></i>
                    </button>
                    <button class="btn btn-sm btn-danger" onclick="deleteMindmap(${mm.id})">
                        <i class="bi bi-trash"></i>
                    </button>
                </div>
            `;
            container.appendChild(item);
        });
    } catch (error) {
        console.error('Error fetching mindmaps:', error);
    }
}

async function loadMindmap(id) {
    try {
        const response = await fetch(`/api/mindmaps/${id}`);
        const data = await response.json();
        
        document.getElementById('mindmapList').style.display = 'none';
        document.getElementById('mindmapContainer').style.display = 'block';
        
        mindmap = new MindMap();
        mindmap.currentMindmapId = id;
        
        // Clear existing nodes
        mindmap.nodes.clear();
        mindmap.connections = [];
        mindmap.nodeIdCounter = 1;
        document.getElementById('mindmapCanvas').innerHTML = '';
        mindmap.svg = document.getElementById('connectionSvg');
        
        // Load nodes
        data.nodes.forEach(nodeData => {
            const nodeElement = document.createElement('div');
            nodeElement.className = `mindmap-node ${nodeData.isRoot ? 'root' : ''}`;
            nodeElement.id = nodeData.id;
            nodeElement.style.left = nodeData.x + 'px';
            nodeElement.style.top = nodeData.y + 'px';
            nodeElement.style.fontSize = nodeData.fontSize;
            nodeElement.style.borderColor = nodeData.color;
            nodeElement.textContent = nodeData.text;
            
            if (!nodeData.isRoot) {
                nodeElement.style.backgroundColor = nodeData.color;
            }
            
            nodeElement.addEventListener('mousedown', (e) => mindmap.onNodeMouseDown(e, nodeElement));
            nodeElement.addEventListener('dblclick', () => mindmap.editNode(mindmap.nodes.get(nodeElement.id)));
            nodeElement.addEventListener('contextmenu', (e) => mindmap.onNodeContextMenu(e, nodeElement));
            
            mindmap.canvas.appendChild(nodeElement);
            mindmap.nodes.set(nodeData.id, {
                ...nodeData,
                element: nodeElement
            });
        });
        
        // Load connections
        mindmap.connections = data.connections;
        mindmap.updateConnections();
        
        mindmap.title = data.title;
        mindmap.description = data.description;
        mindmap.category = data.category;

    } catch (error) {
        console.error('Error loading mindmap:', error);
        alert('Error loading mind map');
    }
}

async function deleteMindmap(id) {
    if (!confirm('Are you sure you want to delete this mind map?')) return;
    
    try {
        const response = await fetch(`/api/mindmaps/${id}`, {
            method: 'DELETE'
        });
        
        if (response.ok) {
            fetchMindmaps();
        } else {
            alert('Failed to delete mind map');
        }
    } catch (error) {
        console.error('Error deleting mindmap:', error);
        alert('Error deleting mind map');
    }
}

function addNode() {
    mindmap?.addNode();
}

function deleteNode() {
    mindmap?.deleteNode();
}

function editNode() {
    mindmap?.editNode();
}

function saveMindmap() {
    mindmap?.saveMindmap();
}

function exportMindmap() {
    mindmap?.exportMindmap();
}

function importMindmap() {
    mindmap?.importMindmap();
}

function zoomIn() {
    if (mindmap) {
        const containerRect = mindmap.container.getBoundingClientRect();
        const centerX = containerRect.width / 2;
        const centerY = containerRect.height / 2;
        const beforeZoomX = (centerX - mindmap.panX) / mindmap.zoom;
        const beforeZoomY = (centerY - mindmap.panY) / mindmap.zoom;
        const newZoom = Math.min(3, mindmap.zoom * 1.1);
        mindmap.panX = centerX - beforeZoomX * newZoom;
        mindmap.panY = centerY - beforeZoomY * newZoom;
        mindmap.zoom = newZoom;
        mindmap.updateCanvasTransform();
        mindmap.updateZoomDisplay();
    }
}

function zoomOut() {
    if (mindmap) {
        const containerRect = mindmap.container.getBoundingClientRect();
        const centerX = containerRect.width / 2;
        const centerY = containerRect.height / 2;
        const beforeZoomX = (centerX - mindmap.panX) / mindmap.zoom;
        const beforeZoomY = (centerY - mindmap.panY) / mindmap.zoom;
        const newZoom = Math.max(0.1, mindmap.zoom * 0.9);
        mindmap.panX = centerX - beforeZoomX * newZoom;
        mindmap.panY = centerY - beforeZoomY * newZoom;
        mindmap.zoom = newZoom;
        mindmap.updateCanvasTransform();
        mindmap.updateZoomDisplay();
    }
}

function resetView() {
    if (mindmap) {
        // Tìm node trung tâm (root)
        const rootNode = Array.from(mindmap.nodes.values()).find(node => node.isRoot);
        if (!rootNode) return;

        // Đặt lại zoom về 1
        mindmap.zoom = 1;

        // Lấy kích thước vùng hiển thị (container) và node trung tâm
        const containerRect = mindmap.container.getBoundingClientRect();
        const nodeWidth = rootNode.element.offsetWidth;
        const nodeHeight = rootNode.element.offsetHeight;

        // Tính panX, panY để node trung tâm nằm giữa vùng hiển thị
        mindmap.panX = (containerRect.width / 2) - (rootNode.x + nodeWidth / 2);
        mindmap.panY = (containerRect.height / 2) - (rootNode.y + nodeHeight / 2);

        mindmap.updateCanvasTransform();
        mindmap.updateZoomDisplay();
    }
}

function autoLayout() {
    mindmap?.autoLayout();
}

function changeNodeColor() {
    mindmap?.editNode();
}

function saveNodeEdit() {
    mindmap?.saveNodeEdit();
}

function cancelNodeEdit() {
    mindmap?.cancelNodeEdit();
}

function addChildNode() {
    mindmap?.addChildNode();
}

function confirmSaveMindmap() {
    mindmap?.confirmSave();
}

// Initialize when page loads
document.addEventListener('DOMContentLoaded', function() {
    createNewMindmap();

    // Xử lý phím ESC để thoát toàn màn hình
    document.addEventListener('fullscreenchange', function() {
        const btn = document.getElementById('fullscreenBtn');
        const icon = document.getElementById('fullscreenIcon');
        if (document.fullscreenElement) {
            icon.classList.remove('bi-arrows-fullscreen');
            icon.classList.add('bi-fullscreen-exit');
            btn.title = 'Thoát toàn màn hình';
        } else {
            icon.classList.remove('bi-fullscreen-exit');
            icon.classList.add('bi-arrows-fullscreen');
            btn.title = 'Toàn màn hình';
        }
    });
});

function toggleFullscreen() {
    const container = document.getElementById('mindmapContainer');
    if (!document.fullscreenElement) {
        if (container.requestFullscreen) {
            container.requestFullscreen();
        } else if (container.webkitRequestFullscreen) {
            container.webkitRequestFullscreen();
        } else if (container.msRequestFullscreen) {
            container.msRequestFullscreen();
        }
    } else {
        if (document.exitFullscreen) {
            document.exitFullscreen();
        } else if (document.webkitExitFullscreen) {
            document.webkitExitFullscreen();
        } else if (document.msExitFullscreen) {
            document.msExitFullscreen();
        }
    }
}

document.addEventListener('fullscreenchange', function() {
    const container = document.getElementById('mindmapContainer');
    const nodeEditor = document.getElementById('nodeEditor');
    const contextMenu = document.getElementById('contextMenu');
    if (document.fullscreenElement === container) {
        // Nếu vào fullscreen, chuyển modal và context menu vào trong container
        container.appendChild(nodeEditor);
        container.appendChild(contextMenu);
    } else {
        // Nếu thoát fullscreen, chuyển modal và context menu ra ngoài container
        document.body.appendChild(nodeEditor);
        document.body.appendChild(contextMenu);
    }
});
</script>
{% endblock %}
